<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="AFL插桩（二）LLVM模式插桩"><meta name="keywords" content="Fuzz,AFL,Instrumentation"><meta name="author" content="HotSpurzzZ"><meta name="copyright" content="HotSpurzzZ"><title>AFL插桩（二）LLVM模式插桩 | HotSpurzzZ</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"atom.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="HotSpurzzZ" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81LLVM%E6%A8%A1%E5%BC%8F%E6%8F%92%E6%A1%A9%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、LLVM模式插桩概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81afl-clang-fast"><span class="toc-number">2.</span> <span class="toc-text">二、afl-clang-fast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81afl-llvm-pass"><span class="toc-number">3.</span> <span class="toc-text">三、afl-llvm-pass</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2021/09/28/5Oing3pmAYI6VtD.jpg"></div><div class="author-info__name text-center">HotSpurzzZ</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">22</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">HotSpurzzZ</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">AFL插桩（二）LLVM模式插桩</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Fuzz/">Fuzz</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>~~</p>
<span id="more"></span>
<h2 id="一、LLVM模式插桩概述"><a href="#一、LLVM模式插桩概述" class="headerlink" title="一、LLVM模式插桩概述"></a>一、LLVM模式插桩概述</h2><p>AFL的 <code>llvm_mode</code> 可以实现编译器级别的插桩，可以替代 <code>afl-gcc</code> 或 <code>afl-clang</code> 使用的比较“粗暴”的汇编级别的重写的方法</p>
<p>优点：</p>
<ul>
<li>编译器可以进行很多优化以提升效率</li>
<li>可以实现CPU无关，可以在非 x86 架构上进行fuzz</li>
<li>可以更好地处理多线程目标</li>
</ul>
<p>AFL的 <code>llvm_mode</code> 文件夹下包含3个文件：</p>
<ul>
<li><code>afl-llvm-rt.o.c</code> 文件主要是重写了 <code>afl-as.h</code> 文件中的 <code>main_payload</code> 部分，方便调用</li>
<li><code>afl-llvm-pass.so.cc</code> 文件主要是当通过 <code>afl-clang-fast</code> 调用 clang 时，这个pass被插入到 LLVM 中，告诉编译器添加与 <code>afl-as.h</code> 中大致等效的代码</li>
<li><code>afl-clang-fast.c</code> 文件本质上是 clang 的 wrapper，最终调用的还是 clang 。但是与 <code>afl-gcc</code> 一样，会进行一些参数处理。</li>
</ul>
<p><code>llvm_mode</code> 的插桩思路就是通过编写pass来实现信息记录，对每个基本块都插入探针，具体代码在 <code>afl-llvm-pass.so.cc</code> 文件中，初始化和forkserver操作通过链接完成</p>
<p>Clang 编译器，从源码至机器码的流程如下：</p>
<p><img src="/2022/05/21/AFL%E6%8F%92%E6%A1%A9%EF%BC%88%E4%BA%8C%EF%BC%89LLVM%E6%A8%A1%E5%BC%8F%E6%8F%92%E6%A1%A9/Untitled.png"></p>
<p>代码首先由编译器前端clang处理后得到中间代码IR，然后经过各 LLVM Pass 进行优化和转换，最终交给编译器后端生成机器码，其中LLVM Pass 可以在中间过程处理 IR 、用户自定义的内容，可以用来遍历、修改 IR 以达到<strong>插桩</strong>、优化、静态分析等目的。</p>
<p>AFL进入llvm_mode进行编译<code>afl-clang-fast</code>（注意：llvm和clang版本要一致）</p>
<p>一个坑：最开始使用的llvm和clang版本是14版本，但编译会报错；改为11版本可以正常编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root @ zzz in ~/Desktop/AFL/llvm_mode on git:master o [14:18:42] C:2</span></span><br><span class="line">$ make all</span><br><span class="line">[*] Checking <span class="keyword">for</span> working <span class="string">&#x27;llvm-config&#x27;</span>...</span><br><span class="line">[*] Checking <span class="keyword">for</span> working <span class="string">&#x27;clang&#x27;</span>...</span><br><span class="line">[*] Checking <span class="keyword">for</span> <span class="string">&#x27;../afl-showmap&#x27;</span>...</span><br><span class="line">[+] All <span class="built_in">set</span> and ready to build.</span><br><span class="line">clang -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/<span class="built_in">local</span>/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/<span class="built_in">local</span>/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  afl-clang-fast.c -o ../afl-clang-fast </span><br><span class="line">ln -sf afl-clang-fast ../afl-clang-fast++</span><br><span class="line">clang++ `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fpic -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DVERSION=\&quot;2.57b\&quot; -Wno-variadic-macros -shared afl-llvm-pass.so.cc -o ../afl-llvm-pass.so `llvm-config --ldflags` </span><br><span class="line">clang -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/<span class="built_in">local</span>/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/<span class="built_in">local</span>/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  -fPIC -c afl-llvm-rt.o.c -o ../afl-llvm-rt.o</span><br><span class="line">[*] Building 32-bit variant of the runtime (-m32)... failed (that<span class="string">&#x27;s fine)</span></span><br><span class="line"><span class="string">[*] Building 64-bit variant of the runtime (-m64)... success!</span></span><br><span class="line"><span class="string">[*] Testing the CC wrapper and instrumentation output...</span></span><br><span class="line"><span class="string">unset AFL_USE_ASAN AFL_USE_MSAN AFL_INST_RATIO; AFL_QUIET=1 AFL_PATH=. AFL_CC=clang ../afl-clang-fast -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  ../test-instr.c -o test-instr </span></span><br><span class="line"><span class="string">../afl-showmap -m none -q -o .test-instr0 ./test-instr &lt; /dev/null</span></span><br><span class="line"><span class="string">echo 1 | ../afl-showmap -m none -q -o .test-instr1 ./test-instr</span></span><br><span class="line"><span class="string">[+] All right, the instrumentation seems to be working!</span></span><br><span class="line"><span class="string">[+] All done! You can now use &#x27;</span>../afl-clang-fast<span class="string">&#x27; to compile programs.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># root @ zzz in ~/Desktop/AFL/llvm_mode on git:master o [14:19:27] </span></span><br><span class="line"><span class="string">$ llvm-config --version     </span></span><br><span class="line"><span class="string">11.1.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># root @ zzz in ~/Desktop/AFL/llvm_mode on git:master o [14:19:41] </span></span><br><span class="line"><span class="string">$ clang --version</span></span><br><span class="line"><span class="string">Ubuntu clang version 11.1.0-6</span></span><br><span class="line"><span class="string">Target: x86_64-pc-linux-gnu</span></span><br><span class="line"><span class="string">Thread model: posix</span></span><br><span class="line"><span class="string">InstalledDir: /usr/bi</span></span><br></pre></td></tr></table></figure>

<h2 id="二、afl-clang-fast"><a href="#二、afl-clang-fast" class="headerlink" title="二、afl-clang-fast"></a>二、<strong>afl-clang-fast</strong></h2><p>afl-clang-fast实际上是CC/CXX的wrapper。它定义了一些宏，设置了一些参数，最终调用真正的编译器（CC指代C语言编译器，CXX指代C++编译器）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Main entry point */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_TRACE_PC</span></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-clang-fast [tpcg] &quot;</span> cBRI VERSION  cRST <span class="string">&quot; by &lt;lszekeres@google.com&gt;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-clang-fast &quot;</span> cBRI VERSION  cRST <span class="string">&quot; by &lt;lszekeres@google.com&gt;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^USE_TRACE_PC */</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">        <span class="string">&quot;for clang, letting you recompile third-party code with the required runtime\n&quot;</span></span><br><span class="line">        <span class="string">&quot;instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;  CC=%s/afl-clang-fast ./configure\n&quot;</span></span><br><span class="line">        <span class="string">&quot;  CXX=%s/afl-clang-fast++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;In contrast to the traditional afl-clang tool, this version is implemented as\n&quot;</span></span><br><span class="line">        <span class="string">&quot;an LLVM pass and tends to offer improved performance with slow programs.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC and AFL_CXX. Setting\n&quot;</span></span><br><span class="line">        <span class="string">&quot;AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">        BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ANDROID__</span></span><br><span class="line">  <span class="comment">// 查找必备库&#x27;afl-llvm-rt.o&#x27; 或 &#x27;afl-llvm-pass.so&#x27;</span></span><br><span class="line">  find_obj(argv[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 设置CC或者CXX的参数</span></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line">  <span class="comment">// 调用execvp来执行CC或者CXX</span></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="keyword">char</span>**)cc_params);</span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、afl-llvm-pass"><a href="#三、afl-llvm-pass" class="headerlink" title="三、afl-llvm-pass"></a>三、<strong>afl-llvm-pass</strong></h2><p><code>afl-llvm-pass.so.cc</code>实现了 LLVM-mode 下的一个插桩 LLVM Pass</p>
<p>llvm_mode是怎么插桩的呢？答：IRBuilder</p>
<ul>
<li>afl-llvm-pass中，只有一个pass : <strong>AFLCoverage</strong>  该pass会在每一个基础块的第一个可插入指令处插桩，检测 <strong>控制流的覆盖程度</strong>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AFLCoverage</span> :</span> <span class="keyword">public</span> ModulePass &#123;</span><br></pre></td></tr></table></figure>
</li>
<li><code>runOnModule</code>函数首先找出当前线程上下文中所对应的IntegerType，并且打印banner  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AFLCoverage::runOnModule</span><span class="params">(Module &amp;M)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  LLVMContext &amp;C = M.getContext();</span><br><span class="line"></span><br><span class="line">  IntegerType *Int8Ty  = IntegerType::getInt8Ty(C);</span><br><span class="line">  IntegerType *Int32Ty = IntegerType::getInt32Ty(C);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Show a banner */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> be_quiet = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-llvm-pass &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lszekeres@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>之后获取预设的插桩密度（插桩率）  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Decide instrumentation ratio */</span></span><br><span class="line"><span class="comment">// 获取代码的插桩率（0-100）</span></span><br><span class="line"><span class="keyword">char</span>* inst_ratio_str = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> inst_ratio = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (inst_ratio_str) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || !inst_ratio ||</span><br><span class="line">      inst_ratio &gt; <span class="number">100</span>)</span><br><span class="line">    FATAL(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 1 and 100)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>获取全局变量中指向共享内存的指针，以及上一个基础块的编号；这个共享内存上存放着各个控制流流经次数的计数器  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get globals for the SHM region and the previous location. Note that</span></span><br><span class="line"><span class="comment">   __afl_prev_loc is thread-local. */</span></span><br><span class="line"><span class="comment">// 指向  用于输出控制流覆盖次数的共享内存  的指针</span></span><br><span class="line">GlobalVariable *AFLMapPtr =</span><br><span class="line">    <span class="keyword">new</span> GlobalVariable(M, PointerType::get(Int8Ty, <span class="number">0</span>), <span class="literal">false</span>,</span><br><span class="line">                       GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">&quot;__afl_area_ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AFLPrevLoc 用来表示前一个基本块的编号</span></span><br><span class="line">GlobalVariable *AFLPrevLoc = <span class="keyword">new</span> GlobalVariable(</span><br><span class="line">    M, Int32Ty, <span class="literal">false</span>, GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">&quot;__afl_prev_loc&quot;</span>,</span><br><span class="line">    <span class="number">0</span>, GlobalVariable::GeneralDynamicTLSModel, <span class="number">0</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>获取上述这些信息后，for循环开始遍历所有基本块，进行插桩：<ul>
<li>首先寻找BB中适合插入桩代码的位置，然后通过初始化 <code>IRBuilder</code> 实例执行插入：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Instrument all the things! */</span></span><br><span class="line"><span class="keyword">int</span> inst_blocks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;F : M)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;BB : F) &#123;</span><br><span class="line">    <span class="comment">// 在每一个基础块前都插入代码。先查找插入点</span></span><br><span class="line">    BasicBlock::iterator IP = BB.getFirstInsertionPt();</span><br><span class="line">    IRBuilder&lt;&gt; IRB(&amp;(*IP));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据代码插桩率，随机插桩</span></span><br><span class="line">    <span class="keyword">if</span> (AFL_R(<span class="number">100</span>) &gt;= inst_ratio) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>插入<code>load</code>指令，获取当前基础块与上一个基础块的编号  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 随机获取当前的基础块编号</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cur_loc = AFL_R(MAP_SIZE);</span><br><span class="line">ConstantInt *CurLoc = ConstantInt::get(Int32Ty, cur_loc);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Load prev_loc */</span></span><br><span class="line"><span class="comment">// 加载上一个基础块的编号</span></span><br><span class="line">LoadInst *PrevLoc = IRB.CreateLoad(AFLPrevLoc);</span><br><span class="line"><span class="comment">// Metadata在这里可以看作是一种调试信息</span></span><br><span class="line">PrevLoc-&gt;setMetadata(M.getMDKindID(<span class="string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));</span><br><span class="line">Value *PrevLocCasted = IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());</span><br></pre></td></tr></table></figure>
</li>
<li>插入<code>load</code>指令，获取共享内存地址；并通过上述两个编号，调用 <code>CreateGEP</code> 函数获取共享内存中指定index的地址  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Load SHM pointer */</span></span><br><span class="line">  <span class="comment">// 获取指向共享内存的指针</span></span><br><span class="line">  LoadInst *MapPtr = IRB.CreateLoad(AFLMapPtr);</span><br><span class="line">  MapPtr-&gt;setMetadata(M.getMDKindID(<span class="string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));</span><br><span class="line">  <span class="comment">// GEP: GetElementPtr</span></span><br><span class="line">  <span class="comment">// 根据当前基础块与上一个基础块的编号，计算指向特定地址的指针</span></span><br><span class="line">  Value *MapPtrIdx =</span><br><span class="line">      IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));</span><br></pre></td></tr></table></figure>
</li>
<li>插入<code>load</code>指令，获取对应index地址的值；同时插入<code>add</code>指令，使该地址上的计数器递增；再插入<code>store</code>指令写入新值，并更新共享内存  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Update bitmap */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该指针上的counter值自增一</span></span><br><span class="line">LoadInst *Counter = IRB.CreateLoad(MapPtrIdx);</span><br><span class="line">Counter-&gt;setMetadata(M.getMDKindID(<span class="string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));</span><br><span class="line">Value *Incr = IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, <span class="number">1</span>));</span><br><span class="line">IRB.CreateStore(Incr, MapPtrIdx)</span><br><span class="line">    -&gt;setMetadata(M.getMDKindID(<span class="string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));</span><br></pre></td></tr></table></figure>
</li>
<li>右移<code>cur_loc</code> ，插入<code>store</code>指令，设置<code>__afl_prev_loc</code>，作为下一个插桩基础块的 “上一个基础块编号”  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set prev_loc to cur_loc &gt;&gt; 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前基础块的编号右移1位后，存入AFLPrevLoc</span></span><br><span class="line">StoreInst *Store =</span><br><span class="line">    IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc &gt;&gt; <span class="number">1</span>), AFLPrevLoc);</span><br><span class="line">Store-&gt;setMetadata(M.getMDKindID(<span class="string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));</span><br><span class="line"></span><br><span class="line">inst_blocks++;</span><br></pre></td></tr></table></figure>
  之所以要将当前基础块编号右移一位，是因为当基础块跳转<code>A-&gt;A</code>和<code>B-&gt;B</code>，或<code>A-&gt;B</code>和<code>B-&gt;A</code>，它们的编号做异或后的结果是相同的，无法区分，所以其中一个编号要右移一位。</li>
<li>当前基础块插桩完成，开始遍历下一个基础块</li>
</ul>
</li>
<li>当插桩完成后，输出相关信息并返回  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Say something nice. */</span></span><br><span class="line"><span class="comment">// 完成插桩</span></span><br><span class="line"><span class="keyword">if</span> (!be_quiet) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!inst_blocks) WARNF(<span class="string">&quot;No instrumentation targets found.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> OKF(<span class="string">&quot;Instrumented %u locations (%s mode, ratio %u%%).&quot;</span>,</span><br><span class="line">           inst_blocks, getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>) ? <span class="string">&quot;hardened&quot;</span> :</span><br><span class="line">           ((getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) ?</span><br><span class="line">            <span class="string">&quot;ASAN/MSAN&quot;</span> : <span class="string">&quot;non-hardened&quot;</span>), inst_ratio);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>总结：<ul>
<li>该pass插桩主要完成以下几点：<ul>
<li>随机计算出当前基础块的编号</li>
<li>通过当前基础块编号与上一个基础块编号，计算出共享内存中对应的索引值idx  这块共享内存的实质就是一个<code>hashtable</code></li>
<li>__afl_area_ptr[idx]++</li>
<li>设置<code>__afl_prev_loc</code>为当前的基础块编号，当前基础块插桩结束，准备插桩下一个基础块</li>
</ul>
</li>
<li>作用：<ul>
<li>当有控制流到达当前基础块时，其共享内存对应位置，用于计数的值就会加一</li>
<li>而AFL可以根据该共享内存上的数据来判断控制流的覆盖程度，调整输入样本，使控制流能够覆盖更多的基础块</li>
</ul>
</li>
<li>缺点：<ul>
<li>编号存在碰撞。不过根据AFL文档中的介绍，对于不是很复杂的目标，碰撞概率还是可以接受的  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Branch cnt | Colliding tuples | Example targets</span><br><span class="line">------------+------------------+-----------------</span><br><span class="line">      <span class="number">1</span>,<span class="number">000</span> | <span class="number">0.75</span>%            | giflib, lzo</span><br><span class="line">      <span class="number">2</span>,<span class="number">000</span> | <span class="number">1.5</span>%             | zlib, tar, xz</span><br><span class="line">      <span class="number">5</span>,<span class="number">000</span> | <span class="number">3.5</span>%             | libpng, libwebp</span><br><span class="line">     <span class="number">10</span>,<span class="number">000</span> | <span class="number">7</span>%               | libxml</span><br><span class="line">     <span class="number">20</span>,<span class="number">000</span> | <span class="number">14</span>%              | sqlite</span><br><span class="line">     <span class="number">50</span>,<span class="number">000</span> | <span class="number">30</span>%              | -</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>示例  设置<code>export AFL_PATH=/root/Desktop/AFL</code>，使其可以找到<code>afl-llvm-rt.o</code> 和 <code>afl-llvm-pass.so</code>  使用<code>afl-clang-fast</code>，对源码进行插桩，得到插桩后的IR指令  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@zzZ:/home/zzz/Desktop/AFL# ./afl-clang-fast -S -emit-llvm test.c </span><br><span class="line">afl-clang-fast <span class="number">2.57b</span> by &lt;lszekeres@google.com&gt;</span><br><span class="line">afl-llvm-pass <span class="number">2.57b</span> by &lt;lszekeres@google.com&gt;</span><br><span class="line">[+] Instrumented <span class="number">5</span> locations (non-hardened mode, ratio <span class="number">100</span>%).</span><br><span class="line">root@zzZ:/home/zzz/Desktop/AFL<span class="meta"># gedit test.ll</span></span><br></pre></td></tr></table></figure>
  其中，源码test.c：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> *null = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, buffer, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">if</span> (buffer[<span class="number">0</span>] == <span class="string">&#x27;6&#x27;</span> &amp;&amp; buffer[<span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; buffer[<span class="number">2</span>] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">    i = *null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No problem&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  插桩后的IR指令：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">; ModuleID = <span class="string">&#x27;test.c&#x27;</span></span><br><span class="line">source_filename = <span class="string">&quot;test.c&quot;</span></span><br><span class="line">target datalayout = <span class="string">&quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line">target triple = <span class="string">&quot;x86_64-pc-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line">@.str = <span class="keyword">private</span> unnamed_addr constant [<span class="number">11</span> x i8] c<span class="string">&quot;No problem\00&quot;</span>, align <span class="number">1</span></span><br><span class="line">@__afl_area_ptr = external global i8*</span><br><span class="line">@__afl_prev_loc = external <span class="keyword">thread_local</span> global i32</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local i32 @main(i32 %<span class="number">0</span>, i8** %<span class="number">1</span>) #<span class="number">0</span> !dbg !<span class="number">7</span> &#123;</span><br><span class="line">  %<span class="number">3</span> = load i32, i32* @__afl_prev_loc, align <span class="number">4</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">4</span> = load i8*, i8** @__afl_area_ptr, align <span class="number">8</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">5</span> = <span class="keyword">xor</span> i32 %<span class="number">3</span>, <span class="number">3216</span></span><br><span class="line">  %<span class="number">6</span> = getelementptr i8, i8* %<span class="number">4</span>, i32 %<span class="number">5</span></span><br><span class="line">  %<span class="number">7</span> = load i8, i8* %<span class="number">6</span>, align <span class="number">1</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">8</span> = add i8 %<span class="number">7</span>, <span class="number">1</span></span><br><span class="line">  store i8 %<span class="number">8</span>, i8* %<span class="number">6</span>, align <span class="number">1</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  store i32 <span class="number">1608</span>, i32* @__afl_prev_loc, align <span class="number">4</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">9</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">10</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">11</span> = alloca i8**, align <span class="number">8</span></span><br><span class="line">  %<span class="number">12</span> = alloca [<span class="number">3</span> x i8], align <span class="number">1</span></span><br><span class="line">  %<span class="number">13</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">14</span> = alloca i32*, align <span class="number">8</span></span><br><span class="line">  store i32 <span class="number">0</span>, i32* %<span class="number">9</span>, align <span class="number">4</span></span><br><span class="line">  store i32 %<span class="number">0</span>, i32* %<span class="number">10</span>, align <span class="number">4</span></span><br><span class="line">  call <span class="keyword">void</span> @llvm.dbg.declare(metadata i32* %<span class="number">10</span>, metadata !<span class="number">14</span>, metadata !DIExpression()), !dbg !<span class="number">15</span></span><br><span class="line">  store i8** %<span class="number">1</span>, i8*** %<span class="number">11</span>, align <span class="number">8</span></span><br><span class="line">  call <span class="keyword">void</span> @llvm.dbg.declare(metadata i8*** %<span class="number">11</span>, metadata !<span class="number">16</span>, metadata !DIExpression()), !dbg !<span class="number">17</span></span><br><span class="line">  call <span class="keyword">void</span> @llvm.dbg.declare(metadata [<span class="number">3</span> x i8]* %<span class="number">12</span>, metadata !<span class="number">18</span>, metadata !DIExpression()), !dbg !<span class="number">22</span></span><br><span class="line">  %<span class="number">15</span> = bitcast [<span class="number">3</span> x i8]* %<span class="number">12</span> to i8*, !dbg !<span class="number">22</span></span><br><span class="line">  call <span class="keyword">void</span> @llvm.<span class="built_in">memset</span>.p0i8.i64(i8* align <span class="number">1</span> %<span class="number">15</span>, i8 <span class="number">0</span>, i64 <span class="number">3</span>, i1 <span class="literal">false</span>), !dbg !<span class="number">22</span></span><br><span class="line">  call <span class="keyword">void</span> @llvm.dbg.declare(metadata i32* %<span class="number">13</span>, metadata !<span class="number">23</span>, metadata !DIExpression()), !dbg !<span class="number">24</span></span><br><span class="line">  call <span class="keyword">void</span> @llvm.dbg.declare(metadata i32** %<span class="number">14</span>, metadata !<span class="number">25</span>, metadata !DIExpression()), !dbg !<span class="number">27</span></span><br><span class="line">  store i32* null, i32** %<span class="number">14</span>, align <span class="number">8</span>, !dbg !<span class="number">27</span></span><br><span class="line">  %<span class="number">16</span> = getelementptr inbounds [<span class="number">3</span> x i8], [<span class="number">3</span> x i8]* %<span class="number">12</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>, !dbg !<span class="number">28</span></span><br><span class="line">  %<span class="number">17</span> = call i64 @read(i32 <span class="number">0</span>, i8* %<span class="number">16</span>, i64 <span class="number">3</span>), !dbg !<span class="number">29</span></span><br><span class="line">  %<span class="number">18</span> = getelementptr inbounds [<span class="number">3</span> x i8], [<span class="number">3</span> x i8]* %<span class="number">12</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>, !dbg !<span class="number">30</span></span><br><span class="line">  %<span class="number">19</span> = load i8, i8* %<span class="number">18</span>, align <span class="number">1</span>, !dbg !<span class="number">30</span></span><br><span class="line">  %<span class="number">20</span> = sext i8 %<span class="number">19</span> to i32, !dbg !<span class="number">30</span></span><br><span class="line">  %<span class="number">21</span> = icmp eq i32 %<span class="number">20</span>, <span class="number">54</span>, !dbg !<span class="number">32</span></span><br><span class="line">  br i1 %<span class="number">21</span>, label %<span class="number">22</span>, label %<span class="number">53</span>, !dbg !<span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="number">22</span>:                                               ; preds = %<span class="number">2</span></span><br><span class="line">  %<span class="number">23</span> = load i32, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">34</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">24</span> = load i8*, i8** @__afl_area_ptr, align <span class="number">8</span>, !dbg !<span class="number">34</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">25</span> = <span class="keyword">xor</span> i32 %<span class="number">23</span>, <span class="number">40101</span>, !dbg !<span class="number">34</span></span><br><span class="line">  %<span class="number">26</span> = getelementptr i8, i8* %<span class="number">24</span>, i32 %<span class="number">25</span>, !dbg !<span class="number">34</span></span><br><span class="line">  %<span class="number">27</span> = load i8, i8* %<span class="number">26</span>, align <span class="number">1</span>, !dbg !<span class="number">34</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">28</span> = add i8 %<span class="number">27</span>, <span class="number">1</span>, !dbg !<span class="number">34</span></span><br><span class="line">  store i8 %<span class="number">28</span>, i8* %<span class="number">26</span>, align <span class="number">1</span>, !dbg !<span class="number">34</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  store i32 <span class="number">20050</span>, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">34</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">29</span> = getelementptr inbounds [<span class="number">3</span> x i8], [<span class="number">3</span> x i8]* %<span class="number">12</span>, i64 <span class="number">0</span>, i64 <span class="number">1</span>, !dbg !<span class="number">34</span></span><br><span class="line">  %<span class="number">30</span> = load i8, i8* %<span class="number">29</span>, align <span class="number">1</span>, !dbg !<span class="number">34</span></span><br><span class="line">  %<span class="number">31</span> = sext i8 %<span class="number">30</span> to i32, !dbg !<span class="number">34</span></span><br><span class="line">  %<span class="number">32</span> = icmp eq i32 %<span class="number">31</span>, <span class="number">50</span>, !dbg !<span class="number">35</span></span><br><span class="line">  br i1 %<span class="number">32</span>, label %<span class="number">33</span>, label %<span class="number">53</span>, !dbg !<span class="number">36</span></span><br><span class="line"></span><br><span class="line"><span class="number">33</span>:                                               ; preds = %<span class="number">22</span></span><br><span class="line">  %<span class="number">34</span> = load i32, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">37</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">35</span> = load i8*, i8** @__afl_area_ptr, align <span class="number">8</span>, !dbg !<span class="number">37</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">36</span> = <span class="keyword">xor</span> i32 %<span class="number">34</span>, <span class="number">39935</span>, !dbg !<span class="number">37</span></span><br><span class="line">  %<span class="number">37</span> = getelementptr i8, i8* %<span class="number">35</span>, i32 %<span class="number">36</span>, !dbg !<span class="number">37</span></span><br><span class="line">  %<span class="number">38</span> = load i8, i8* %<span class="number">37</span>, align <span class="number">1</span>, !dbg !<span class="number">37</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">39</span> = add i8 %<span class="number">38</span>, <span class="number">1</span>, !dbg !<span class="number">37</span></span><br><span class="line">  store i8 %<span class="number">39</span>, i8* %<span class="number">37</span>, align <span class="number">1</span>, !dbg !<span class="number">37</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  store i32 <span class="number">19967</span>, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">37</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">40</span> = getelementptr inbounds [<span class="number">3</span> x i8], [<span class="number">3</span> x i8]* %<span class="number">12</span>, i64 <span class="number">0</span>, i64 <span class="number">2</span>, !dbg !<span class="number">37</span></span><br><span class="line">  %<span class="number">41</span> = load i8, i8* %<span class="number">40</span>, align <span class="number">1</span>, !dbg !<span class="number">37</span></span><br><span class="line">  %<span class="number">42</span> = sext i8 %<span class="number">41</span> to i32, !dbg !<span class="number">37</span></span><br><span class="line">  %<span class="number">43</span> = icmp eq i32 %<span class="number">42</span>, <span class="number">97</span>, !dbg !<span class="number">38</span></span><br><span class="line">  br i1 %<span class="number">43</span>, label %<span class="number">44</span>, label %<span class="number">53</span>, !dbg !<span class="number">39</span></span><br><span class="line"></span><br><span class="line"><span class="number">44</span>:                                               ; preds = %<span class="number">33</span></span><br><span class="line">  %<span class="number">45</span> = load i32, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">40</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">46</span> = load i8*, i8** @__afl_area_ptr, align <span class="number">8</span>, !dbg !<span class="number">40</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">47</span> = <span class="keyword">xor</span> i32 %<span class="number">45</span>, <span class="number">25417</span>, !dbg !<span class="number">40</span></span><br><span class="line">  %<span class="number">48</span> = getelementptr i8, i8* %<span class="number">46</span>, i32 %<span class="number">47</span>, !dbg !<span class="number">40</span></span><br><span class="line">  %<span class="number">49</span> = load i8, i8* %<span class="number">48</span>, align <span class="number">1</span>, !dbg !<span class="number">40</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">50</span> = add i8 %<span class="number">49</span>, <span class="number">1</span>, !dbg !<span class="number">40</span></span><br><span class="line">  store i8 %<span class="number">50</span>, i8* %<span class="number">48</span>, align <span class="number">1</span>, !dbg !<span class="number">40</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  store i32 <span class="number">12708</span>, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">40</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">51</span> = load i32*, i32** %<span class="number">14</span>, align <span class="number">8</span>, !dbg !<span class="number">40</span></span><br><span class="line">  %<span class="number">52</span> = load i32, i32* %<span class="number">51</span>, align <span class="number">4</span>, !dbg !<span class="number">42</span></span><br><span class="line">  store i32 %<span class="number">52</span>, i32* %<span class="number">13</span>, align <span class="number">4</span>, !dbg !<span class="number">43</span></span><br><span class="line">  br label %<span class="number">53</span>, !dbg !<span class="number">44</span></span><br><span class="line"></span><br><span class="line"><span class="number">53</span>:                                               ; preds = %<span class="number">44</span>, %<span class="number">33</span>, %<span class="number">22</span>, %<span class="number">2</span></span><br><span class="line">  %<span class="number">54</span> = load i32, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">45</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">55</span> = load i8*, i8** @__afl_area_ptr, align <span class="number">8</span>, !dbg !<span class="number">45</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">56</span> = <span class="keyword">xor</span> i32 %<span class="number">54</span>, <span class="number">59797</span>, !dbg !<span class="number">45</span></span><br><span class="line">  %<span class="number">57</span> = getelementptr i8, i8* %<span class="number">55</span>, i32 %<span class="number">56</span>, !dbg !<span class="number">45</span></span><br><span class="line">  %<span class="number">58</span> = load i8, i8* %<span class="number">57</span>, align <span class="number">1</span>, !dbg !<span class="number">45</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">59</span> = add i8 %<span class="number">58</span>, <span class="number">1</span>, !dbg !<span class="number">45</span></span><br><span class="line">  store i8 %<span class="number">59</span>, i8* %<span class="number">57</span>, align <span class="number">1</span>, !dbg !<span class="number">45</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  store i32 <span class="number">29898</span>, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">45</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">60</span> = call i32 @<span class="built_in">puts</span>(i8* getelementptr inbounds ([<span class="number">11</span> x i8], [<span class="number">11</span> x i8]* @.str, i64 <span class="number">0</span>, i64 <span class="number">0</span>)), !dbg !<span class="number">45</span></span><br><span class="line">  %<span class="number">61</span> = load i32, i32* %<span class="number">9</span>, align <span class="number">4</span>, !dbg !<span class="number">46</span></span><br><span class="line">  ret i32 %<span class="number">61</span>, !dbg !<span class="number">46</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nounwind readnone speculatable willreturn</span><br><span class="line">declare <span class="keyword">void</span> @llvm.dbg.declare(metadata, metadata, metadata) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: argmemonly nounwind willreturn writeonly</span><br><span class="line">declare <span class="keyword">void</span> @llvm.<span class="built_in">memset</span>.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #<span class="number">2</span></span><br><span class="line"></span><br><span class="line">declare dso_local i64 @read(i32, i8*, i64) #<span class="number">3</span></span><br><span class="line"></span><br><span class="line">declare dso_local i32 @<span class="built_in">puts</span>(i8*) #<span class="number">3</span></span><br><span class="line"></span><br><span class="line">attributes #<span class="number">0</span> = &#123; noinline nounwind optnone uwtable <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span>=<span class="string">&quot;0&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line">attributes #<span class="number">1</span> = &#123; nounwind readnone speculatable willreturn &#125;</span><br><span class="line">attributes #<span class="number">2</span> = &#123; argmemonly nounwind willreturn writeonly &#125;</span><br><span class="line">attributes #<span class="number">3</span> = &#123; <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">!llvm.dbg.cu = !&#123;!<span class="number">0</span>&#125;</span><br><span class="line">!llvm.<span class="keyword">module</span>.flags = !&#123;!<span class="number">3</span>, !<span class="number">4</span>, !<span class="number">5</span>&#125;</span><br><span class="line">!llvm.ident = !&#123;!<span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = distinct !DICompileUnit(language: DW_LANG_C99, file: !<span class="number">1</span>, producer: <span class="string">&quot;Ubuntu clang version 11.1.0-6&quot;</span>, isOptimized: <span class="literal">false</span>, runtimeVersion: <span class="number">0</span>, emissionKind: FullDebug, enums: !<span class="number">2</span>, splitDebugInlining: <span class="literal">false</span>, nameTableKind: None)</span><br><span class="line">!<span class="number">1</span> = !DIFile(filename: <span class="string">&quot;test.c&quot;</span>, directory: <span class="string">&quot;/root/Desktop/AFL&quot;</span>)</span><br><span class="line">!<span class="number">2</span> = !&#123;&#125;</span><br><span class="line">!<span class="number">3</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">&quot;Dwarf Version&quot;</span>, i32 <span class="number">4</span>&#125;</span><br><span class="line">!<span class="number">4</span> = !&#123;i32 <span class="number">2</span>, !<span class="string">&quot;Debug Info Version&quot;</span>, i32 <span class="number">3</span>&#125;</span><br><span class="line">!<span class="number">5</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">&quot;wchar_size&quot;</span>, i32 <span class="number">4</span>&#125;</span><br><span class="line">!<span class="number">6</span> = !&#123;!<span class="string">&quot;Ubuntu clang version 11.1.0-6&quot;</span>&#125;</span><br><span class="line"><span class="comment">/// other informations</span></span><br></pre></td></tr></table></figure>
  可以看到插入了的IR代码：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%<span class="number">1</span> = load i32* @__afl_prev_loc, align <span class="number">4</span>, !nosanitize !<span class="number">25</span></span><br><span class="line">%<span class="number">2</span> = load i8** @__afl_area_ptr, align <span class="number">8</span>, !nosanitize !<span class="number">25</span></span><br><span class="line">%<span class="number">3</span> = <span class="keyword">xor</span> i32 %<span class="number">1</span>, <span class="number">47106</span></span><br><span class="line">%<span class="number">4</span> = sext i32 %<span class="number">3</span> to i64</span><br><span class="line">%<span class="number">5</span> = getelementptr i8* %<span class="number">2</span>, i64 %<span class="number">4</span></span><br><span class="line">%<span class="number">6</span> = load i8* %<span class="number">5</span>, align <span class="number">1</span>, !nosanitize !<span class="number">25</span></span><br><span class="line">%<span class="number">7</span> = add i8 %<span class="number">6</span>, <span class="number">1</span></span><br><span class="line">store i8 %<span class="number">7</span>, i8* %<span class="number">5</span>, align <span class="number">1</span>, !nosanitize !<span class="number">25</span></span><br><span class="line">store i32 <span class="number">23553</span>, i32* @__afl_prev_loc, align <span class="number">4</span>, !nosanitize !<span class="number">25</span></span><br></pre></td></tr></table></figure>
  其中，<code>47106</code>是当前基本块的随机编号（key），<code>23553</code>是<code>47106 &gt;&gt; 1</code> 的结果</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">HotSpurzzZ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/05/21/AFL插桩（二）LLVM模式插桩/">http://example.com/2022/05/21/AFL插桩（二）LLVM模式插桩/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">HotSpurzzZ</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Fuzz/">Fuzz</a><a class="post-meta__tags" href="/tags/AFL/">AFL</a><a class="post-meta__tags" href="/tags/Instrumentation/">Instrumentation</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/05/23/All%20You%20Ever%20Wanted%20to%20Know%20About%20Dynamic%20Taint%20An/"><i class="fa fa-chevron-left">  </i><span>论文阅读 -- &quot;All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution&quot;</span></a></div><div class="next-post pull-right"><a href="/2022/05/15/AFL%E6%8F%92%E6%A1%A9%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E6%8F%92%E6%A1%A9/"><span>AFL插桩（一）概述与普通插桩</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'b166e2f551e9803e7eef',
  clientSecret: '9267242d46a5b1af315666cd638e6db8e0bb8249',
  repo: 'blogcomments',
  owner: 'HotSpurzzZ',
  admin: 'HotSpurzzZ',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By HotSpurzzZ</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>