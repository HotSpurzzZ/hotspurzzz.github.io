<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HotSpurzzZ</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-16T12:03:52.942Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>HotSpurzzZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>03-LLVM Pass使用-官网教程复现</title>
    <link href="http://example.com/2022/05/10/03-LLVM%20Pass%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/05/10/03-LLVM%20Pass%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-05-10T13:00:00.000Z</published>
    <updated>2022-05-16T12:03:52.942Z</updated>
    
    <content type="html"><![CDATA[<p>本文安装LLVM官网编写Pass的入门教程进行实验，对LLVM Pass进行初步的学习了解，并解决实验中遇到的问题，官网教程链接如下：<br><a href="https://llvm.org/docs/WritingAnLLVMPass.html">https://llvm.org/docs/WritingAnLLVMPass.html</a></p><span id="more"></span><h2 id="什么是pass"><a href="#什么是pass" class="headerlink" title="什么是pass"></a>什么是pass</h2><p>LLVM Pass就是“遍历一遍IR，可以同时对它做一些操作”的意思</p><p>LLVM Pass框架是LLVM系统中很重要的一部分。LLVM的优化和转换就是由多个pass一起完成的，类似流水线操作一样，每个pass都有着自己特定的优化工作。</p><p>Pass总体上分为两类：</p><ul><li>分析类：通过pass提供信息</li><li>转换类；修改中间代码</li></ul><hr><h2 id="配置Pass构建环境"><a href="#配置Pass构建环境" class="headerlink" title="配置Pass构建环境"></a>配置Pass构建环境</h2><p>在LLVM源代码库某处创建新目录，例如源码中提供了：<code>llvm/lib/Transforms/Hello</code></p><p>设置构建脚本，将以下内容复制到<code>llvm/lib/Transforms/Hello/CMakeLists.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_llvm_library( LLVMHello MODULE</span><br><span class="line">  Hello.cpp</span><br><span class="line"></span><br><span class="line">  PLUGIN_TOOL</span><br><span class="line">  opt</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>代码的含义是：此构建脚本指定当前目录中的<code>Hello.cpp</code>文件将被编译并链接到一个共享项<code>$(LEVEL)/lib/LLVMHello.so</code>中，共享项可以由<strong>opt</strong>工具通过 -load 选项动态加载。</p><p>之后将以下内容放置在<code>lib/Transforms/CMakeLists.txt</code>中，这样才可以选择在之后的编译中对’Hello’pass编译</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_subdirectory(Hello)</span><br></pre></td></tr></table></figure><p>注：源码中已经有了一个“Hello”pass 的目录及示例，因此对于“Hello”不需要修改上面的内容。</p><hr><h2 id="编写Pass代码"><a href="#编写Pass代码" class="headerlink" title="编写Pass代码"></a>编写Pass代码</h2><p>头文件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>llvm命名空间</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br></pre></td></tr></table></figure><p>匿名命名空间：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br></pre></td></tr></table></figure><p>声明pass本身：这里声明了一个“ <code>Hello</code>”类，它是<a href="https://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-functionpass">FunctionPass</a>的子类，以及LLVM 用来识别 pass 的 pass 标识符</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">Hello() : FunctionPass(ID) &#123;&#125;</span><br></pre></td></tr></table></figure><p>声明一个 runOnFunction 方法，它覆盖了从 FunctionPass 继承的抽象虚函数，打印出每个函数名称：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    errs() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">    errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; <span class="comment">// end of struct Hello</span></span><br><span class="line">&#125;  <span class="comment">// end of anonymous namespace</span></span><br></pre></td></tr></table></figure><p>初始化 pass ID。LLVM 使用 ID 的地址来识别 pass，所以初始化值并不重要；最后<a href="https://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-registration">注册</a>Hello类：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="literal">false</span> <span class="comment">/* Only looks at CFG */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="literal">false</span> <span class="comment">/* Analysis Pass */</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>总的来说，整个Hello.cpp应该为这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/ADT/Statistic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_TYPE <span class="meta-string">&quot;hello&quot;</span></span></span><br><span class="line"></span><br><span class="line">STATISTIC(HelloCounter, <span class="string">&quot;Counts number of functions greeted&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="comment">// Hello - The first implementation, without getAnalysisUsage.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ID; <span class="comment">// Pass identification, replacement for typeid</span></span><br><span class="line">    Hello() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      ++HelloCounter;</span><br><span class="line">      errs() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>当然，因为源码中已经提供了初始样本，可以不对代码进行改动，这与官方教程中的内容有些许不同：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//===- Hello.cpp - Example code from &quot;Writing an LLVM Pass&quot; ---------------===//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span></span><br><span class="line"><span class="comment">// See https://llvm.org/LICENSE.txt for license information.</span></span><br><span class="line"><span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file implements two versions of the LLVM &quot;Hello World&quot; pass described</span></span><br><span class="line"><span class="comment">// in docs/WritingAnLLVMPass.html</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/ADT/Statistic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_TYPE <span class="meta-string">&quot;hello&quot;</span></span></span><br><span class="line"></span><br><span class="line">STATISTIC(HelloCounter, <span class="string">&quot;Counts number of functions greeted&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="comment">// Hello - The first implementation, without getAnalysisUsage.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ID; <span class="comment">// Pass identification, replacement for typeid</span></span><br><span class="line">    Hello() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      ++HelloCounter;</span><br><span class="line">      errs() &lt;&lt; <span class="string">&quot;Hello : &quot;</span>;</span><br><span class="line">      errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="comment">// Hello2 - The second implementation with getAnalysisUsage implemented.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Hello2</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ID; <span class="comment">// Pass identification, replacement for typeid</span></span><br><span class="line">    Hello2() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      ++HelloCounter;</span><br><span class="line">      errs() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t modify the program, so we preserve all analyses.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getAnalysisUsage</span><span class="params">(AnalysisUsage &amp;AU)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      AU.setPreservesAll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Hello2::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello2&gt;</span></span><br><span class="line"><span class="function"><span class="title">Y</span><span class="params">(<span class="string">&quot;hello2&quot;</span>, <span class="string">&quot;Hello World Pass (with getAnalysisUsage implemented)&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="编译及运行Pass"><a href="#编译及运行Pass" class="headerlink" title="编译及运行Pass"></a>编译及运行Pass</h2><p>在对<code>llvm/lib/Transforms/Hello</code>下的Hello.cpp完成编写或修改后，重新编译如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root @ zzz in ~/Desktop/llvm-project/build on git:main x </span></span><br><span class="line">$ ninja -j8</span><br><span class="line">[2/2] Linking CXX shared module lib/LLVMHello.so</span><br></pre></td></tr></table></figure><p>在lib文件夹下会生成对应的<code>LLVMHello.so</code>，之后可以使用<code>opt</code>命令通过 pass 运行 LLVM 程序</p><p>这里随便使用一个C程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hello_llvm.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello LLVM\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为bitcode：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -emit-llvm -c hello_llvm.c -o hello_llvm.bc</span><br></pre></td></tr></table></figure><p>运行pass，识别函数名：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root @ zzz in ~/Desktop </span></span><br><span class="line">$ opt -load ~/Desktop/llvm-project/build/lib/LLVMHello.so -hello &lt; hello_llvm.bc &gt; /dev/null -enable-new-pm=0</span><br><span class="line">Hello : add</span><br><span class="line">Hello : sub</span><br><span class="line">Hello : main</span><br></pre></td></tr></table></figure><p>注：若在最后运行时遇到<code>opt: unknown pass name &#39;hello&#39;</code>报错，则可根据<a href="https://llvm.org/docs/WritingAnLLVMPass.html#introduction-what-is-a-pass">提醒</a>，添加<code>-enable-new-pm=0</code> 参数</p><p>至此完成第一个Pass编写、运行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文安装LLVM官网编写Pass的入门教程进行实验，对LLVM Pass进行初步的学习了解，并解决实验中遇到的问题，官网教程链接如下：&lt;br&gt;&lt;a href=&quot;https://llvm.org/docs/WritingAnLLVMPass.html&quot;&gt;https://llvm.org/docs/WritingAnLLVMPass.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LLVM" scheme="http://example.com/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://example.com/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>00-LLVM源码安装</title>
    <link href="http://example.com/2022/05/01/00-LLVM%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2022/05/01/00-LLVM%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/</id>
    <published>2022-05-01T13:00:00.000Z</published>
    <updated>2022-05-10T02:17:54.902Z</updated>
    
    <content type="html"><![CDATA[<ul><li>环境：Ubuntu20.04</li><li>版本：LLVM 14.0.3</li></ul><p>LLVM安装方法有许多，其实主要区别就在于，源码安装可以后续对LLVM进行进一步加工；若只是单纯使用LLVM，则可以直接安装。</p><span id="more"></span><h2 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h2><hr><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://apt.llvm.org/llvm.sh</span><br><span class="line">chmod +x llvm.sh</span><br><span class="line">sudo ./llvm.sh </span><br></pre></td></tr></table></figure><p><a href="http://llvm.sh/">llvm.sh</a> 内包含安装llvm所需要的其他配件工具，主要通过apt-get安装的</p><h2 id="源码编译安装（推荐）"><a href="#源码编译安装（推荐）" class="headerlink" title="源码编译安装（推荐）"></a>源码编译安装（推荐）</h2><hr><p>这里使用的LLVM 版本是<a href="https://github.com/llvm/llvm-project">Github</a>上显示的14.0.3</p><h3 id="环境条件"><a href="#环境条件" class="headerlink" title="环境条件"></a>环境条件</h3><ul><li>CMake &gt;= 3.13.4</li><li>GCC &gt;= 7.1.0</li><li>python &gt;= 3.6</li><li><a href="http://zlib.net/">zlib</a> &gt;= 1.2.3.4</li><li><a href="http://savannah.gnu.org/projects/make">GNU Make</a> ≥ 3.79</li></ul><p>这些工具的安装网上教程很多，这里不再记录，这里我的环境是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake version 3.16.3</span><br><span class="line">gcc version 9.4.0</span><br><span class="line">Python 3.8.10</span><br><span class="line">zlib version 1.2.12</span><br><span class="line">GNU Make 4.2.1</span><br></pre></td></tr></table></figure><h3 id="下载LLVM源码"><a href="#下载LLVM源码" class="headerlink" title="下载LLVM源码"></a>下载LLVM源码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/llvm/llvm-project.git</span><br></pre></td></tr></table></figure><p>我下载的时候是LLVM 14.0.3版本，由于上面的命令较慢，也可以以浅层克隆的形式节约空间及时间（使用这个只能构建最新版本的llvm，对于只想编译的普通用户，此命令可以正常工作。但是如果后来有人成为贡献者，由于他们无法从浅克隆推送代码，因此需要将其转换为完整克隆）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/llvm/llvm-project.git </span><br></pre></td></tr></table></figure><h3 id="构建LLVM及Clang"><a href="#构建LLVM及Clang" class="headerlink" title="构建LLVM及Clang"></a>构建LLVM及Clang</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> llvm-project</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -G Ninja -DCMAKE_BUILD_TYPE=Release  -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang&quot;</span> ../llvm  <span class="comment">#编译配置</span></span><br><span class="line">ninja -j8  <span class="comment">#开始编译</span></span><br><span class="line">ninja install</span><br></pre></td></tr></table></figure><p>其中，第四行cmake指令的官方原型是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -G &lt;generator&gt; -DCMAKE_BUILD_TYPE=&lt;<span class="built_in">type</span>&gt; [options] ../llvm</span><br></pre></td></tr></table></figure><p>这里的参数含义分别是：</p><ul><li>**-G <generator>**：一些常见的构建系统生成器<generator>包括<ul><li><strong>Ninja</strong> — 用于生成<a href="https://ninja-build.org/">Ninja</a> 构建文件（官方文档言：大多数 llvm 开发人员使用这个）</li><li><strong>Unix Makefiles</strong> — 用于生成与 make 兼容的并行 makefile</li><li><strong>Visual Studio</strong> — 用于生成 Visual Studio 项目和解决方案</li><li><strong>Xcode</strong> — 用于生成 Xcode 项目</li></ul>  在没有-G参数时，默认是使用的make命令</generator></generator></li><li><strong>-DCMAKE_BUILD_TYPE</strong>：默认情况下llvm编译的是debug版本，在编译release版本的时候需要明确指定编译的类型</li><li>其他一些选项[options]包括：<ul><li>**DLLVM_ENABLE_PROJECTS=’…’**：在编译的时候，会默认只编译llvm的基础库，使用此命令，指定要另外构建的 LLVM 子项目。可以包括以下任何一种：clang、clang-tools-extra、lldb、compiler-rt、lld、polly、cross-project-tests</li><li><strong>DCMAKE_INSTALL_PREFIX=directory</strong>：指定要安装 LLVM 工具和库的位置的完整路径名（默认值是<code>/usr/local</code>）</li><li><strong>DLLVM_ENABLE_ASSERTIONS=On</strong>：在启用断言检查的情况下编译（Debug 构建默认为 Yes，所有其他构建类型默认为 No）</li></ul></li></ul><p>执行完最后的ninja install指令，编译安装完后，将build下的bin文件夹添加到环境变量path下</p><p>查看版本：（这里不明白为什么显示15.0.0版本，github上却是14.0.3）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ llvm-as --version</span><br><span class="line">LLVM (http://llvm.org/):</span><br><span class="line">  LLVM version 15.0.0git</span><br><span class="line">  Optimized build.</span><br><span class="line">  Default target: x86_64-unknown-linux-gnu</span><br><span class="line">  Host CPU: tigerlake</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(argc)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 1 : argc is  %d\r\n&quot;</span>,argc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 2 : argc is  %d\r\n&quot;</span>,argc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;default ：argc is  %d\r\n&quot;</span>,argc);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将llvm_test.c转换为LLVM IR</span></span><br><span class="line">clang -emit-llvm -S llvm_test.c -o llvm_test_1.ll</span><br></pre></td></tr></table></figure><p>查看生成的IR：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">; ModuleID = <span class="string">&#x27;llvm_test.c&#x27;</span></span><br><span class="line">source_filename = <span class="string">&quot;llvm_test.c&quot;</span></span><br><span class="line">target datalayout = <span class="string">&quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line">target triple = <span class="string">&quot;x86_64-unknown-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line">@.str = <span class="keyword">private</span> unnamed_addr constant [<span class="number">23</span> x i8] c<span class="string">&quot;case 1 : argc is  %d\0D\0A\00&quot;</span>, align <span class="number">1</span></span><br><span class="line">@.str<span class="number">.1</span> = <span class="keyword">private</span> unnamed_addr constant [<span class="number">23</span> x i8] c<span class="string">&quot;case 2 : argc is  %d\0D\0A\00&quot;</span>, align <span class="number">1</span></span><br><span class="line">@.str<span class="number">.2</span> = <span class="keyword">private</span> unnamed_addr constant [<span class="number">25</span> x i8] c<span class="string">&quot;default \EF\BC\9Aargc is  %d\0D\0A\00&quot;</span>, align <span class="number">1</span></span><br><span class="line">@.str<span class="number">.3</span> = <span class="keyword">private</span> unnamed_addr constant [<span class="number">3</span> x i8] c<span class="string">&quot;OK\00&quot;</span>, align <span class="number">1</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local i32 @main(i32 noundef %<span class="number">0</span>, ptr noundef %<span class="number">1</span>) #<span class="number">0</span> &#123;</span><br><span class="line">  %<span class="number">3</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">4</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">5</span> = alloca ptr, align <span class="number">8</span></span><br><span class="line">  store i32 <span class="number">0</span>, ptr %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  store i32 %<span class="number">0</span>, ptr %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  store ptr %<span class="number">1</span>, ptr %<span class="number">5</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">6</span> = load i32, ptr %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  <span class="keyword">switch</span> i32 %<span class="number">6</span>, label %<span class="number">13</span> [</span><br><span class="line">    i32 <span class="number">1</span>, label %<span class="number">7</span></span><br><span class="line">    i32 <span class="number">2</span>, label %<span class="number">10</span></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>:                                                ; preds = %<span class="number">2</span></span><br><span class="line">  %<span class="number">8</span> = load i32, ptr %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">9</span> = call i32 (ptr, ...) @<span class="built_in">printf</span>(ptr noundef @.str, i32 noundef %<span class="number">8</span>)</span><br><span class="line">  br label %<span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>:                                               ; preds = %<span class="number">2</span></span><br><span class="line">  %<span class="number">11</span> = load i32, ptr %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">12</span> = call i32 (ptr, ...) @<span class="built_in">printf</span>(ptr noundef @.str<span class="number">.1</span>, i32 noundef %<span class="number">11</span>)</span><br><span class="line">  br label %<span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>:                                               ; preds = %<span class="number">2</span></span><br><span class="line">  %<span class="number">14</span> = load i32, ptr %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">15</span> = call i32 (ptr, ...) @<span class="built_in">printf</span>(ptr noundef @.str<span class="number">.2</span>, i32 noundef %<span class="number">14</span>)</span><br><span class="line">  br label %<span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="number">16</span>:                                               ; preds = %<span class="number">13</span>, %<span class="number">10</span>, %<span class="number">7</span></span><br><span class="line">  %<span class="number">17</span> = call i32 (ptr, ...) @<span class="built_in">printf</span>(ptr noundef @.str<span class="number">.3</span>)</span><br><span class="line">  %<span class="number">18</span> = load i32, ptr %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  ret i32 %<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i32 @<span class="built_in">printf</span>(ptr noundef, ...) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">attributes #<span class="number">0</span> = &#123; noinline nounwind optnone uwtable <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span>=<span class="string">&quot;0&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;tune-cpu&quot;</span>=<span class="string">&quot;generic&quot;</span> &#125;</span><br><span class="line">attributes #<span class="number">1</span> = &#123; <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;tune-cpu&quot;</span>=<span class="string">&quot;generic&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">!llvm.<span class="keyword">module</span>.flags = !&#123;!<span class="number">0</span>, !<span class="number">1</span>, !<span class="number">2</span>, !<span class="number">3</span>, !<span class="number">4</span>&#125;</span><br><span class="line">!llvm.ident = !&#123;!<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">&quot;wchar_size&quot;</span>, i32 <span class="number">4</span>&#125;</span><br><span class="line">!<span class="number">1</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">&quot;PIC Level&quot;</span>, i32 <span class="number">2</span>&#125;</span><br><span class="line">!<span class="number">2</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">&quot;PIE Level&quot;</span>, i32 <span class="number">2</span>&#125;</span><br><span class="line">!<span class="number">3</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">&quot;uwtable&quot;</span>, i32 <span class="number">2</span>&#125;</span><br><span class="line">!<span class="number">4</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">&quot;frame-pointer&quot;</span>, i32 <span class="number">2</span>&#125;</span><br><span class="line">!<span class="number">5</span> = !&#123;!<span class="string">&quot;clang version 15.0.0 (https://github.com/llvm/llvm-project.git e300682597470ffc88b59a6187cdd763f1595d3a)&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>运行测试：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lli llvm_test_1.ll                               </span><br><span class="line"><span class="keyword">case</span> 1 : argc is  1</span><br><span class="line">OK<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">$ lli llvm_test_1.ll 1</span><br><span class="line"><span class="keyword">case</span> 2 : argc is  2</span><br><span class="line">OK<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>至此LLVM的源码编译安装及测试使用完成。</p><p>参考：</p><p><a href="https://clang.llvm.org/get_started.html">https://clang.llvm.org/get_started.html</a></p><p><a href="https://llvm.org/docs/GettingStarted.html#checkout-llvm-from-subversion">https://llvm.org/docs/GettingStarted.html#checkout-llvm-from-subversion</a></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;环境：Ubuntu20.04&lt;/li&gt;
&lt;li&gt;版本：LLVM 14.0.3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LLVM安装方法有许多，其实主要区别就在于，源码安装可以后续对LLVM进行进一步加工；若只是单纯使用LLVM，则可以直接安装。&lt;/p&gt;</summary>
    
    
    
    <category term="LLVM" scheme="http://example.com/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://example.com/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>Pande使用：record与replay</title>
    <link href="http://example.com/2022/04/04/Pande%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/04/04/Pande%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</id>
    <published>2022-04-04T02:00:00.000Z</published>
    <updated>2022-04-05T08:48:02.054Z</updated>
    
    <content type="html"><![CDATA[<p>record（记录）与replay（回放）是Panda的两个重要功能，本文在完成这两个功能的自动化处理的同时，还简单使用到了Panda的插件功能。<br>主要基于以下教程，但在复现过程中会遇到一些原文中没有提到的问题</p><p><a href="https://adalogics.com/blog/Building-a-custom-malware-sandbox-with-PANDA-Part-1">Building a custom malware sandbox with PANDA - Part 1</a></p><span id="more"></span><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><hr><ul><li>首先需要一个windows镜像，并生成对应的qcow2文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a working directory</span></span><br><span class="line">mkdir sandbox_base</span><br><span class="line"><span class="built_in">cd</span> sandbox_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download the disk image from Microsofts&#x27; website</span></span><br><span class="line"><span class="comment"># (URL from https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/)</span></span><br><span class="line">wget https://az792536.vo.msecnd.net/vms/VMBuild_20150916/VirtualBox/IE8/IE8.Win7.VirtualBox.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Unzip the virtualbox zip</span></span><br><span class="line">unzip IE8.Win7.VirtualBox.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Untar the .ova</span></span><br><span class="line">tar -xvf IE8\ -\ Win7.ova</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a qcow image from the .vmdk file.</span></span><br><span class="line"><span class="comment">## First install qemu utils</span></span><br><span class="line">sudo apt-get install qemu-utils</span><br><span class="line"></span><br><span class="line"><span class="comment">## Then create our image</span></span><br><span class="line">qemu-img convert -O qcow2 IE8\ -\ Win7-disk1.vmdk IE8_win7_disk1.qcow2</span><br><span class="line">chmod +x ./IE8_win7_disk1.qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment">## Clean up some of the unnecessary files</span></span><br><span class="line">rm IE8\ -\ Win7-disk1.vmdk</span><br><span class="line">rm IE8\ -\ Win7.ova</span><br></pre></td></tr></table></figure></li></ul><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><hr><h2 id="record记录"><a href="#record记录" class="headerlink" title="record记录"></a>record记录</h2><p>运行这个脚本，我们得到一个 qcow2 图像，可以在这个qcow2上运行panda</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panda/build/i386-softmmu/qemu-system-i386 IE8-win7-disk1.qcow2</span><br><span class="line"><span class="comment">#运行此命令可以启动windows镜像</span></span><br></pre></td></tr></table></figure><p>下一步就是确保可以<strong>记录和回放</strong>刚才的执行，如上一篇提到的，可以使用 PANDA 命令<code>begin_record</code><strong>，</strong><code>end_record</code>完成这一功能</p><p>运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./panda/build/i386-softmmu/panda-system-i386 -monitor stdio -show-cursor -m 8192 ./IE8_win7_disk1.qcow2</span><br></pre></td></tr></table></figure><p><img src="/2022/04/04/Pande%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Untitled.png"></p><p>产生两个文件：</p><p><img src="/2022/04/04/Pande%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Untitled%201.png"></p><p><code>sample-rr-nondet.log</code> 和 <code>sample-rr-snp</code> 是 PANDA 创建的用于重播执行的文件。 </p><ul><li><code>sample-rr-snp</code> 文件包含记录开始时的内存快照</li><li><code>sample-rr-nondet.log</code> 文件包含重放执行所需的 CPU 输入。</li></ul><h2 id="replay回放"><a href="#replay回放" class="headerlink" title="replay回放"></a>replay回放</h2><p>最后，为了回放执行，我们使用 PANDA 的 qemu 命令行参数 <code>-replay NAME</code>。 回放我们刚刚记录的执行的过程如下面的输出所示。</p><p>输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./panda/build/i386-softmmu/panda-system-i386 -monitor stdio -show-cursor -m 8192 -replay sample                                                          </span><br><span class="line">QEMU 2.9.1 monitor - <span class="built_in">type</span> <span class="string">&#x27;help&#x27;</span> <span class="keyword">for</span> more information</span><br><span class="line">(qemu) loading snapshot</span><br><span class="line">... <span class="keyword">done</span>.</span><br><span class="line">opening nondet <span class="built_in">log</span> <span class="keyword">for</span> <span class="built_in">read</span> :./sample-rr-nondet.log</span><br><span class="line">./sample-rr-nondet.log:  12257883474 instrs total.</span><br><span class="line">sample:   122578839 (  1.00%) instrs.    3.03 sec.  2.09 GB ram.</span><br><span class="line">sample:   245157670 (  2.00%) instrs.    5.30 sec.  2.16 GB ram.</span><br><span class="line">sample:   367736508 (  3.00%) instrs.    7.08 sec.  2.21 GB ram.</span><br><span class="line">sample:   490315339 (  4.00%) instrs.    8.93 sec.  2.26 GB ram.</span><br><span class="line">sample:   612894177 (  5.00%) instrs.   10.51 sec.  2.28 GB ram.</span><br><span class="line">sample:   735473011 (  6.00%) instrs.   12.59 sec.  2.30 GB ram.</span><br><span class="line">sample:   858051847 (  7.00%) instrs.   14.14 sec.  2.31 GB ram.</span><br><span class="line">sample:   980630679 (  8.00%) instrs.   15.67 sec.  2.32 GB ram.</span><br><span class="line">sample:  1103209513 (  9.00%) instrs.   17.13 sec.  2.35 GB ram.</span><br><span class="line">sample:  1225788351 ( 10.00%) instrs.   19.25 sec.  2.36 GB ram.</span><br><span class="line">sample:  1348367183 ( 11.00%) instrs.   21.67 sec.  2.39 GB ram.</span><br><span class="line">sample:  1470946025 ( 12.00%) instrs.   23.74 sec.  2.42 GB ram.</span><br><span class="line">sample:  1593524854 ( 13.00%) instrs.   25.30 sec.  2.43 GB ram.</span><br><span class="line">sample:  1716103692 ( 14.00%) instrs.   26.59 sec.  2.44 GB ram.</span><br><span class="line">sample:  1838682533 ( 15.00%) instrs.   28.35 sec.  2.48 GB ram.</span><br><span class="line">sample:  1961261358 ( 16.00%) instrs.   30.05 sec.  2.49 GB ram.</span><br><span class="line">sample:  2083840197 ( 17.00%) instrs.   31.73 sec.  2.50 GB ram.</span><br><span class="line">sample:  2206419030 ( 18.00%) instrs.   33.05 sec.  2.50 GB ram.</span><br><span class="line">sample:  2328997867 ( 19.00%) instrs.   34.10 sec.  2.51 GB ram.</span><br><span class="line">sample:  2451576695 ( 20.00%) instrs.   34.86 sec.  2.51 GB ram.</span><br><span class="line">sample:  2574155533 ( 21.00%) instrs.   35.62 sec.  2.51 GB ram.</span><br><span class="line">sample:  2696734368 ( 22.00%) instrs.   36.34 sec.  2.51 GB ram.</span><br><span class="line">sample:  2819313201 ( 23.00%) instrs.   37.15 sec.  2.51 GB ram.</span><br><span class="line">sample:  2941892037 ( 24.00%) instrs.   37.90 sec.  2.51 GB ram.</span><br><span class="line">sample:  3064470870 ( 25.00%) instrs.   38.64 sec.  2.51 GB ram.</span><br><span class="line">sample:  3187049706 ( 26.00%) instrs.   39.37 sec.  2.51 GB ram.</span><br><span class="line">sample:  3309628543 ( 27.00%) instrs.   40.14 sec.  2.53 GB ram.</span><br><span class="line">sample:  3432207378 ( 28.00%) instrs.   40.90 sec.  2.53 GB ram.</span><br><span class="line">sample:  3554786210 ( 29.00%) instrs.   41.67 sec.  2.53 GB ram.</span><br><span class="line">sample:  3677365047 ( 30.00%) instrs.   42.44 sec.  2.53 GB ram.</span><br><span class="line">sample:  3799943884 ( 31.00%) instrs.   43.20 sec.  2.53 GB ram.</span><br><span class="line">sample:  3922522712 ( 32.00%) instrs.   44.01 sec.  2.53 GB ram.</span><br><span class="line">sample:  4045101555 ( 33.00%) instrs.   44.80 sec.  2.53 GB ram.</span><br><span class="line">sample:  4167680384 ( 34.00%) instrs.   46.56 sec.  2.54 GB ram.</span><br><span class="line">sample:  4290259220 ( 35.00%) instrs.   47.72 sec.  2.54 GB ram.</span><br><span class="line">sample:  4412838054 ( 36.00%) instrs.   48.71 sec.  2.54 GB ram.</span><br><span class="line">sample:  4535416896 ( 37.00%) instrs.   50.03 sec.  2.55 GB ram.</span><br><span class="line">sample:  4657995732 ( 38.00%) instrs.   51.02 sec.  2.55 GB ram.</span><br><span class="line">sample:  4780574563 ( 39.00%) instrs.   52.02 sec.  2.55 GB ram.</span><br><span class="line">sample:  4903153392 ( 40.00%) instrs.   53.05 sec.  2.56 GB ram.</span><br><span class="line">sample:  5025732229 ( 41.00%) instrs.   54.11 sec.  2.56 GB ram.</span><br><span class="line">sample:  5148311061 ( 42.00%) instrs.   55.59 sec.  2.57 GB ram.</span><br><span class="line">sample:  5270889895 ( 43.00%) instrs.   57.61 sec.  2.58 GB ram.</span><br><span class="line">sample:  5393468732 ( 44.00%) instrs.   59.63 sec.  2.58 GB ram.</span><br><span class="line">sample:  5516047564 ( 45.00%) instrs.   61.49 sec.  2.60 GB ram.</span><br><span class="line">sample:  5638626404 ( 46.00%) instrs.   62.96 sec.  2.62 GB ram.</span><br><span class="line">sample:  5761205244 ( 47.00%) instrs.   63.83 sec.  2.66 GB ram.</span><br><span class="line">sample:  5883784083 ( 48.00%) instrs.   64.33 sec.  2.66 GB ram.</span><br><span class="line">sample:  6006362907 ( 49.00%) instrs.   65.52 sec.  2.66 GB ram.</span><br><span class="line">sample:  6128941737 ( 50.00%) instrs.   67.38 sec.  2.67 GB ram.</span><br><span class="line">sample:  6251520574 ( 51.00%) instrs.   68.85 sec.  2.67 GB ram.</span><br><span class="line">sample:  6374099413 ( 52.00%) instrs.   71.54 sec.  2.68 GB ram.</span><br><span class="line">sample:  6496678244 ( 53.00%) instrs.   73.11 sec.  2.70 GB ram.</span><br><span class="line">sample:  6619257095 ( 54.00%) instrs.   75.17 sec.  2.72 GB ram.</span><br><span class="line">sample:  6741835915 ( 55.00%) instrs.   76.67 sec.  2.75 GB ram.</span><br><span class="line">sample:  6864414747 ( 56.00%) instrs.   78.02 sec.  2.77 GB ram.</span><br><span class="line">sample:  6986993585 ( 57.00%) instrs.   79.43 sec.  2.78 GB ram.</span><br><span class="line">sample:  7109572416 ( 58.00%) instrs.   81.03 sec.  2.79 GB ram.</span><br><span class="line">sample:  7232151255 ( 59.00%) instrs.   81.99 sec.  2.79 GB ram.</span><br><span class="line">sample:  7354730096 ( 60.00%) instrs.   83.04 sec.  2.79 GB ram.</span><br><span class="line">sample:  7477308922 ( 61.00%) instrs.   84.02 sec.  2.79 GB ram.</span><br><span class="line">sample:  7599887756 ( 62.00%) instrs.   85.07 sec.  2.82 GB ram.</span><br><span class="line">sample:  7722466590 ( 63.00%) instrs.   85.93 sec.  2.91 GB ram.</span><br><span class="line">sample:  7845045425 ( 64.00%) instrs.   86.94 sec.  2.92 GB ram.</span><br><span class="line">sample:  7967624263 ( 65.00%) instrs.   89.36 sec.  2.92 GB ram.</span><br><span class="line">sample:  8090203100 ( 66.00%) instrs.   91.36 sec.  2.92 GB ram.</span><br><span class="line">sample:  8212781928 ( 67.00%) instrs.   92.56 sec.  2.93 GB ram.</span><br><span class="line">sample:  8335360763 ( 68.00%) instrs.   93.53 sec.  2.93 GB ram.</span><br><span class="line">sample:  8457939599 ( 69.00%) instrs.   94.50 sec.  2.93 GB ram.</span><br><span class="line">sample:  8580518433 ( 70.00%) instrs.   95.51 sec.  2.93 GB ram.</span><br><span class="line">sample:  8703097273 ( 71.00%) instrs.   97.64 sec.  2.96 GB ram.</span><br><span class="line">sample:  8825676104 ( 72.00%) instrs.   99.93 sec.  2.98 GB ram.</span><br><span class="line">sample:  8948254945 ( 73.00%) instrs.  102.09 sec.  2.98 GB ram.</span><br><span class="line">sample:  9070833775 ( 74.00%) instrs.  103.77 sec.  3.00 GB ram.</span><br><span class="line">sample:  9193412614 ( 75.00%) instrs.  105.20 sec.  3.00 GB ram.</span><br><span class="line">sample:  9315991448 ( 76.00%) instrs.  106.58 sec.  3.00 GB ram.</span><br><span class="line">sample:  9438570277 ( 77.00%) instrs.  108.09 sec.  3.01 GB ram.</span><br><span class="line">sample:  9561149110 ( 78.00%) instrs.  109.48 sec.  3.02 GB ram.</span><br><span class="line">sample:  9683727949 ( 79.00%) instrs.  111.43 sec.  3.03 GB ram.</span><br><span class="line">sample:  9806306784 ( 80.00%) instrs.  113.25 sec.  3.03 GB ram.</span><br><span class="line">sample:  9928885615 ( 81.00%) instrs.  115.41 sec.  3.04 GB ram.</span><br><span class="line">sample:  10051464450 ( 82.00%) instrs.  117.09 sec.  3.06 GB ram.</span><br><span class="line">sample:  10174043284 ( 83.00%) instrs.  119.48 sec.  3.08 GB ram.</span><br><span class="line">sample:  10296622121 ( 84.00%) instrs.  121.13 sec.  3.09 GB ram.</span><br><span class="line">sample:  10419200982 ( 85.00%) instrs.  121.95 sec.  3.09 GB ram.</span><br><span class="line">sample:  10541779795 ( 86.00%) instrs.  122.45 sec.  3.10 GB ram.</span><br><span class="line">sample:  10664358635 ( 87.00%) instrs.  123.53 sec.  3.13 GB ram.</span><br><span class="line">sample:  10786937459 ( 88.00%) instrs.  124.43 sec.  3.14 GB ram.</span><br><span class="line">sample:  10909516309 ( 89.00%) instrs.  125.78 sec.  3.15 GB ram.</span><br><span class="line">sample:  11032095129 ( 90.00%) instrs.  126.66 sec.  3.15 GB ram.</span><br><span class="line">sample:  11154673962 ( 91.00%) instrs.  127.90 sec.  3.16 GB ram.</span><br><span class="line">sample:  11277252798 ( 92.00%) instrs.  128.95 sec.  3.16 GB ram.</span><br><span class="line">sample:  11399831631 ( 93.00%) instrs.  130.46 sec.  3.16 GB ram.</span><br><span class="line">sample:  11522410472 ( 94.00%) instrs.  131.79 sec.  3.17 GB ram.</span><br><span class="line">sample:  11644989304 ( 95.00%) instrs.  133.26 sec.  3.19 GB ram.</span><br><span class="line">sample:  11767568137 ( 96.00%) instrs.  134.75 sec.  3.19 GB ram.</span><br><span class="line">sample:  11890146970 ( 97.00%) instrs.  136.06 sec.  3.20 GB ram.</span><br><span class="line">sample:  12012725817 ( 98.00%) instrs.  137.22 sec.  3.20 GB ram.</span><br><span class="line">sample:  12135304642 ( 99.00%) instrs.  138.58 sec.  3.20 GB ram.</span><br><span class="line">./sample-rr-nondet.log:  <span class="built_in">log</span> is empty.</span><br><span class="line">./sample-rr-nondet.log:  <span class="built_in">log</span> is empty.</span><br><span class="line">Time taken was: 143 seconds.</span><br><span class="line">Stats:</span><br><span class="line">RR_INPUT_1 number = 0, size = 0 bytes</span><br><span class="line">RR_INPUT_2 number = 0, size = 0 bytes</span><br><span class="line">RR_INPUT_4 number = 52356, size = 732984 bytes</span><br><span class="line">RR_INPUT_8 number = 263807, size = 4748526 bytes</span><br><span class="line">RR_INTERRUPT_REQUEST number = 41100, size = 575400 bytes</span><br><span class="line">RR_EXIT_REQUEST number = 0, size = 0 bytes</span><br><span class="line">RR_SKIPPED_CALL number = 34033, size = 76861370 bytes</span><br><span class="line">RR_END_OF_LOG number = 1, size = 10 bytes</span><br><span class="line">RR_PENDING_INTERRUPTS number = 0, size = 0 bytes</span><br><span class="line">RR_EXCEPTION number = 0, size = 0 bytes</span><br><span class="line">max_queue_len = 821</span><br><span class="line">Replay completed successfully</span><br><span class="line">Exiting cpu_handle_execption loop</span><br></pre></td></tr></table></figure><h3 id="减少分析时间"><a href="#减少分析时间" class="headerlink" title="减少分析时间"></a>减少分析时间</h3><p>回放仿真是会消耗许多时间，可以在客户系统内将性能提至最优，以达到提高分析速度的效果。以本实验使用的客户系统win7系统为例，在计算机属性内找到如下选项，选择“Adjust for best performance”并保存，即可提高分析速度。</p><p><img src="/2022/04/04/Pande%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Untitled%202.png"></p><h1 id="分析特定样本"><a href="#分析特定样本" class="headerlink" title="分析特定样本"></a>分析特定样本</h1><p>此时，我们可以使用 PANDA 记录执行并重放它，但是，我们仍然需要一种机制来允许我们记录目标应用程序的执行。目标是拥有一种灵活的方法，允许我们将应用程序从主机环境转移到客户（guest）环境，然后在客户（guest）环境中启动应用程序的执行。此外，我们希望在客户系统内不部署任何脚本或类似内容的情况下执行此操作。</p><h2 id="设置适当的快照"><a href="#设置适当的快照" class="headerlink" title="设置适当的快照"></a>设置适当的快照</h2><p>首先必须将虚拟机设置为可以轻松地从盒子外面执行我们的应用程序的状态。</p><p>方法：在客户系统中打开一个命令提示符，然后保存虚拟机状态。之后通过发送适当的击键从框外与命令提示符交互来利用此快照。</p><p>为了创建快照，在Panda中启动虚拟机并在客户环境中启动Windows命令行界面（要保证光标在界面上），如图所示：</p><p><img src="/2022/04/04/Pande%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Untitled%203.png"></p><p>此时，在QEMU命令行界面中使用<code>savevm</code>命令，保存虚拟机的状态，并创建一个快照。</p><p><img src="/2022/04/04/Pande%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Untitled%204.png"></p><p>我们可以启动这个快照，并且由于命令提示符在客户环境内，可以通过向机器发送按键keystrokes从外部控制客户机。</p><p>启动快照命令：<code>-loadvm</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./panda/build/i386-softmmu/panda-system-i386 -monitor stdio -show-cursor -m 8192 ./IE8_win7_disk1.qcow2 -loadvm 1</span><br></pre></td></tr></table></figure><p>可以很快地启动快照客户环境</p><h2 id="构建其他基础设置"><a href="#构建其他基础设置" class="headerlink" title="构建其他基础设置"></a>构建其他基础设置</h2><h3 id="记录样本程序的执行"><a href="#记录样本程序的执行" class="headerlink" title="记录样本程序的执行"></a>记录样本程序的执行</h3><p>上一步已设置了一个合适的快照，接下来要创建将应用程序发送到 VM 并在 VM 内启动应用程序的结构。</p><ul><li>方法：将样本转换为 .iso 文件，将这个 .iso 文件挂载到我们的虚拟机中，然后指示虚拟机从盒子外部抓取其 cd-rom 中的文件并将其作为应用程序启动。</li></ul><p>我们将向客户机发送按键，这将触发命令提示符中的以下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">copy D:\\sample C:\\Users\\IEUser\\Desktop\\sample.exe</span><br><span class="line">start C:\\Users\\IEUser\\Desktop\\sample.exe</span><br></pre></td></tr></table></figure><p>使用以下python脚本执行这个过程：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></span><br><span class="line"><span class="comment">#vm_record.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">PANDA_BASE = os.path.join(os.getcwd(), <span class="string">&quot;panda&quot;</span>)</span><br><span class="line">PANDA_x86 = os.path.join(PANDA_BASE, <span class="string">&quot;build&quot;</span>, <span class="string">&quot;i386-softmmu&quot;</span>, <span class="string">&quot;panda-system-i386&quot;</span>)</span><br><span class="line">IMG_PATH = os.path.join(os.getcwd(), <span class="string">&quot;IE8_win7_disk1.qcow2&quot;</span>)</span><br><span class="line"></span><br><span class="line">PANDA_flags = [</span><br><span class="line">        <span class="string">&quot;-monitor&quot;</span>, <span class="string">&quot;stdio&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-show-cursor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-m&quot;</span>, <span class="string">&quot;8192&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-loadvm&quot;</span>, <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        IMG_PATH</span><br><span class="line">    ]</span><br><span class="line">TIME_TO_EXECUTE = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_info</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] %s&quot;</span>%(msg))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_exit</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] %s&quot;</span>%(msg))</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">guest_type</span>(<span class="params">s, p</span>):</span></span><br><span class="line"><span class="comment">#cmd</span></span><br><span class="line">    <span class="comment">#cmd命令转换</span></span><br><span class="line">    keymap = &#123;</span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: <span class="string">&#x27;minus&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;=&#x27;</span>: <span class="string">&#x27;equal&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;bracket_left&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;bracket_right&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;;&#x27;</span>: <span class="string">&#x27;semicolon&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;\&#x27;&#x27;</span>: <span class="string">&#x27;apostrophe&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;\\&#x27;</span>: <span class="string">&#x27;backslash&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;,&#x27;</span>: <span class="string">&#x27;comma&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span>: <span class="string">&#x27;dot&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: <span class="string">&#x27;slash&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span>: <span class="string">&#x27;asterisk&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>: <span class="string">&#x27;spc&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;_&#x27;</span>: <span class="string">&#x27;shift-minus&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: <span class="string">&#x27;shift-equal&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;shift-bracket_left&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;shift-bracket_right&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;:&#x27;</span>: <span class="string">&#x27;shift-semicolon&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&quot;&#x27;</span>: <span class="string">&#x27;shift-apostrophe&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;|&#x27;</span>: <span class="string">&#x27;shift-backslash&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&lt;&#x27;</span>: <span class="string">&#x27;shift-comma&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&gt;&#x27;</span>: <span class="string">&#x27;shift-dot&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;?&#x27;</span>: <span class="string">&#x27;shift-slash&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;\n&#x27;</span>: <span class="string">&#x27;ret&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> string.ascii_uppercase:</span><br><span class="line">            key = <span class="string">&#x27;shift-&#x27;</span> + c.lower()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            key = keymap.get(c, c)</span><br><span class="line">        str_sendkey = <span class="string">&quot;sendkey &quot;</span>+<span class="string">&quot;%s&quot;</span>%(key)+<span class="string">&quot;\n&quot;</span></span><br><span class="line">        p.stdin.write(str_sendkey.encode())</span><br><span class="line">        p.stdin.flush()</span><br><span class="line">        time.sleep(<span class="number">.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_execution</span>(<span class="params">sample, recording_time</span>):</span></span><br><span class="line">    <span class="comment">#执行记录程序</span></span><br><span class="line">    log_info(<span class="string">&quot;Recording execution %s&quot;</span>%(sample))</span><br><span class="line">    log_info(<span class="string">&quot;Recording for %d seconds&quot;</span>%(recording_time))</span><br><span class="line"></span><br><span class="line">    new_sample = <span class="string">&quot;sample&quot;</span></span><br><span class="line">    shutil.copy(sample, new_sample)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建目标程序对应的ISO文件</span></span><br><span class="line">    cmd = []</span><br><span class="line">    cmd.append(<span class="string">&quot;/usr/bin/genisoimage&quot;</span>)</span><br><span class="line">    cmd.append(<span class="string">&quot;-iso-level&quot;</span>)</span><br><span class="line">    cmd.append(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    cmd.append(<span class="string">&quot;-l&quot;</span>)</span><br><span class="line">    cmd.append(<span class="string">&quot;-R&quot;</span>)</span><br><span class="line">    cmd.append(<span class="string">&quot;-J&quot;</span>)</span><br><span class="line">    cmd.append(<span class="string">&quot;-o&quot;</span>)</span><br><span class="line">    cmd.append(<span class="string">&quot;sample.iso&quot;</span>)</span><br><span class="line">    cmd.append(new_sample)    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        subprocess.check_call(cmd)</span><br><span class="line">        log_info(<span class="string">&quot;Made an iso file for the sample&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(traceback.format_exc())</span><br><span class="line">        <span class="built_in">print</span>(sys.exc_info()[<span class="number">0</span>])</span><br><span class="line">        log_exit(<span class="string">&quot;Could not make any iso file for the sample&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#运行Panda</span></span><br><span class="line">    cmd = []</span><br><span class="line">    cmd.append(PANDA_x86)</span><br><span class="line">    <span class="keyword">for</span> flag <span class="keyword">in</span> PANDA_flags:</span><br><span class="line">        cmd.append(flag)</span><br><span class="line">    panda_stdout_path = <span class="string">&quot;panda.stdout&quot;</span></span><br><span class="line">    panda_stderr_path = <span class="string">&quot;panda.stderr&quot;</span></span><br><span class="line">    panda_stdout = <span class="built_in">open</span>(panda_stdout_path, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line">    panda_stderr = <span class="built_in">open</span>(panda_stderr_path, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Executing command: %s&quot;</span>%(<span class="string">&quot; &quot;</span>.join(cmd)))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = subprocess.Popen(cmd,</span><br><span class="line">                stdin = subprocess.PIPE,</span><br><span class="line">                stdout = panda_stdout,</span><br><span class="line">                stderr = panda_stderr)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line">    str_mark = <span class="string">&quot;MARK\n&quot;</span></span><br><span class="line">    p.stdin.write(str_mark.encode())</span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    <span class="comment"># 检查虚拟机何时准备好让我们与之交互</span></span><br><span class="line">    f_out = <span class="built_in">open</span>(panda_stdout_path, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        content = f_out.read()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;M&quot;</span> <span class="keyword">in</span> content:</span><br><span class="line">            log_info(<span class="string">&quot;VM started&quot;</span>)  </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        f_out.seek(<span class="number">0</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置 QEMU，以便将 sample.iso 文件挂载到 cdrom 中。</span></span><br><span class="line">    p.stdin.write(<span class="string">b&quot;change ide1-cd0 sample.iso\n&quot;</span>)   </span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在win7中，cdrom会打开一个窗口，使用esc可以关闭</span></span><br><span class="line">    p.stdin.write(<span class="string">b&quot;sendkey esc\n&quot;</span>) </span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    <span class="comment"># 向客户系统中发送命令（通过qemu向刚刚打开的cmd窗口输送）</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    calc_cmd = <span class="string">&quot;calc\n&quot;</span></span><br><span class="line">    guest_type(calc_cmd, p)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    copy_cmd = <span class="string">&quot; copy D:\\sample C:\\Users\\IEUser\\Desktop\\sample.exe\n&quot;</span></span><br><span class="line">    guest_type(copy_cmd, p)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意这里并没有立即执行程序（没有添加\n），因为想在之后的begin_record后再执行它</span></span><br><span class="line">    start_cmd = <span class="string">&quot;start C:\\Users\\IEUser\\Desktop\\sample.exe&quot;</span></span><br><span class="line">    guest_type(start_cmd, p)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行程序前，开始记录</span></span><br><span class="line">    p.stdin.write(<span class="string">b&quot;begin_record sample\n&quot;</span>)</span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    <span class="comment"># 发送\n执行刚才输入的命令（执行sample.exe程序）</span></span><br><span class="line">    guest_type(<span class="string">&quot;\n&quot;</span>, p)     </span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Started recording and executed the sample in the guest machine&quot;</span>)</span><br><span class="line">    log_info(<span class="string">&quot;Recording for: %d seconds&quot;</span>%(TIME_TO_EXECUTE))</span><br><span class="line">    time.sleep(TIME_TO_EXECUTE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结束记录</span></span><br><span class="line">    p.stdin.write(<span class="string">b&quot;end_record\n&quot;</span>)</span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    <span class="comment"># 向qemu发送&#x27;q&#x27;退出环境</span></span><br><span class="line">    p.stdin.write(<span class="string">b&quot;q\n&quot;</span>)</span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    log_info(<span class="string">&quot;Recording is over, shutting the VM down&quot;</span>)</span><br><span class="line">    p.stdin.write(<span class="string">b&quot;q\n&quot;</span>)</span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        poll = p.poll()</span><br><span class="line">        <span class="keyword">if</span> poll == <span class="literal">None</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            log_info(<span class="string">&quot;VM is shut down&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Finished recording the sample execution&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(</span><br><span class="line">            <span class="string">&quot;-sample&quot;</span>, </span><br><span class="line">            <span class="built_in">help</span> = <span class="string">&quot;The sample to executed&quot;</span>,</span><br><span class="line">            required = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">            <span class="string">&quot;-time&quot;</span>,</span><br><span class="line">            <span class="built_in">help</span> = <span class="string">&quot;The number of seconds to record an execution&quot;</span>,</span><br><span class="line">            <span class="built_in">type</span> = <span class="built_in">int</span>,</span><br><span class="line">            default = <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args(args = sys.argv[<span class="number">1</span>:])</span><br><span class="line">    record_execution(args.sample, args.time)</span><br></pre></td></tr></table></figure><p>这里遇到一个问题，在<code>p.stdin.write</code>后，如果不使用<code>flush()</code>，会导致qemu接收不到输入（原文中并没有使用）</p><p>脚本使用方式：其中<code>-sample</code>参数提供主机系统上将在录制期间执行的样本的路径。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 vm_record.py -sample ./sample.exe</span><br><span class="line">[+] Recording execution ./sample.exe</span><br><span class="line">[+] Recording <span class="keyword">for</span> 25 seconds</span><br><span class="line">Warning: Creating ISO-9660:1999 (version 2) filesystem.</span><br><span class="line">Warning: ISO-9660 filenames longer than 31 may cause buffer overflows <span class="keyword">in</span> the OS.</span><br><span class="line">Total translation table size: 0</span><br><span class="line">Total rockridge attributes bytes: 247</span><br><span class="line">Total directory bytes: 0</span><br><span class="line">Path table size(bytes): 10</span><br><span class="line">Max brk space used 0</span><br><span class="line">241 extents written (0 MB)</span><br><span class="line">[+] Made an iso file <span class="keyword">for</span> the sample</span><br><span class="line">[+] Executing <span class="built_in">command</span>: /root/Desktop/panda/build/i386-softmmu/panda-system-i386 -monitor stdio -show-cursor -m 8192 -loadvm 1 /root/Desktop/IE8_win7_disk1.qcow2</span><br><span class="line">[+] VM started</span><br><span class="line">[+] Started recording and executed the sample <span class="keyword">in</span> the guest machine</span><br><span class="line">[+] Recording <span class="keyword">for</span>: 20 seconds</span><br><span class="line">[+] Recording is over, shutting the VM down</span><br><span class="line">[+] VM is shut down</span><br><span class="line">[+] Finished recording the sample execution</span><br></pre></td></tr></table></figure><h3 id="重放回放（Replaying-a-recording）"><a href="#重放回放（Replaying-a-recording）" class="headerlink" title="重放回放（Replaying a recording）"></a>重放回放（<strong>Replaying a recording</strong>）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></span><br><span class="line"><span class="comment">#vm_replay.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configs</span></span><br><span class="line">PANDA_BASE = os.path.join(os.getcwd(), <span class="string">&quot;panda&quot;</span>)</span><br><span class="line">PANDA_x86 = os.path.join(PANDA_BASE, <span class="string">&quot;build&quot;</span>, <span class="string">&quot;i386-softmmu&quot;</span>, <span class="string">&quot;panda-system-i386&quot;</span>)</span><br><span class="line">IMG_PATH = os.path.join(os.getcwd(), <span class="string">&quot;IE8_win7_disk1.qcow2&quot;</span>)</span><br><span class="line"></span><br><span class="line">PANDA_flags = [</span><br><span class="line">        <span class="string">&quot;-monitor&quot;</span>, <span class="string">&quot;stdio&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-show-cursor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-m&quot;</span>, <span class="string">&quot;8192&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The PADNA plugins we would like to use</span></span><br><span class="line">PANDA_plugins = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_info</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] %s&quot;</span>%(msg))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_exit</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] %s&quot;</span>%(msg))</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replay_recording</span>(<span class="params">snapshot_name</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Replays a recording</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    log_info(<span class="string">&quot;Replaying %s&quot;</span>%(snapshot_name))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Launch PANDA</span></span><br><span class="line">    cmd = []</span><br><span class="line">    cmd.append(PANDA_x86)</span><br><span class="line">    cmd.append(<span class="string">&quot;-replay&quot;</span>)</span><br><span class="line">    cmd.append(snapshot_name)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> flag <span class="keyword">in</span> PANDA_flags:</span><br><span class="line">        cmd.append(flag)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> plugin_cmdline <span class="keyword">in</span> PANDA_plugins:</span><br><span class="line">        cmd.append(plugin_cmdline)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Output files</span></span><br><span class="line">    panda_stdout_path = <span class="string">&quot;replay_panda.stdout&quot;</span></span><br><span class="line">    panda_stderr_path = <span class="string">&quot;replay_panda.stderr&quot;</span></span><br><span class="line">    panda_stdout = <span class="built_in">open</span>(panda_stdout_path, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line">    panda_stderr = <span class="built_in">open</span>(panda_stderr_path, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Launching replay %s&quot;</span>%(<span class="string">&quot; &quot;</span>.join(cmd)))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = subprocess.Popen(</span><br><span class="line">                <span class="string">&quot; &quot;</span>.join(cmd),</span><br><span class="line">                shell=<span class="literal">True</span>,</span><br><span class="line">                stdout = panda_stdout,</span><br><span class="line">                stderr = panda_stderr,</span><br><span class="line">                preexec_fn = os.setsid)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        log_exit(<span class="string">&quot;Could not complete replay&quot;</span>)</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Replay launched&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        poll = p.poll()</span><br><span class="line">        <span class="keyword">if</span> poll == <span class="literal">None</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            log_info(<span class="string">&quot;Replaying finished&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Analysis process finished, exiting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(</span><br><span class="line">            <span class="string">&quot;-recording&quot;</span>, </span><br><span class="line">            <span class="built_in">help</span> = <span class="string">&quot;The name of the recording to replay&quot;</span>,</span><br><span class="line">            required = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args(args = sys.argv[<span class="number">1</span>:])</span><br><span class="line">    replay_recording(args.recording)</span><br></pre></td></tr></table></figure><p>通过以下方式使用此脚本，其中<code>-recording</code>指定我们要重播的录音的名称</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 vm_replay.py -recording sample </span><br><span class="line">[+] Replaying sample</span><br><span class="line">[+] Launching replay /root/Desktop/panda/build/i386-softmmu/panda-system-i386 -replay sample -monitor stdio -show-cursor -m 8192</span><br><span class="line">[+] Replay launched</span><br><span class="line">[+] Replaying finished</span><br><span class="line">[+] Analysis process finished, exiting</span><br></pre></td></tr></table></figure><h1 id="使用Panda插件"><a href="#使用Panda插件" class="headerlink" title="使用Panda插件"></a>使用Panda插件</h1><p>上面创建了一个简单地框架，可以在Panda中使用记录（record）和回放（replay）程序。但绝大多数时候，我们希望能研究自己给定的程序。</p><h2 id="监控系统的进程"><a href="#监控系统的进程" class="headerlink" title="监控系统的进程"></a>监控系统的进程</h2><p>第一步我们选择使用Panda的两个虚拟机自省（virtual machine introspection (VMI)）插件<code>osi</code>和<code>wintrospection</code> ，来监控在系统上执行的进程。</p><ul><li>虚拟机自省（VMI）：主要的功能是从虚拟机外面 VMM层观察虚拟机，检查虚拟机的状态。</li></ul><p>这样做，与在客户系统中放置特定于分析的工件（例如分析驱动程序）相比，客户系统保持相对透明。缺点是必须纯粹通过<strong>观察内存</strong>来推断操作系统级别的抽象，并且不能使用正常的 Windows 提供的 API 来执行此操作。</p><p>扩展<code>vm_replay.py</code>脚本，在回放（replay）的时候启动插件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></span><br><span class="line"><span class="comment">#vm_replay.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">PANDA_BASE = os.path.join(os.getcwd(), <span class="string">&quot;panda&quot;</span>)</span><br><span class="line">PANDA_x86 = os.path.join(PANDA_BASE, <span class="string">&quot;build&quot;</span>, <span class="string">&quot;i386-softmmu&quot;</span>, <span class="string">&quot;panda-system-i386&quot;</span>)</span><br><span class="line">IMG_PATH = os.path.join(os.getcwd(), <span class="string">&quot;IE8_win7_disk1.qcow2&quot;</span>)</span><br><span class="line">PANDA_flags = [</span><br><span class="line">        <span class="string">&quot;-monitor&quot;</span>, <span class="string">&quot;stdio&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-show-cursor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-m&quot;</span>, <span class="string">&quot;8192&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用的Panda插件</span></span><br><span class="line">PANDA_plugins = [</span><br><span class="line">        <span class="string">&quot;-panda osi -os windows-32-7sp1 -panda wintrospection -panda osi_test&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_info</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] %s&quot;</span>%(msg))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_exit</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] %s&quot;</span>%(msg))</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replay_recording</span>(<span class="params">snapshot_name</span>):</span></span><br><span class="line">    <span class="comment">#回放</span></span><br><span class="line">    </span><br><span class="line">    log_info(<span class="string">&quot;Replaying %s&quot;</span>%(snapshot_name))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 运行Panda</span></span><br><span class="line">    cmd = []</span><br><span class="line">    cmd.append(PANDA_x86)</span><br><span class="line">    cmd.append(<span class="string">&quot;-replay&quot;</span>)</span><br><span class="line">    cmd.append(snapshot_name)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> flag <span class="keyword">in</span> PANDA_flags:</span><br><span class="line">        cmd.append(flag)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> plugin_cmdline <span class="keyword">in</span> PANDA_plugins:</span><br><span class="line">        cmd.append(plugin_cmdline)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出qemu运行信息</span></span><br><span class="line">    panda_stdout_path = <span class="string">&quot;replay_panda.stdout&quot;</span></span><br><span class="line">    panda_stderr_path = <span class="string">&quot;replay_panda.stderr&quot;</span></span><br><span class="line">    panda_stdout = <span class="built_in">open</span>(panda_stdout_path, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line">    panda_stderr = <span class="built_in">open</span>(panda_stderr_path, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Launching replay %s&quot;</span>%(<span class="string">&quot; &quot;</span>.join(cmd)))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = subprocess.Popen(</span><br><span class="line">                <span class="string">&quot; &quot;</span>.join(cmd),</span><br><span class="line">                shell=<span class="literal">True</span>,</span><br><span class="line">                stdout = panda_stdout,</span><br><span class="line">                stderr = panda_stderr,</span><br><span class="line">                preexec_fn = os.setsid)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        log_exit(<span class="string">&quot;Could not complete replay&quot;</span>)</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Replay launched&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        poll = p.poll()</span><br><span class="line">        <span class="keyword">if</span> poll == <span class="literal">None</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            log_info(<span class="string">&quot;Replaying finished&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Analysis process finished, exiting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(</span><br><span class="line">            <span class="string">&quot;-recording&quot;</span>, </span><br><span class="line">            <span class="built_in">help</span> = <span class="string">&quot;The name of the recording to replay&quot;</span>,</span><br><span class="line">            required = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args(args = sys.argv[<span class="number">1</span>:])</span><br><span class="line">    replay_recording(args.recording)</span><br></pre></td></tr></table></figure><p>这里遇到两个坑。</p><ul><li>一是对于osi插件的指定操作系统参数-os，现版本其<a href="https://github.com/panda-re/panda/tree/dev/panda/plugins/osi#command-line-arguments">README</a>和<a href="https://github.com/panda-re/panda/blob/dev/panda/src/common.c">代码</a>里的描述有差异，开始的时候只看了README，结果一直报错不通过os检查。后来看了代码才发现问题：按照README一开始使用的<code>windows-32-7</code>，但看了代码发现应该使用<code>windows-32-7sp1</code></li><li>二是在网上的教程中，作者使用的是<code>win7x86intro</code> ，但这个插件在现版本已不能使用（没了），因此我这里选择使用<code>wintrospection</code> 这一插件替代。</li></ul><p>运行回放：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 vm_replay.py -recording sample   </span><br><span class="line">[+] Replaying sample</span><br><span class="line">[+] Launching replay /root/Desktop/panda/build/i386-softmmu/panda-system-i386 -replay sample -monitor stdio -show-cursor -m 8192 -panda osi -os windows-32-7sp1 -panda wintrospection -panda osi_test</span><br><span class="line">[+] Replay launched</span><br><span class="line">[+] Replaying finished</span><br><span class="line">[+] Analysis process finished, exiting</span><br></pre></td></tr></table></figure><p>之后在输出生产的<code>replay_panda.stdout</code>中可以看到系统状态，包括系统上执行的所有进程、当前执行进程加载的 DLL 以及内核模块。但这个文件会非常的大，这里我生成的就有341M，因为在每次发生上下文切换时都会打印系统状态。部分内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">......</span><br><span class="line">Current process: csrss.exe PID:344 PPID:324</span><br><span class="line"></span><br><span class="line">Process list (48 procs):</span><br><span class="line">  smss.exe              220     4</span><br><span class="line">  csrss.exe             296     288</span><br><span class="line">  wininit.exe           332     288</span><br><span class="line">  csrss.exe             344     324</span><br><span class="line">  winlogon.exe          372     324</span><br><span class="line">  services.exe          428     332</span><br><span class="line">  lsass.exe             444     332</span><br><span class="line">  lsm.exe               452     332</span><br><span class="line">  svchost.exe           560     428</span><br><span class="line">  svchost.exe           632     428</span><br><span class="line">  svchost.exe           680     428</span><br><span class="line">  svchost.exe           808     428</span><br><span class="line">  svchost.exe           840     428</span><br><span class="line">  svchost.exe           948     428</span><br><span class="line">  explorer.exe          1100    1092</span><br><span class="line">  dwm.exe               1152    808</span><br><span class="line">  svchost.exe           1208    428</span><br><span class="line">  spoolsv.exe           1404    428</span><br><span class="line">  taskhost.exe          1448    428</span><br><span class="line">  svchost.exe           1476    428</span><br><span class="line">  vmicsvc.exe           1624    428</span><br><span class="line">  vmicsvc.exe           1644    428</span><br><span class="line">  vmicsvc.exe           1688    428</span><br><span class="line">  vmicsvc.exe           1720    428</span><br><span class="line">vmicsvc.exe           1748    428</span><br><span class="line">  svchost.exe           1784    428</span><br><span class="line">  cygrunsrv.exe         1920    428</span><br><span class="line">  wlms.exe              1976    428</span><br><span class="line">  cygrunsrv.exe         624     1920</span><br><span class="line">  conhost.exe           736     296</span><br><span class="line">  sshd.exe              892     624</span><br><span class="line">  sppsvc.exe            1064    428</span><br><span class="line">  SearchIndexer.        1244    428</span><br><span class="line">  svchost.exe           1824    428</span><br><span class="line">  SearchProtocol        2104    1244</span><br><span class="line">  SearchFilterHo        2164    1244</span><br><span class="line">  cmd.exe               2368    1100</span><br><span class="line">  conhost.exe           2376    344</span><br><span class="line">  svchost.exe           2560    428</span><br><span class="line">  svchost.exe           2660    428</span><br><span class="line">  calc.exe              2792    2368</span><br><span class="line">  taskhost.exe          2988    428</span><br><span class="line">  CompatTelRunne        3080    428</span><br><span class="line">  conhost.exe           3088    296</span><br><span class="line">  sample.exe            3180    2368</span><br><span class="line">  WmiPrvSE.exe          3236    560</span><br><span class="line">  DeviceDisplayO        3292    560</span><br><span class="line">  System                4       0</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line"></span><br><span class="line">Dynamic libraries list (18 libs):</span><br><span class="line">        0x49e30000      20480   csrss.exe                C:\Windows\system32\csrss.exe</span><br><span class="line">        0x76e60000      1314816 ntdll.dll                C:\Windows\SYSTEM32\ntdll.dll</span><br><span class="line">        0x74fc0000      53248   CSRSRV.dll               C:\Windows\system32\CSRSRV.dll</span><br><span class="line">        0x74fb0000      57344   basesrv.DLL              C:\Windows\system32\basesrv.DLL</span><br><span class="line">0x74f80000      180224  winsrv.DLL               C:\Windows\system32\winsrv.DLL</span><br><span class="line">        0x752b0000      823296  USER32.dll               C:\Windows\system32\USER32.dll</span><br><span class="line">        0x75490000      319488  GDI32.dll                C:\Windows\system32\GDI32.dll</span><br><span class="line">        0x75960000      868352  kernel32.dll             C:\Windows\SYSTEM32\kernel32.dll</span><br><span class="line">        0x75190000      307200  KERNELBASE.dll           C:\Windows\system32\KERNELBASE.dll</span><br><span class="line">        0x75480000      40960   LPK.dll                  C:\Windows\system32\LPK.dll</span><br><span class="line">        0x76ff0000      643072  USP10.dll                C:\Windows\system32\USP10.dll</span><br><span class="line">        0x75830000      704512  msvcrt.dll               C:\Windows\system32\msvcrt.dll</span><br><span class="line">        0x74f70000      36864   sxssrv.DLL               C:\Windows\system32\sxssrv.DLL</span><br><span class="line">        0x74ec0000      389120  sxs.dll                  C:\Windows\system32\sxs.dll</span><br><span class="line">        0x75780000      663552  RPCRT4.dll               C:\Windows\system32\RPCRT4.dll</span><br><span class="line">        0x74eb0000      49152   CRYPTBASE.dll            C:\Windows\system32\CRYPTBASE.dll</span><br><span class="line">        0x75ad0000      659456  ADVAPI32.dll             C:\Windows\system32\ADVAPI32.dll</span><br><span class="line">        0x77090000      102400  sechost.dll              C:\Windows\SYSTEM32\sechost.dll</span><br><span class="line"></span><br><span class="line">Kernel module list (135 modules):</span><br><span class="line">        0x82816000      4235264 ntoskrnl.exe             \SystemRoot\system32\ntoskrnl.exe</span><br><span class="line">        0x82c20000      225280  hal.dll                  \SystemRoot\system32\halmacpi.dll</span><br><span class="line">        0x80bd3000      32768   kdcom.dll                \SystemRoot\system32\kdcom.dll</span><br><span class="line">        0x8b40d000      544768  mcupdate.dll             \SystemRoot\system32\mcupdate_GenuineIntel.dll</span><br><span class="line">        0x8b492000      69632   PSHED.dll                \SystemRoot\system32\PSHED.dll</span><br><span class="line">        0x8b4a3000      32768   BOOTVID.dll              \SystemRoot\system32\BOOTVID.dll</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到，客户环境的<code>calc.exe</code>以及从本地传过去的<code>sample.exe</code>都得到了运行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本次实验，了解了Panda的记录、回放过程，完成了记录、回放对应的自动化脚本的编写，并简单使用了Panda插件。在未向客户系统预存代码的情况下，将目标程序在系统中运行，使我们能够对我们选择的给定应用程序的系统进行舒适的分析。</p>]]></content>
    
    
    <summary type="html">Panda（Platform for Architecture-Neutral Dynamic Analysis）是一个用于架构中性动态分析的开源平台。优势在于软件的快速逆向工程。</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="Panda-re" scheme="http://example.com/tags/Panda-re/"/>
    
  </entry>
  
  <entry>
    <title>Panda安装及基础操作（未完，持续记录）</title>
    <link href="http://example.com/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-26T02:00:00.000Z</published>
    <updated>2022-04-05T08:10:10.216Z</updated>
    
    <content type="html"><![CDATA[<p>动态分析是计算机安全中的一项基本技术，在处理真实程序时，动态分析通常必须在整个系统上运行，而不是仅仅在一个二进制文件上运行，在受控环境中执行样本，然后监视该环境以了解软件的行为。</p><p>Panda（Platform for Architecture-Neutral Dynamic Analysis）是目前基于QEMU 2.9.1的全系统动态分析引擎，是一个用于架构中性动态分析的开源平台。优势在于软件的快速逆向工程。</p><p>包括一个用于记录和回放执行的系统、一个用于在执行代码上运行 LLVM 分析的框架，以及一个易于扩展的插件架构。</p><p><strong>优势：可以收集一段感兴趣的执行记录，然后一遍又一遍地分析该记录。</strong>记录/重放能够一遍又一遍地重复执行跟踪，所有数据完全相同。然后，可以分析执行情况并慢慢了解事物的存储位置、正在运行的进程、关键执行事件何时发生等。</p><p><img src="/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/Untitled.png"></p><p>PANDA 还具有将 QEMU 的中间表示 TCG 转换为 LLVM 代码的功能，这使得通过 LLVM 通道编写全系统动态分析工具成为可能。这是一个强大的功能，它将两个程序分析框架 QEMU 和 LLVM 连接在一起，以利用两者之间的协同作用。</p><span id="more"></span><ul><li>项目地址</li></ul><p><a href="https://github.com/panda-re/panda">https://github.com/panda-re/panda</a></p><ul><li>用户使用文档：</li></ul><p><a href="https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#recordreplay-details">panda/manual.md at dev · panda-re/panda</a></p><h1 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h1><p>Panda插件通过两种主要方式（插件接口）与 QEMU 交互：</p><ul><li>通过检测回调</li><li>通过公开客户系统状态的检查 API，例如内存状态</li></ul><p><img src="/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/Untitled%201.png"></p><p>常见的一些回调在：<a href="https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#callback-and-plugin-management">https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#callback-and-plugin-management</a></p><p>使用回调来hook程序的执行并执行分析代码</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><hr><p>环境：Ubuntu20.04</p><h3 id="编译安装-采用"><a href="#编译安装-采用" class="headerlink" title="编译安装(采用)"></a>编译安装(采用)</h3><p><code>./install_ubuntu.sh</code></p><p><a href="https://github.com/panda-re/panda/blob/dev/panda/scripts/install_ubuntu.sh">panda/install_ubuntu.sh at dev · panda-re/panda</a></p><p><img src="/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/Untitled%202.png"></p><p>编译完成后，QEMU二进制文件位于build文件夹下；</p><p>还需要创建一个用于PANDA的Qcow（磁盘映像）</p><h3 id="PIP安装Python接口：PyPanda"><a href="#PIP安装Python接口：PyPanda" class="headerlink" title="PIP安装Python接口：PyPanda"></a>PIP安装Python接口：PyPanda</h3><p>安装一些依赖：</p><p><code>apt install libvdeplug-dev libpng16-16 libsdl2-2.0-0</code></p><p><code>pip3 install pandare</code></p><p>这将安装基于 python 的 PANDA 分析所需的一切，但不会安装独立的 PANDA 二进制文件。 这个包不会自动更新，所以它可能落后于 PANDA 的 master 分支。</p><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p><code>panda</code>容器：安装了 Panda 和 PyPANDA 以及它们的运行时依赖项的容器，但没有构建工件或源代码以减小容器的大小。</p><p><code>pandadev</code>容器：安装了 Panda和 PyPANDA 以及它们的运行时依赖项的容器，所有构建工件和源代码以及目录中此存储库的内容。（适合开发者）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull pandare/pandadev</span><br><span class="line">$ docker run --rm pandare/pandadev /panda/build/panda-system-i386 --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h1 id="记录Record和重放Replay"><a href="#记录Record和重放Replay" class="headerlink" title="记录Record和重放Replay"></a>记录Record和重放Replay</h1><hr><p>确定性记录和重放是一种用于捕获系统的 非确定性输入的技术（如果系统使用相同的输入从同一点重新启动，会导致系统行为不同的事物。）</p><ul><li>Panda记录的非确定性输入是对 CPU 状态和内存所做的更改——DMA、中断、in指令等等</li><li>Panda不记录设备的输入</li><li>想象在CPU与RAM外画个圈，记录从外部世界跨过这条线的东西</li></ul><h3 id="记录Record"><a href="#记录Record" class="headerlink" title="记录Record"></a>记录Record</h3><p>可以使用 QEMU 监视器中的 <code>begin_record</code> 和 <code>end_record</code> 命令来记录执行情况。</p><ul><li>begin_record <name><ul><li>开始录制会话，另存为<name>，会覆盖之前的记录</name></li><li>会生成两个文件：<ul><li>VM 快照<code>&lt;name&gt;-rr-snp</code></li><li>所有非确定性输入的日志<code>&lt;name&gt;-rr-nondet.log</code></li></ul></li></ul></name></li><li>end_record<ul><li>结束活动的录制会话，guest将被暂停，但可以恢复，并且一旦恢复guest，就可以进行另一次录制。</li></ul></li></ul><p>监视器，使用 <code>-monitor stdio</code> 运行 QEMU（也有更复杂的设置）。 输入 <code>begin_record &quot;replay_name&quot;</code> 开始录制过程，并使用 <code>end_record</code> 结束它。</p><h3 id="重放Replay"><a href="#重放Replay" class="headerlink" title="重放Replay"></a>重放Replay</h3><p>重放记录（replay recording）：可以使用 （这两个文件）<code>panda-system-$arch -replay replay_name</code>。确保将相同的内存大小传递给 VM，就像记录所做的那样。否则 QEMU 将失败并出现无法理解的错误。</p><p>仅仅运行重放本身并不是很有用，可以启用一些插件，对重放的执行进行分析。</p><h3 id="分享记录"><a href="#分享记录" class="headerlink" title="分享记录"></a>分享记录</h3><p>Pande支持打包和解压记录</p><ul><li>打包记录（这将捆绑<code>&lt;name&gt;-rr-snp</code>与<code>&lt;name&gt;-rr-nondet.log</code>放入 <code>&lt;name&gt;.rr</code>）：  <code>scripts/rrpack.py &lt;name&gt;</code></li><li>解压记录  <code>scripts/rrunpack.py &lt;name&gt;.rr</code></li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>捕获重放（Replay）后，可以多次播放它。通常首先使用标准分析来尝试了解正在发生的事情的基本情况，然后使用自定义插件（<code>panda_plugins</code>目录）来进行更具体的分析。</p><p>常用于开始分析的插件：<code>asidstory</code>、 <code>stringsearch</code>和 <code>file_taint</code></p>]]></content>
    
    
    <summary type="html">Panda（Platform for Architecture-Neutral Dynamic Analysis）是一个用于架构中性动态分析的开源平台。优势在于软件的快速逆向工程。</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="Panda-re" scheme="http://example.com/tags/Panda-re/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读--&quot;Symbolic Execution for Software Testing&quot;</title>
    <link href="http://example.com/2022/02/10/Symbolic%20Execution%20for%20Software%20Testing%20Three%20Deca/"/>
    <id>http://example.com/2022/02/10/Symbolic%20Execution%20for%20Software%20Testing%20Three%20Deca/</id>
    <published>2022-02-10T13:00:00.000Z</published>
    <updated>2022-05-10T07:40:29.495Z</updated>
    
    <content type="html"><![CDATA[<p>该论文以较为通俗的语言和简单的例子阐述了符号执行的基本原理，并介绍了符号执行技术的发展历程和面临挑战。通过本文，可以基本的了解符号执行<br>论文地址：<a href="https://dl.acm.org/doi/fullHtml/10.1145/2408776.2408795">https://dl.acm.org/doi/fullHtml/10.1145/2408776.2408795</a></p><span id="more"></span><p>软件测试环境中，符号执行的一个关键目标是在一定的时间内探索尽可能多的不同程序路径，并为每一条路径：</p><p>（1）生成一组具体的输入值来执行该路径</p><p>（2）检查是否存在各种错误，包括断言违规、未捕获的异常、安全漏洞、内存损坏等</p><h2 id="符号执行关键思想"><a href="#符号执行关键思想" class="headerlink" title="符号执行关键思想"></a>符号执行关键思想</h2><hr><h3 id="关键思想"><a href="#关键思想" class="headerlink" title="关键思想"></a>关键思想</h3><p>符号执行关键思想：使用符号值，而不是具体的数据值作为输入，并将程序变量的值表示为符号表达式，而不是符号输入值。那么，程序的输出值为符号输入值的一种函数 function(symbolic_input_values)。</p><h3 id="程序表达方式"><a href="#程序表达方式" class="headerlink" title="程序表达方式"></a>程序表达方式</h3><p>具体而言，符号执行为程序每个执行路径生产测试用例。而程序的执行路径可以分为true和false的序列，在序列的第i个位置为true则表示第i个条件判断语句执行then分支，若为false则执行else分支。</p><p>每个程序的执行路径都可以用执行树来表达，后面会通过例子理解。</p><p>符号执行的目标就是生成一组输入，在一定的时间内遍历尽可能多的路径。</p><h2 id="符号执行思路与过程"><a href="#符号执行思路与过程" class="headerlink" title="符号执行思路与过程"></a>符号执行思路与过程</h2><hr><p>符号执行拥有两个变量：</p><ul><li><strong>符号状态 σ</strong> ：表示变量到符号表达式的<strong>映射集合</strong></li><li><strong>符号路径约束 PC</strong> ：是符号表达式的无量词的一阶式</li></ul><p>在符号开始之前，符号状态 σ 为空集，PC 初始化为 <code>True</code></p><p>当一条路径执行结束时，使用约束求解器求解PC，可以生成具体的输入值。（对于该输入值，如果程序以其作为输入，程序将执行与符号执行完全相同的路径并以相同的方式终止）</p><p>那么符号状态 σ和符号路径约束 PC是怎么变化的呢？</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testme</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    z = twice(y);</span><br><span class="line">    <span class="keyword">if</span> (z == x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y + <span class="number">10</span>)</span><br><span class="line">            ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = sym_input();</span><br><span class="line">    y = sym_input();</span><br><span class="line">    testme(x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/02/10/Symbolic%20Execution%20for%20Software%20Testing%20Three%20Deca/Untitled.png"></p><p>可以看到<code>void testme(int x, int y)</code>函数存在三条执行路径；上图表示这对应的执行树。</p><p>当符号执行开始执行时：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">符号状态 σ = 空集</span><br><span class="line">符号路径约束 PC = True</span><br></pre></td></tr></table></figure><ul><li>当符号执行遇到一个输入语句时，形式为<code>var = sym_input()</code>，符号执行将为符号状态<strong>σ</strong>添加映射：<img src="http://latex.codecogs.com/svg.latex?var \rightarrow s"></li></ul><p> 其中<img src="http://latex.codecogs.com/svg.latex?s"> 是一个新的未约束的符号值。</p><p>例如，对于上面的例子，在执行第16、17行：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> x = sym_input();</span><br><span class="line"> y = sym_input();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>后，符号状态<img src="http://latex.codecogs.com/svg.latex?\sigma=\{x \rightarrow x_0,y \rightarrow y_0\}">，其中$x_0，y_0$是新的未约束的符号值。</p><ul><li>当符号执行遇到一个赋值语句时，形式为<code>v = e</code>，符号执行将为符号状态<strong>σ</strong>添加映射：<img src="http://latex.codecogs.com/svg.latex?v \rightarrow \sigma(e)">，其中$σ(e)$就是在当前符号化状态计算e得到的符号表达式。</li></ul><p>例如，对于上面的例子，在执行第6行：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * v;</span><br><span class="line">&#125;</span><br><span class="line">    z = twice(y);</span><br></pre></td></tr></table></figure><p>后，符号状态<img src="http://latex.codecogs.com/svg.latex?\sigma=\{x \rightarrow x_0,y \rightarrow y_0\, z \rightarrow 2y_0\}"></p><ul><li>当符号执行遇到一个条件语句<code>if(e)  S1  else  S2</code>，PC会有两种更新：<ol><li>首先更新PC（表示then分支）为：<img src="http://latex.codecogs.com/svg.latex?PC = PC  \Lambda  \sigma(e)"></li><li>之后建立一个路径约束(else语句)PC‘：<img src="http://latex.codecogs.com/svg.latex?PC^{'} = PC \Lambda \lnot\sigma(e)"></li></ol><ul><li>如果PC可以满足对符号值的某些分配，给一些实际值，那么符号执行继续沿着then这条分支执行下去，且符号状态为σ和符号路径约束为PC；</li><li>同样，如果PC’可满足，PC‘则使用符号状态σ和符号路径约束PC’创建另一个符号执行的实例，并沿着“else”分支继续执行；</li><li>与直接执行程序所不同的是，符号执行的两个分支都可以执行，从而产生两条路径；如果没有满足的分支PC，符号执行将终止</li></ul></li></ul><p>例如，对于上面的例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">z = twice(y);</span><br><span class="line"><span class="keyword">if</span> (z == x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y + <span class="number">10</span>)</span><br><span class="line">        ERROR;</span><br></pre></td></tr></table></figure><p>在第7行，会创建两个路径约束实例，路径约束分别为：</p><p><img src="http://latex.codecogs.com/svg.latex?x_0 = 2y_0">      和   <img src="http://latex.codecogs.com/svg.latex?x_0\neq2y_0"></p><p>在第7行，会创建两个路径约束实例，路径约束分别为：</p><p><img src="http://latex.codecogs.com/svg.latex?(x_0 = 2y_0)\Lambda(x_0>y_0+10)">      和    <img src="http://latex.codecogs.com/svg.latex?(x_0 = 2y_0)\Lambda(x_0 \leq y_0+10)"></p><ul><li>当符号执行遇到exit语句或错误（程序崩溃、违反断言等），将终止符号执行的当前实例，利用约束求解器对当前符号路径约束<strong>PC</strong>得到一个可满足的值，该值就构成了测试用例输入。  即：如果程序执行这些可满足的实际值，就会采用与符号执行完全相同的路径，并以相同的方式结束。</li><li>当符号执行遇到循环和递归时，符号执行可能会导致无限多条路径，如下图：</li></ul><p><img src="/2022/02/10/Symbolic%20Execution%20for%20Software%20Testing%20Three%20Deca/Untitled%201.png"></p><p>这段代码就有无数条执行路径，每条路径的可能性有两种：①任意数量的True加上一个False结尾；②无穷多数量的True。</p><p>对于这种情况：</p><p>符号路径约束<img src="http://latex.codecogs.com/svg.latex?PC =(\wedge_ {i\in [1,n]}N_{i} >0) \wedge (N_{n+1}\leq 10)">  其中每个$N_{i}$都是一个新的符号值</p><p>执行结尾符号状态 <img src="http://latex.codecogs.com/svg.latex?\sigma =\{N \rightarrow N_{n+1} , sum \rightarrow \sum Ni\}"></p><p>在实践中，需要对搜索进行限制（时间超时、路径数、循环迭代次数、搜索深度等）</p><h3 id="静态符号执行的缺点"><a href="#静态符号执行的缺点" class="headerlink" title="静态符号执行的缺点"></a>静态符号执行的缺点</h3><ul><li>关键缺点：当符号执行得到的约束不能被约束求解器求解时，就无法生产输入</li></ul><p>假如上面的代码例子产生变化：</p><p>① twice函数发生了改变：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span> <span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (v∗v) % <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则符号执行到twice函数时，会产生两个路径约束：</p><img src="http://latex.codecogs.com/svg.latex?x_0 \neq (y_0y_0)mod50"><img src="http://latex.codecogs.com/svg.latex?x_0 = (y_0y_0)mod50"><p>② 假设twice函数不可用（例如没有函数源码），则会产生两个路径约束：</p><img src="http://latex.codecogs.com/svg.latex?x_0 \neq twice(y_0)"><img src="http://latex.codecogs.com/svg.latex?x_0=twice(y_0)"><p>其中，<img src="http://latex.codecogs.com/svg.latex?twice">是一个未解释的函数</p><p>在这两种情况下，约束求解器无法解决任何这些约束，符号执行将无法为修改后的程序生成任何输入。</p><p>为了缓解这个问题，研究者提出了混合符号执行 concolic execution（实际执行+符号执行）的方法，这是一种动态的符号执行，可以为修改后的程序生产一些输入。</p><h2 id="混合符号执行（Concolic-Execution）"><a href="#混合符号执行（Concolic-Execution）" class="headerlink" title="混合符号执行（Concolic Execution）"></a>混合符号执行（Concolic Execution）</h2><hr><p>混合符号执行Concolic Execution（实际执行+符号执行），是一种动态符号执行。在执行符号执行的同时，程序也在一些具体的输入值上执行。</p><p>Concolic Execution维护一个具体状态和一个符号状态。</p><ul><li>具体状态将所有变量映射到它们的具体值</li><li>符号状态仅映射具有非具体值的变量</li></ul><p>与经典的符号执行不同，混合符号执行在过程中需要获取程序的具体状态，因此它需要初始的具体值作为输入。</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>Concolic Executio的初试输入可以给定或随机生成，在执行过程中收集条件语句中对输入的符号约束，然后使用约束求解器推断先前输入的变体（取反等），以便将程序的下一次执行引导到另一条执行路径。</p><p>系统地或启发式地重复该过程，直到探索完所有执行路径，满足用户定义的覆盖标准，或时间预算到期。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testme</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    z = twice(y);</span><br><span class="line">    <span class="keyword">if</span> (z == x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y + <span class="number">10</span>)</span><br><span class="line">            ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = sym_input();</span><br><span class="line">    y = sym_input();</span><br><span class="line">    testme(x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是以上面的程序为例：</p><ol><li>首先，Concolic Execution先产生一些随机输入，例如{x = 22, y = 7}</li><li>之后，同时具体地和符号化地执行程序。 当实际执行到第7行的else分支时，符号执行会在该执行路径生成路径约<img src="http://latex.codecogs.com/svg.latex?x_0\neq2y_0"></li><li>之后，Concolic Execution会将路径约束的连接词取反，得到<img src="http://latex.codecogs.com/svg.latex?x_0= 2y_0">，并求解，可得到一种测试用例输入：{x = 2, y = 1}</li><li>通过这个新的测试用例输入，Concolic Execution会得到并进入新的路径，并同时开启新的实际执行与符号执行。 在本例中，就会进入到第7行的then分支和第8行的else分支，此时就会产生新的路径约束：<img src="http://latex.codecogs.com/svg.latex?(x_0=2y_0) \Lambda (x_0 \leq y_0+10)">，对于此约束进行约束求解，生成新的测试输入，可以让程序继续执行之前没有执行过的路径；而再对该约束取反，得到：<img src="http://latex.codecogs.com/svg.latex?(x_0=2y_0) \Lambda (x_0 > y_0+10)">，就可以探索到新的路径，例如：{x = 30, y = 15}，使用这个测试输入，程序会触发第9行的ERROR。</li><li>通过这三次执行程序，Concolic Execution已经覆盖了程序的所有路径，并停止生产测试用例输入</li></ol><p>注意，这里使用“深度优先”的搜索策略来探索所有的执行路径；我们也可以使用其他策略来探索不同顺序的路径。</p><h2 id="执行生成测试-EGT"><a href="#执行生成测试-EGT" class="headerlink" title="执行生成测试(EGT)"></a>执行生成测试(EGT)</h2><hr><p>本文作者通过<a href="https://dl.acm.org/doi/abs/10.1145/1455518.1455522">EXE</a>和<a href="https://www.usenix.org/legacy/event/osdi08/tech/full_papers/cadar/cadar.pdf">Klee</a> 这两篇工作，实现和扩展了<a href="https://link.springer.com/chapter/10.1007/11537328_2">EGT方法</a> （Execution-Generated Testing）</p><p>EGT方法区分了程序的具体状态和符号状态，通过在每次操作之前动态检查所涉及的值是否是实际的，将具体执行和符号执行混合在一起。</p><p>如果是实际值，那么就按照程序本身执行；相反，如果至少有一个值是符号化的，则通过更新当前路径的路径条件以符号方式执行。</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>还是以上面的程序为例，在第17行处，如果把<code>y**=**sym input()</code> 改为 <code>y = 10</code>，那么第6行<code>z **=**twice (y);</code> 函数将使用具体值 “20”来调用函数twice(20)，完成实际执行。</p><p>之后，第7行<code>if (z == x)</code>将变为<code>if (20 == x)</code>    </p><p>约束<img src="http://latex.codecogs.com/svg.latex?x=20">，程序走then分支</p><p>约束<img src="http://latex.codecogs.com/svg.latex?x \neq 20">，程序走else分支</p><p>注意，在then分支，程序走到第8行为<code>if (x &gt; 20)</code>， 由于x = 20，则无法往下继续走。</p><p>总之，混合符号执行Concolic Execution与执行生成测试EGT，主要的贡献都是结合了实际执行与符号执行，缓解了传统符号执行的缺点。它们都是动态符号执行的范畴。</p><h2 id="动态符号执行的缺点"><a href="#动态符号执行的缺点" class="headerlink" title="动态符号执行的缺点"></a>动态符号执行的缺点</h2><hr><p>动态符号执行的优点是：可以使用具体值，来降低与外部代码交互或约束求解超时所导致的不精确性，这缓解了传统符号执行遇到的问题。但是这个过程遇到的问题是，会丢失一些执行路径，从而牺牲了完整性。</p><ul><li>先回顾一下Concolic Execution是怎样解决静态符号执行的缺点的：  例如，在上面的代码例子中，将twice函数进行改变：返回值改为<code>(v*v)%50</code>  ，而且程序执行的初试随机值为{x = 22, y = 7}，则针对该随机输入，生成的路径约束为 <img src="http://latex.codecogs.com/svg.latex?x_{0}\ne (y_{0} y_{0}) mod 50">  假设约束求解器不能解决非线性约束，则Concolic Execution将无法为替代执行路径生成输入。当函数twice的源代码不可用时（是某个第三方库函数或系统调用），会出现类似情况，此时，路径约束为<img src="http://latex.codecogs.com/svg.latex?x_0 \neq twice(y_0)"> ，其中<img src="http://latex.codecogs.com/svg.latex?twice">是一个未解释的函数。  以上是前文静态符号执行的缺点，混合符号执行Concolic Execution会通过使用实际值替换符号值的方式解决这个问题。例如，将<img src="http://latex.codecogs.com/svg.latex?y0">使用实际值 “7” 替换。那么上面的路径约束就简化为：<img src="http://latex.codecogs.com/svg.latex?x_0 \neq 49"> ，求解该约束，可以得到一个探索新路径的输入：{x = 49, y = 7}。以此解决了传统符号执行（静态符号执行）的缺点。</li></ul><p>但是，这个例子中，无法生成路径true, false的输入，即在代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testme</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    z = twice(y);</span><br><span class="line">    <span class="keyword">if</span> (z == x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y + <span class="number">10</span>)</span><br><span class="line">            ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中，符合if (z == x)，但又不符合if (x &gt; y + 10)，进不去ERROR</p><p>即：无法生成对于约束<img src="http://latex.codecogs.com/svg.latex?x_{0}= (y_{0} y_{0}) mod 50\wedge (x_{0}\leq y_{0}+10)">的测试输入，因为<img src="http://latex.codecogs.com/svg.latex?y_0">的值已经被实际化为“7”了。因此会造成路径的丢失，失去了路径完整性。</p><p>但是相比与传统符号执行遇到不受支持的操作或外部调用问题时直接终止执行，混合符号执行Concolic Execution的方法还是更可取。</p><h2 id="符号执行的挑战"><a href="#符号执行的挑战" class="headerlink" title="符号执行的挑战"></a>符号执行的挑战</h2><hr><h3 id="一、路径爆炸"><a href="#一、路径爆炸" class="headerlink" title="一、路径爆炸"></a>一、路径爆炸</h3><p>符号执行的关键挑战之一就是路径爆炸问题。除了较小的程序外，所有程序中都有大量的程序路径，这通常是代码中静态分支数量的指数级。限制符号执行时间及循环迭代次数都可以缓解这一问题，主要的方法包括：</p><ul><li>启发式技术-优先探索最有希望的路径  启发式技术是用于确定路径探索优先顺序的关键机制。<ul><li>使用CFG来探索，尽量选择与未覆盖指令最接近的路径</li><li>基于随机探索，将符号探索与随机测试相结合</li></ul></li><li>使用合理的程序分析技术降低路径探索的复杂性<ul><li>使用 selelct 表达式进行静态融合，然后将其直接传递给约束求解器</li><li>通过缓存和重用底层函数的计算结果，减小分析的复杂性</li></ul></li></ul><p>以上这些方法都是当时其他文献的工作，这里没有深入研究。</p><h3 id="二、约束求解"><a href="#二、约束求解" class="headerlink" title="二、约束求解"></a>二、约束求解</h3><p>两种优化方法：</p><ul><li>不相关的约束消除：通常一个程序分支只依赖于一小部分的程序变量，因此一种有效的优化是从当前路径条件中移除与识别当前分支不相关的约束</li><li>增量求解：在符号执行期间生成的约束集的一个重要特征是，它们以来自程序源代码的一组固定的静态分支来表示。所以，多个路径可能会产生相似的约束集，所以可以使用相似的解决方案。通过重用以前相似请求得到的结果，可以提升约束求解的速度（CUTE、KLEE使用）</li></ul><h3 id="三、内存建模"><a href="#三、内存建模" class="headerlink" title="三、内存建模"></a>三、内存建模</h3><p>程序语句转换为符号约束的精确性对符号执行的覆盖率有很大的影响。内存建模可以引申为其他方面的挑战，主要是符号执行如何模拟具体的系统环境。</p><p>精确度和可伸缩性之间的权衡应该根据要分析的代码(例如，低级系统代码与高级应用程序代码)以及不同约束求解理论之间的确切性能差异来确定。而在动态符号执行中，可以通过自定义符号公式中具体值的使用来调整可伸缩性和精度。</p><h3 id="四、处理并发性"><a href="#四、处理并发性" class="headerlink" title="四、处理并发性"></a>四、处理并发性</h3><p>动态符号执行已经被有效地用于测试并发程序，包括具有复杂数据输入的应用程序、分布式系统等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;该论文以较为通俗的语言和简单的例子阐述了符号执行的基本原理，并介绍了符号执行技术的发展历程和面临挑战。通过本文，可以基本的了解符号执行&lt;br&gt;论文地址：&lt;a href=&quot;https://dl.acm.org/doi/fullHtml/10.1145/2408776.2408795&quot;&gt;https://dl.acm.org/doi/fullHtml/10.1145/2408776.2408795&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="符号执行" scheme="http://example.com/categories/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    
    
    <category term="符号执行" scheme="http://example.com/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    
    <category term="论文阅读" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Fuzzing101 Exercise 2 - libexif - CVE-2009-3895&amp;CVE-2012-2836</title>
    <link href="http://example.com/2022/01/10/Exercise%202/"/>
    <id>http://example.com/2022/01/10/Exercise%202/</id>
    <published>2022-01-10T13:00:00.000Z</published>
    <updated>2022-04-05T08:08:46.450Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%202">Fuzzing101/Exercise 2 at main · antonio-morales/Fuzzing101</a></p><ul><li>任务：在libexif中，找到两个crash  <strong><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895">CVE-2009-3895</a>&amp;****<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836">CVE-2012-2836</a></strong></li><li>版本：libexif 0.6.14</li><li><strong><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895">CVE-2009-3895</a>：</strong>一种基于堆的缓冲区溢出，可以用无效的 EXIF 图像触发。<ul><li>漏洞描述：基于堆的缓冲区溢出是一种发生在堆数据区的缓冲区溢出，它通常与显式动态内存管理（使用 malloc() 和 free() 函数进行分配/释放）有关。因此，远程攻击者可以利用此问题在使用受影响库的应用程序上下文中执行任意代码。</li></ul></li><li><strong><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836">CVE-2012-2836</a>：</strong>一个越界读取漏洞，可以通过带有精心制作的 EXIF 标签的图像触发。<ul><li>漏洞描述：越界读取是当程序读取数据超过预期缓冲区的末尾或开头之前发生的漏洞。因此，它允许远程攻击者导致拒绝服务或可能从进程内存中获取潜在的敏感信息。</li></ul></li><li>本地实验环境：<strong>虚拟机Ubuntu 20.04.3 LTS</strong><span id="more"></span></li></ul><hr><p>AFL使用非确定性测试算法，因此两个模糊会话永远不会相同。因此作者强烈建议设置一个固定的种子(-s 123)。这样模糊结果将类似于这些显示，更容易跟随练习。</p><p>作者建议使用<strong>Ubuntu 20.04.2 LTS</strong>，因为作者已在该环境下测试过，而且建议使用主机而不是虚拟机，以发挥AFL更好的性能</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><hr><ul><li>下载安装libexif-0.6.14</li></ul><p>新建目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line">mkdir fuzzing_libexif &amp;&amp; <span class="built_in">cd</span> fuzzing_libexif/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/libexif/libexif/archive/refs/tags/libexif-0_6_14-release.tar.gz</span><br><span class="line">tar -xzvf libexif-0_6_14-release.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> libexif-libexif-0_6_14-release/</span><br><span class="line">sudo apt-get install autopoint libtool gettext libpopt-dev</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>选择libexif调用接口—exif</li></ul><p>由于 libexif 是一个库，因此我们需要另一个使用该库的应用程序，并将对其进行模糊测试。对于此任务，我们将使用<strong>exif</strong> 命令行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif</span><br><span class="line">wget https://github.com/libexif/exif/archive/refs/tags/exif-0_6_15-release.tar.gz</span><br><span class="line">tar -xzvf exif-0_6_15-release.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> exif-exif-0_6_15-release/</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/install/&quot;</span> PKG_CONFIG_PATH=<span class="variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>测试是否安装成功：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/fuzzing_libexif/install/bin/exif</span><br></pre></td></tr></table></figure><p><img src="/2022/01/10/Exercise%202/Untitled.png"></p><ul><li>建立种子语料库（<strong>Seed corpus</strong>）</li></ul><p>我们需要获取一些 exif 样本。我们将使用以下 repo 中的示例图像：<a href="https://github.com/ianare/exif-samples">https</a> : <a href="https://github.com/ianare/exif-samples">//github.com/ianare/exif-samples</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif</span><br><span class="line">wget https://github.com/ianare/exif-samples/archive/refs/heads/master.zip</span><br><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure><p>之后，我们可以这样使用（举例）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/fuzzing_libexif/install/bin/exif <span class="variable">$HOME</span>/fuzzing_libexif/exif-samples-master/jpg/Canon_40D_photoshop_import.jpg</span><br></pre></td></tr></table></figure><ul><li><strong>Afl-clang-lto</strong></li></ul><p>使用<strong>afl-clang-lto</strong>作为编译器来构建 libexif</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -r <span class="variable">$HOME</span>/fuzzing_libexif/install</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif/libexif-libexif-0_6_14-release/</span><br><span class="line">make clean</span><br><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif/exif-exif-0_6_15-release</span><br><span class="line">make clean</span><br><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/install/&quot;</span> PKG_CONFIG_PATH=<span class="variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>一般来说，<em>afl-clang-lto</em>是最好的选择，因为它是一种无碰撞的仪器（<strong>instrumentation</strong>），而且比<em>afl-clang-fast 更快</em>。</p><p>如果您不确定何时使用<em>afl-clang-lto</em>或<em>afl-clang-fast，</em>您可以查看从<a href="https://github.com/AFLplusplus/AFLplusplus#1-instrumenting-that-target">AFLplusplus</a>提取的下图来选择</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+--------------------------------+</span><br><span class="line">| clang/clang++ 11+ is available | --&gt; use LTO mode (afl-clang-lto/afl-clang-lto++)</span><br><span class="line">+--------------------------------+     see [instrumentation/README.lto.md](instrumentation/README.lto.md)</span><br><span class="line">    |</span><br><span class="line">    | <span class="keyword">if</span> not, or <span class="keyword">if</span> the target fails with LTO afl-clang-lto/++</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">+---------------------------------+</span><br><span class="line">| clang/clang++ 6.0+ is available | --&gt; use LLVM mode (afl-clang-fast/afl-clang-fast++)</span><br><span class="line">+---------------------------------+     see [instrumentation/README.llvm.md](instrumentation/README.llvm.md)</span><br><span class="line">    |</span><br><span class="line">    | <span class="keyword">if</span> not, or <span class="keyword">if</span> the target fails with LLVM afl-clang-fast/++</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"> +--------------------------------+</span><br><span class="line"> | gcc 5+ is available            | -&gt; use GCC_PLUGIN mode (afl-gcc-fast/afl-g++-fast)</span><br><span class="line"> +--------------------------------+    see [instrumentation/README.gcc_plugin.md](instrumentation/README.gcc_plugin.md) and</span><br><span class="line">                                       [instrumentation/README.instrument_list.md](instrumentation/README.instrument_list.md)</span><br><span class="line">    |</span><br><span class="line">    | <span class="keyword">if</span> not, or <span class="keyword">if</span> you <span class="keyword">do</span> not have a gcc with plugin support</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">   use GCC mode (afl-gcc/afl-g++) (or afl-clang/afl-clang++ <span class="keyword">for</span> clang)</span><br></pre></td></tr></table></figure><h1 id="开始模糊测试"><a href="#开始模糊测试" class="headerlink" title="开始模糊测试"></a>开始模糊测试</h1><hr><p>运行fuzz</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i <span class="variable">$HOME</span>/fuzzing_libexif/exif-samples-master/jpg/ -o <span class="variable">$HOME</span>/fuzzing_libexif/out/ -s 123 -- <span class="variable">$HOME</span>/fuzzing_libexif/install/bin/exif @@</span><br></pre></td></tr></table></figure><p>可以发现许多crash</p><p><img src="/2022/01/10/Exercise%202/Untitled%201.png"></p><h1 id="使用Eclipse-CDT调试"><a href="#使用Eclipse-CDT调试" class="headerlink" title="使用Eclipse-CDT调试"></a>使用Eclipse-CDT调试</h1><p>安装JAVA-SDK</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install default-jdk</span><br></pre></td></tr></table></figure><p>下载Eclipse：<a href="https://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/2021-12/R/eclipse-cpp-2021-12-R-linux-gtk-x86_64.tar.gz">https://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/2021-12/R/eclipse-cpp-2021-12-R-linux-gtk-x86_64.tar.gz</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzvf eclipse-cpp-2021-03-R-linux-gtk-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>完成这两步后，打开Eclipse — File — Import — C/C++ — “Existing code as makefile project”</p><p><img src="/2022/01/10/Exercise%202/Untitled%202.png"></p><p>之后选择Linux GCC 并选择exif源码文件夹</p><p><img src="/2022/01/10/Exercise%202/Untitled%203.png"></p><p>之后可以在项目资源管理器中看到exif文件夹。</p><p>现在要配置调试的参数。Run — Debug Configurations，选择我们的exif项目及exif二进制文件</p><p><img src="/2022/01/10/Exercise%202/Untitled%204.png"></p><p>之后要设置Arguments，我们找到刚才AFL产生的crash路径，选一条复制进去</p><p>【至于选择哪一条，这里确实不太明白】</p><p><img src="/2022/01/10/Exercise%202/Untitled%205.png"></p><p>点击Debug后，程序会停在main函数开头</p><p><img src="/2022/01/10/Exercise%202/Untitled%206.png"></p><p>Run — Resume 检测到分段错误时会自动停止运行</p><p><img src="/2022/01/10/Exercise%202/Untitled%207.png"></p><h1 id="实验总结与心得"><a href="#实验总结与心得" class="headerlink" title="实验总结与心得"></a>实验总结与心得</h1><hr><ol><li>每次fuzz，不管时间是多少，产生crash数量与类型都是不同的。</li><li>多个crash，可能指向的代码点是同一处。</li><li>作者指出的这两处CVE的溢出点，我在fuzz产生的crash调试时，都没有发现（即使第二次fuzz了3个小时，产生了30个crash，也没有发现）</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%202&quot;&gt;Fuzzing101/Exercise 2 at main · antonio-morales/Fuzzing101&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务：在libexif中，找到两个crash  &lt;strong&gt;&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895&quot;&gt;CVE-2009-3895&lt;/a&gt;&amp;amp;****&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836&quot;&gt;CVE-2012-2836&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;版本：libexif 0.6.14&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895&quot;&gt;CVE-2009-3895&lt;/a&gt;：&lt;/strong&gt;一种基于堆的缓冲区溢出，可以用无效的 EXIF 图像触发。&lt;ul&gt;
&lt;li&gt;漏洞描述：基于堆的缓冲区溢出是一种发生在堆数据区的缓冲区溢出，它通常与显式动态内存管理（使用 malloc() 和 free() 函数进行分配/释放）有关。因此，远程攻击者可以利用此问题在使用受影响库的应用程序上下文中执行任意代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836&quot;&gt;CVE-2012-2836&lt;/a&gt;：&lt;/strong&gt;一个越界读取漏洞，可以通过带有精心制作的 EXIF 标签的图像触发。&lt;ul&gt;
&lt;li&gt;漏洞描述：越界读取是当程序读取数据超过预期缓冲区的末尾或开头之前发生的漏洞。因此，它允许远程攻击者导致拒绝服务或可能从进程内存中获取潜在的敏感信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本地实验环境：&lt;strong&gt;虚拟机Ubuntu 20.04.3 LTS&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Fuzzing101 Exercise 1 - Xpdf - CVE-2019-13288</title>
    <link href="http://example.com/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/"/>
    <id>http://example.com/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/</id>
    <published>2021-11-29T13:00:00.000Z</published>
    <updated>2021-11-29T14:25:59.655Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201">Fuzzing101/Exercise 1 at main · antonio-morales/Fuzzing101</a></p><ul><li>任务：在Xpdf这一PDF阅读器中，找到一个crash  [<strong>CVE-2019-13288]</strong></li><li>版本：XPDF 3.02</li><li>CVE-2019-13288：是一个可能通过精心制作的文件导致无限递归的漏洞<ul><li>漏洞描述：由于程序中每个被调用的函数在堆栈上分配一个堆栈帧，如果一个函数被递归调用太多次，可能会导致堆栈内存耗尽和程序崩溃。因此，远程攻击者可以利用这一点进行DoS攻击。</li><li>详细信息：<a href="https://www.cvedetails.com/cve/CVE-2019-13288/">https://www.cvedetails.com/cve/CVE-2019-13288/</a></li></ul></li><li>本地实验环境：<strong>虚拟机Ubuntu 20.04.3 LTS</strong></li><li>关于非受控递归漏洞：<a href="https://cwe.mitre.org/data/definitions/674.html">https://cwe.mitre.org/data/definitions/674.html</a><span id="more"></span></li></ul><hr><p>AFL使用非确定性测试算法，因此两个模糊会话永远不会相同。因此作者强烈建议设置一个固定的种子(-s 123)。这样模糊结果将类似于这些显示，更容易跟随练习。</p><p>作者建议使用<strong>Ubuntu 20.04.2 LTS</strong>，因为作者已在该环境下测试过，而且建议使用主机而不是虚拟机，以发挥AFL更好的性能</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><hr><p>新建目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line">mkdir fuzzing_xpdf &amp;&amp; <span class="built_in">cd</span> fuzzing_xpdf/</span><br></pre></td></tr></table></figure><p>安装额外工具（即 make 和 gcc）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install build-essential</span><br></pre></td></tr></table></figure><p>下载XPDF 3.02</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gz</span><br><span class="line">tar -xvzf xpdf-3.02.tar.gz</span><br></pre></td></tr></table></figure><p>构建XPDF</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> xpdf-3.02</span><br><span class="line">sudo apt update &amp;&amp; sudo apt install -y build-essential gcc</span><br><span class="line">./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_xpdf/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>下载PDF示例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_xpdf</span><br><span class="line">mkdir pdf_examples &amp;&amp; <span class="built_in">cd</span> pdf_examples</span><br><span class="line">wget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdf</span><br><span class="line">wget http://www.africau.edu/images/default/sample.pdf</span><br><span class="line">wget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf</span><br></pre></td></tr></table></figure><p>使用以下命令测试pdfinfo二进制文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/fuzzing_xpdf/install/bin/pdfinfo -box -meta <span class="variable">$HOME</span>/fuzzing_xpdf/pdf_examples/helloworld.pdf</span><br></pre></td></tr></table></figure><p>得到：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled.png"></p><h1 id="安装AFL"><a href="#安装AFL" class="headerlink" title="安装AFL++"></a>安装AFL++</h1><hr><p>作者推荐本地安装（也可以使用Docker）</p><p>安装依赖：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools</span><br><span class="line">sudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang </span><br><span class="line">sudo apt-get install -y gcc-$(gcc --version|head -n1|sed <span class="string">&#x27;s/.* //&#x27;</span>|sed <span class="string">&#x27;s/\..*//&#x27;</span>)-plugin-dev libstdc++-$(gcc --version|head -n1|sed <span class="string">&#x27;s/.* //&#x27;</span>|sed <span class="string">&#x27;s/\..*//&#x27;</span>)-dev</span><br></pre></td></tr></table></figure><p>构建AFL++</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/AFLplusplus/AFLplusplus &amp;&amp; <span class="built_in">cd</span> AFLplusplus</span><br><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line">make distrib</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>安装成功：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%201.png"></p><p>为了我们的目标应用程序启用检测，我们需要使用 AFL 的编译器编译代码</p><p>首先，我们将清理所有以前编译的目标文件和可执行文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -r <span class="variable">$HOME</span>/fuzzing_xpdf/install</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_xpdf/xpdf-3.02/</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p>使用<strong>afl-clang-fast</strong>编译器构建 xpdf ：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line">CC=<span class="variable">$HOME</span>/AFLplusplus/afl-clang-fast CXX=<span class="variable">$HOME</span>/AFLplusplus/afl-clang-fast++ ./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_xpdf/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>之后可以使用以下命令来运行fuzz</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i <span class="variable">$HOME</span>/fuzzing_xpdf/pdf_examples/ -o <span class="variable">$HOME</span>/fuzzing_xpdf/out/ -s 123 -- <span class="variable">$HOME</span>/fuzzing_xpdf/install/bin/pdftotext @@ <span class="variable">$HOME</span>/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure><p>每个选项的简要说明：</p><ul><li>-<em>i</em>表示我们必须放置输入案例（文件示例）的目录</li><li>-<em>o</em>表示 AFL++ 将存储变异文件的目录</li><li>-<em>s</em>表示要使用的静态随机种子</li><li>*@@*是占位符目标的命令行，AFL 将用每个输入文件名替换它</li></ul><p>等待一段时间后，发现crash，之后可以直接<code>ctrl+c</code>结束fuzz。</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%202.png"></p><h1 id="分析crash"><a href="#分析crash" class="headerlink" title="分析crash"></a>分析crash</h1><hr><p>在<code>$HOME/fuzzing_xpdf/out/</code>目录中找到crash对应的文件：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%203.png"></p><p>将此文件作为输入传递给 pdftotext 二进制文件(如果系统报打不开文件，就改下文件名，例如test.pdf)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/fuzzing_xpdf/install/bin/pdftotext <span class="string">&#x27;$HOME/fuzzing_xpdf/out/default/crashes/&lt;your_filename&gt;&#x27;</span> <span class="variable">$HOME</span>/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure><p>这里注意两个坑，一是不能直接使用pdftotext XXX，结果是不一样的；二是要把命令中间的引号去掉才能运行，不知道这里作者用的引号是什么意思</p><p>最终输出：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%204.png"></p><p>开始使用GDB来查找产生crash的原因</p><p>首先，需要使用调试信息重建 Xpdf 以获得符号堆栈跟踪：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -r <span class="variable">$HOME</span>/fuzzing_xpdf/install</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_xpdf/xpdf-3.02/</span><br><span class="line">make clean</span><br><span class="line">CFLAGS=<span class="string">&quot;-g -O0&quot;</span> CXXFLAGS=<span class="string">&quot;-g -O0&quot;</span> ./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_xpdf/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>运行GDB：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb --args <span class="variable">$HOME</span>/fuzzing_xpdf/install/bin/pdftotext <span class="variable">$HOME</span>/fuzzing_xpdf/out/default/crashes/&lt;your_filename&gt; <span class="variable">$HOME</span>/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%205.png"></p><p>输入<code>run</code>得到：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%206.png"></p><p>之后输入<code>bt</code> 查看调用栈</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%207.png"></p><p>发现程序一直在调用<code>Parser::getObj</code>这一函数，这也正匹配了<a href="https://www.cvedetails.com/cve/CVE-2019-13288/">https://www.cvedetails.com/cve/CVE-2019-13288/</a>中描述的该CVE漏洞信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">In Xpdf 4.01.01, the Parser::getObj() <span class="keyword">function</span> <span class="keyword">in</span> Parser.cc may cause infinite recursion via a crafted file. A remote attacker can leverage this <span class="keyword">for</span> a DoS attack. This is similar to CVE-2018-16646.</span><br><span class="line">Publish Date : 2019-07-04 Last Update Date : 2020-08-24</span><br><span class="line"></span><br><span class="line">在 Xpdf 4.01.01 中，Parser.cc 中的 Parser::getObj() 函数可能会通过精心制作的文件导致无限递归。远程攻击者可以利用它进行 DoS 攻击。这类似于 CVE-2018-16646。</span><br><span class="line">发布日期：2019-07-04 最后更新日期：2020-08-24</span><br></pre></td></tr></table></figure><h1 id="修复bug"><a href="#修复bug" class="headerlink" title="修复bug"></a>修复bug</h1><hr><p>这里我们可以下载已修复错误的 Xpdf 4.02，对比下代码：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%208.png"></p><p>参考资料：</p><p><a href="https://chowdera.com/2021/09/20210912223059406n.html">https://chowdera.com/2021/09/20210912223059406n.html</a></p><p><a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201">https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise 1</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201&quot;&gt;Fuzzing101/Exercise 1 at main · antonio-morales/Fuzzing101&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务：在Xpdf这一PDF阅读器中，找到一个crash  [&lt;strong&gt;CVE-2019-13288]&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;版本：XPDF 3.02&lt;/li&gt;
&lt;li&gt;CVE-2019-13288：是一个可能通过精心制作的文件导致无限递归的漏洞&lt;ul&gt;
&lt;li&gt;漏洞描述：由于程序中每个被调用的函数在堆栈上分配一个堆栈帧，如果一个函数被递归调用太多次，可能会导致堆栈内存耗尽和程序崩溃。因此，远程攻击者可以利用这一点进行DoS攻击。&lt;/li&gt;
&lt;li&gt;详细信息：&lt;a href=&quot;https://www.cvedetails.com/cve/CVE-2019-13288/&quot;&gt;https://www.cvedetails.com/cve/CVE-2019-13288/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本地实验环境：&lt;strong&gt;虚拟机Ubuntu 20.04.3 LTS&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;关于非受控递归漏洞：&lt;a href=&quot;https://cwe.mitre.org/data/definitions/674.html&quot;&gt;https://cwe.mitre.org/data/definitions/674.html&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>IDA Python 常用API（持续更新）</title>
    <link href="http://example.com/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://example.com/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2021-11-17T13:21:00.000Z</published>
    <updated>2021-11-18T03:05:58.230Z</updated>
    
    <content type="html"><![CDATA[<p>环境：IDAPro 7.6</p><p>（注意IDAPro 7.4版本后，IDA Python的API版本与7.4之前的版本发生了很多变化，具体区别请看<a href="https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml">https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml</a>）</p><span id="more"></span><h2 id="常见模块"><a href="#常见模块" class="headerlink" title="常见模块"></a>常见模块</h2><p>在IDA中.有三个重要的库.分别是IDC,idautils,idaapi</p><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>IDC</td><td>封装IDA与IDC函数的兼容性模块.</td></tr><tr><td>idautils</td><td>高级实用的模块</td></tr><tr><td>idaapi</td><td>允许访问更加底层的数据</td></tr></tbody></table><h2 id="获取IDA界面地址"><a href="#获取IDA界面地址" class="headerlink" title="获取IDA界面地址"></a>获取IDA界面地址</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>取当前地址</td><td>idc.here() 或 idc.get_screen_ea()</td></tr><tr><td>获取最小地址（可以使用的）</td><td>ida_ida.inf_get_min_ea()</td></tr><tr><td>获取最大地址（可以使用的）</td><td>ida_ida.inf_get_max_ea()</td></tr><tr><td>获取所选范围的起始地址</td><td>idc.read_selection_start()</td></tr><tr><td>获取所选范围的结束地址</td><td>idc.read_selection_end()</td></tr><tr><td></td><td></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;当前地址：&#x27;</span>+<span class="built_in">hex</span>(idc.here()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;基址：&#x27;</span>+<span class="built_in">hex</span>(ida_ida.inf_get_min_ea())))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled.png"></p><h2 id="获取地址的数值"><a href="#获取地址的数值" class="headerlink" title="获取地址的数值"></a>获取地址的数值</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>以1字节为单位获取地址处的值</td><td>idc.get_wide_byte(addr)</td></tr><tr><td>以2字节(字)的单位获取</td><td>idc.get_wide_word(addr)</td></tr><tr><td>以4字节的单位获取</td><td>idc.get_wide_dword(addr)</td></tr><tr><td>以8字节的单位获取</td><td>idc.get_qword(addr)</td></tr><tr><td>判断是否是字节</td><td>ida_bytes.is_byte</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;当前地址：&#x27;</span>+<span class="built_in">hex</span>(idc.here()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;值&#x27;</span>+<span class="built_in">hex</span>(idc.get_wide_byte(idc.here())))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%201.png"></p><h2 id="修改指令数值"><a href="#修改指令数值" class="headerlink" title="修改指令数值"></a>修改指令数值</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>修改addr地址的值为value.每次修改1个字节</td><td>ida_bytes.patch_byte(addr,value)</td></tr><tr><td>每次修改2个字节</td><td>ida_bytes.patch_word(addr,value)</td></tr><tr><td>每次修改4个字节</td><td>ida_bytes.patch_Dword(addr,value)</td></tr><tr><td>每次修改8个字节</td><td>ida_bytes.patch_Qword(addr,value)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line">addr = idc.here()</span><br><span class="line">value_before = idc.get_wide_byte(addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改之前：&quot;</span>+ <span class="built_in">hex</span>(value_before))</span><br><span class="line"></span><br><span class="line">ida_bytes.patch_byte(addr,<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">value_after = idc.get_wide_byte(addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改之后：&quot;</span>+ <span class="built_in">hex</span>(value_after))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%202.png" alt="Untitled"></p><h2 id="汇编指令操作"><a href="#汇编指令操作" class="headerlink" title="汇编指令操作"></a>汇编指令操作</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取地址处的汇编语句</td><td>idc.GetDisasm(addr) 或 idc.generate_disasm_line(addr,flags)</td></tr><tr><td>获取指定地址位置的操作数.参数1是地址.参数2是操作数索引.如 mov ebp,esp中： 操作数1是ebp ，操作数2是esp mov则是汇编指令不是操作数</td><td>idc.print_operand(addr,index)</td></tr><tr><td>获取汇编操作指令（如mov、add）</td><td>idc.print_insn_mnem(addr)</td></tr><tr><td>获取操作数的类型</td><td>idc.get_operand_type(addr,index)</td></tr><tr><td>获取指定索引操作数中的值: 如 calll 0x00402004 对应汇编为: FF 15 04 20 40 00 FF15=Call 而操作数的值则为04 20 40 00 (小端) 使用函数之后获取则为地址 00402004</td><td>idc.get_operand_value(addr,index)</td></tr><tr><td>获取下一行汇编</td><td>idc.next_head(addr)</td></tr><tr><td>获取上一行汇编</td><td>idc.PrevHead(addr)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line">ea = idc.here();</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基址为: &quot;</span> + <span class="built_in">hex</span>(idaapi.get_imagebase()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前汇编: &quot;</span> + idc.GetDisasm(ea))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前汇编指令为: &quot;</span> + idc.print_insn_mnem(ea))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前操作数为: &quot;</span> + idc.print_operand(ea,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%203.png" alt="Untitled"></p><h2 id="段操作"><a href="#段操作" class="headerlink" title="段操作"></a>段操作</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取段的名字（参数为当前的地址）</td><td>idc.get_segm_name(addr)</td></tr><tr><td>获取段的开始地址</td><td>idc.get_segm_start(addr)</td></tr><tr><td>获取段的结束地址</td><td>idc.get_segm_end(addr)</td></tr><tr><td>获取第一个段</td><td>idc.get_first_seg(addr)</td></tr><tr><td>获取下一个段</td><td>idc.get_next_seg(addr)</td></tr><tr><td>返回一个列表记录所有段的地址</td><td>idautil.Segments()</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> seg_addr <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">    segname = idc.get_segm_name(seg_addr)</span><br><span class="line">    segstart = idc.get_segm_start(seg_addr)</span><br><span class="line">    segend   = idc.get_segm_end(seg_addr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;段名：&quot;</span> + segname + <span class="string">&quot;起始地址：&quot;</span> + <span class="built_in">hex</span>(segstart) + <span class="string">&quot;结束地址：&quot;</span> + <span class="built_in">hex</span>(segend));</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%204.png" alt="Untitled"></p><h2 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取指定地址之间的所有函数</td><td>idautils.Functions(startaddr,endaddr)</td></tr><tr><td>获取指定地址的函数名</td><td>idc.get_func_name(addr)</td></tr><tr><td>获取函数的注释</td><td>get_func_cmt(addr, repeatable)  repeatable:0/1    0是获取常规注释 1是获取重复注释</td></tr><tr><td>设置函数注释</td><td>idc.set_func_cmt(ea, cmt, repeatable)</td></tr><tr><td>弹出框框要求用户进行选择 参数则是信息</td><td>idc.choose_func(title)</td></tr><tr><td>返回: addr 距离函数的偏移形式</td><td>idc.get_func_off_str(addr)</td></tr><tr><td>寻找函数结尾,如果函数存在则返回结尾地址,否则返回BADADDR</td><td>idc.find_func_end(addr)</td></tr><tr><td>设置函数结尾</td><td>ida_funcs.set_func_end(ea, newend)      newend:新的结束地址</td></tr><tr><td>设置函数开头</td><td>ida_funcs.set_func_start(addr, newstart)</td></tr><tr><td>设置地址处的名字</td><td>idc.set_name(ea, name, SN_CHECK)                 Ex函数也使用set_name</td></tr><tr><td>获取首个函数</td><td>idc.get_prev_func(ea)</td></tr><tr><td>获取下一个函数</td><td>idc.get_next_func(ea)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">    segname = idc.get_segm_name(seg)</span><br><span class="line">    segstart = idc.get_segm_start(seg)</span><br><span class="line">    segend = idc.get_segm_end(seg)</span><br><span class="line">    <span class="keyword">if</span> (segname == <span class="string">&#x27;.text&#x27;</span>):</span><br><span class="line">        <span class="keyword">for</span> funcaddr <span class="keyword">in</span> Functions(segstart,segend):</span><br><span class="line">            funname = idc.get_func_name(funcaddr)</span><br><span class="line">            funend =  idc.find_func_end(funcaddr)</span><br><span class="line">            funnext = idc.get_next_func(funcaddr)</span><br><span class="line">            funnextname = idc.get_func_name(funnext)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;当前函数名: &quot;</span> + funname + <span class="string">&quot;当前结束地址: &quot;</span> + <span class="built_in">hex</span>(funend) +<span class="string">&quot;下一个函数地址: &quot;</span> + <span class="built_in">hex</span>(funnext) + <span class="string">&quot;下一个函数名: &quot;</span> + funnextname)</span><br><span class="line">ea = idc.get_screen_ea()</span><br><span class="line">funnextoffset = idc.get_func_off_str(ea)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前选择地址距离当前函数的偏移为: &quot;</span>+ funnextoffset)</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%205.png" alt="Untitled"></p><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p> 在IDAPython中如果我们想查询某些 数据 代码 二进制 都可以用都搜索函数。</p><p>搜索函数可以是向上搜索 也可以是向下搜索. 搜索失败就会返回-1 也就是BADADDR。</p><p>而搜索功能也常常用于去除花指令当中。</p><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>查找二进制找到返回地址没找到返回-1(BADADDR)</td><td>idc.find_binary(ea, flag, searchstr, radix=16, from_bc695=False)</td></tr><tr><td>从ea开始寻找下一个数据地址</td><td>ida_search.find_data(ea, sflag)</td></tr><tr><td>从ea开始寻找下一个代码地址</td><td>ida_search.find_code(ea, sflag)</td></tr><tr><td>跳转到ea位置</td><td>ida_kernwin.jumpto(ea)</td></tr><tr><td></td><td></td></tr></tbody></table><p>flags取值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SEARCH_DOWN 向下搜索</span><br><span class="line">SEARCH_UP 向上搜索</span><br><span class="line">SEARCH_NEXT 获取下一个找到的对象。</span><br><span class="line">SEARCH_CASE 指定大小写敏感度</span><br><span class="line">SEARCH_UNICODE 搜索 Unicode 字符串。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line">addr = idc.here()</span><br><span class="line">value = idc.find_binary(ea,SEARCH_DOWN,<span class="string">&#x27;C4 00 C4&#x27;</span>)</span><br><span class="line">value1 = idc.find_code(ea,SEARCH_DOWN)</span><br><span class="line">value2 = idc.find_data(ea,SEARCH_DOWN)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前位置：&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;C4 00 C4 所在位置：&quot;</span>+<span class="built_in">hex</span>(value))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下一处代码位置：&quot;</span>+<span class="built_in">hex</span>(value1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下一处数据位置：&quot;</span>+<span class="built_in">hex</span>(value2))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%206.png" alt="Untitled"></p><h2 id="数据校验函数"><a href="#数据校验函数" class="headerlink" title="数据校验函数"></a>数据校验函数</h2><p>数据校验函数有一个参数flag，得到flag后可以直接进行校验</p><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取标志</td><td>ida_bytes.get_full_flags(ea)</td></tr><tr><td>判断是否为代码</td><td>ida_bytes.is_code(f)                                                                     f即标志</td></tr><tr><td>判断是否为数据</td><td>ida_bytes.is_data(f)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line">addr = idc.here()</span><br><span class="line">value = idc.find_binary(ea,SEARCH_DOWN,<span class="string">&#x27;C4 00 C4&#x27;</span>)</span><br><span class="line">value1 = idc.find_code(ea,SEARCH_DOWN)</span><br><span class="line">value2 = idc.find_data(ea,SEARCH_DOWN)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前位置：&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;C4 00 C4 所在位置：&quot;</span>+<span class="built_in">hex</span>(value))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下一处代码位置：&quot;</span>+<span class="built_in">hex</span>(value1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下一处数据位置：&quot;</span>+<span class="built_in">hex</span>(value2))</span><br><span class="line">flag1 = ida_bytes.get_full_flags(value1)</span><br><span class="line">flag2 = ida_bytes.get_full_flags(value2)</span><br><span class="line"><span class="comment">#print(flag)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">hex</span>(value1)) +<span class="string">&quot;处是不是代码？：&quot;</span>  + <span class="built_in">str</span>(ida_bytes.is_code(flag1)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">hex</span>(value2)) +<span class="string">&quot;处是不是代码？：&quot;</span>  + <span class="built_in">str</span>(ida_bytes.is_code(flag2)))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%207.png" alt="Untitled"></p><h2 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h2><p>在IDA的操作中 我们常常会对一个函数按X快捷键来查看谁引用了</p><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取地址处引用位置 A调用B 对B函数地址使用此函数则找到A调用 返回列表.遍历列表则可以找出所有引用位置. 参数1是ea也就是地址,参数2告诉IDA是否跟踪这些代码.</td><td>idautils.CodeRefsTo(ea, flow)</td></tr><tr><td>返回ea的代码引用了何处的代码. 返回一个列表</td><td>idautils.CodeRefsFrom(ea, flow)</td></tr><tr><td>返回一个列表告诉ea位置的数据被谁引用了</td><td>idautils.DataRefsTo(ea)</td></tr><tr><td>告诉我们ea引用了谁.</td><td>idautils.DataRefsFrom(ea)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line">addr = idc.here()   </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> CodeRefsTo(addr,<span class="literal">False</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前汇编: &quot;</span> + idc.GetDisasm(i))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%208.png" alt="Untitled"></p><p>除了上述通过地址来查找引用的方式外，还可以通过函数名来进行查找交叉引用：</p><p>1、先通过<code>idc.get_name_ea_simple(fun_name)</code>找到函数的线性地址</p><p>2、再使用<code>for i in CodeRefsTo(addr,False)</code>得到所有引用的地址</p><p>一个例子：<a href="https://hotspurzzz.github.io/2021/11/12/IDA-Python%20%E6%89%B9%E9%87%8F%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/">https://hotspurzzz.github.io/2021/11/12/IDA-Python 批量脚本分析程序/</a></p><p>官网API文档：</p><p><a href="https://www.hex-rays.com/wp-content/static/products/ida/support/idapython_docs/">https://www.hex-rays.com/wp-content/static/products/ida/support/idapython_docs/</a></p><p>参考链接：</p><p><a href="https://www.cnblogs.com/iBinary/p/14642662.html">https://www.cnblogs.com/iBinary/p/14642662.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;环境：IDAPro 7.6&lt;/p&gt;
&lt;p&gt;（注意IDAPro 7.4版本后，IDA Python的API版本与7.4之前的版本发生了很多变化，具体区别请看&lt;a href=&quot;https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml&quot;&gt;https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml&lt;/a&gt;）&lt;/p&gt;</summary>
    
    
    
    <category term="IDA" scheme="http://example.com/categories/IDA/"/>
    
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
    <category term="IDA Python" scheme="http://example.com/tags/IDA-Python/"/>
    
  </entry>
  
  <entry>
    <title>IDA-Python 批量脚本分析程序</title>
    <link href="http://example.com/2021/11/12/IDA-Python%20%E6%89%B9%E9%87%8F%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2021/11/12/IDA-Python%20%E6%89%B9%E9%87%8F%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-11-12T08:00:00.000Z</published>
    <updated>2021-11-12T10:51:58.777Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，IDA Python对于分析二进制程序来说是一个非常好用的工具。<br>当面对大量的二进制文件需要分析时，可以实现自动化批量处理。<br>环境：IDA Pro7.5    Python3.7</p><span id="more"></span><p>这里准备两个python文件</p><h3 id="analysis-py"><a href="#analysis-py" class="headerlink" title="analysis.py"></a>analysis.py</h3><p>实现对二进制程序的具体分析</p><p>Demo:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> ida_auto</span><br><span class="line"><span class="keyword">import</span> ida_pro</span><br><span class="line"><span class="keyword">import</span> ida_nalt</span><br><span class="line"><span class="keyword">import</span> ida_ida</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis</span>():</span></span><br><span class="line">    <span class="comment">#Do Some Things</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    ida_auto.auto_wait()</span><br><span class="line">    analysis()</span><br><span class="line">    ida_pro.qexit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="run-py"><a href="#run-py" class="headerlink" title="run.py"></a>run.py</h3><p>Demo:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">dir_path = <span class="string">&quot;path_to_binfile&quot;</span></span><br><span class="line">ida64_path = <span class="string">&quot;path_to_ida&quot;</span></span><br><span class="line">analysis_file = <span class="string">&quot;path_to_analysis.py&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(dir_path):</span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> files:</span><br><span class="line">            file_path = os.path.join(root, file_name)</span><br><span class="line">            cmd = <span class="string">&quot;&#123;0&#125; -LD:/mylog.log -c -A -S&#123;1&#125; &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(ida64_path, ana_file, file_path)</span><br><span class="line">            p = subprocess.Popen(cmd)</span><br><span class="line">            p.wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>dir_path</code> 指需要进行分析的二进制文件的目录</p><p><code>ida64_path</code>指向本地IDA程序</p><p><code>analysis_file</code>指向前面的analysis.py</p><h3 id="小示例"><a href="#小示例" class="headerlink" title="小示例"></a>小示例</h3><p>这里需要来分析多个二进制文件中某个函数的调用地址(相对地址）：</p><p>analysis.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> ida_auto</span><br><span class="line"><span class="keyword">import</span> ida_pro</span><br><span class="line"><span class="keyword">import</span> ida_nalt</span><br><span class="line"><span class="keyword">import</span> ida_ida</span><br><span class="line"></span><br><span class="line">outfile = <span class="built_in">open</span>(<span class="string">&quot;result.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis</span>():</span></span><br><span class="line">    addr_base = ida_ida.inf_get_min_ea()</span><br><span class="line">    danger_funcs = [<span class="string">&quot;system&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> danger_funcs:</span><br><span class="line">        addr = idc.get_name_ea_simple(func)</span><br><span class="line">        filename = ida_nalt.get_root_filename()</span><br><span class="line">        <span class="keyword">if</span> addr != BADADDR:</span><br><span class="line">            cross_refs = CodeRefsTo( addr, <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">for</span> ref <span class="keyword">in</span> cross_refs:</span><br><span class="line">                ref = ref - addr_base</span><br><span class="line">                outfile.write(filename + <span class="string">&quot;-&quot;</span> + <span class="string">&quot;%s&quot;</span> % func + <span class="string">&quot;-0x&quot;</span> + <span class="string">&quot;%08x&quot;</span> % ref + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    ida_auto.auto_wait()</span><br><span class="line">    analysis()</span><br><span class="line">    ida_pro.qexit(<span class="number">0</span>)</span><br><span class="line">    outfile.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p> run.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">dir_path = <span class="string">&quot;C://Users/Desktop/bin_file&quot;</span></span><br><span class="line">ida64_path = <span class="string">&quot;E://IDA_Pro_v7.5_Portable/ida.exe&quot;</span></span><br><span class="line">analysis_file = <span class="string">&quot;C://Users/Desktop/analysis.py&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(dir_path):</span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> files:</span><br><span class="line">            <span class="built_in">print</span>(file_name)</span><br><span class="line">            file_path = os.path.join(root, file_name)</span><br><span class="line">            cmd = <span class="string">&quot;&#123;0&#125; -LD:/mylog.log -c -A -S&#123;1&#125; &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(ida64_path, ana_file, file_path)</span><br><span class="line">            p = subprocess.Popen(cmd)</span><br><span class="line">            p.wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>只需python3 run.py即可</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>IDA python中的API在7.4版本后产生了变化，如果本地使用的IDA Pro版本≥7.4，之前在网上搜的API可能就无法使用，旧版本与新版本相对应的API变化在这可以查询：</p><p><a href="https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml">https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知，IDA Python对于分析二进制程序来说是一个非常好用的工具。&lt;br&gt;当面对大量的二进制文件需要分析时，可以实现自动化批量处理。&lt;br&gt;环境：IDA Pro7.5    Python3.7&lt;/p&gt;</summary>
    
    
    
    <category term="IDA" scheme="http://example.com/categories/IDA/"/>
    
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
    <category term="IDA Python" scheme="http://example.com/tags/IDA-Python/"/>
    
  </entry>
  
  <entry>
    <title>shellphish-fuzzer环境搭建</title>
    <link href="http://example.com/2021/11/09/shellphish-fuzzer%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2021/11/09/shellphish-fuzzer%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-11-09T08:00:00.000Z</published>
    <updated>2022-03-26T07:49:08.689Z</updated>
    
    <content type="html"><![CDATA[<p>搭建shellphish-fuzzer环境，用于python调用AFL<br>环境：Docker—ubuntu18.04<br>python版本：3.6.9</p><span id="more"></span><p>注：由于个人网络问题，github源使用的<code>https://github.com.cnpmjs.org</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; \</span><br><span class="line">    apt-get upgrade -y &amp;&amp; \</span><br><span class="line">    apt-get autoremove -y &amp;&amp; \</span><br><span class="line">    apt-get install -y \</span><br><span class="line">        curl \</span><br><span class="line">        gdb \</span><br><span class="line">        wget \</span><br><span class="line">        git \</span><br><span class="line">        vim</span><br></pre></td></tr></table></figure><p>换源：</p><p><code>vim /etc/apt/sources.list</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>shellphish-fuzzer的安装：</p><p><code>apt-get install build-essential gcc-multilib libtool automake autoconf bison debootstrap debian-archive-keyring libtool-bin</code></p><p><code>apt-get build-dep qemu</code></p><p>由于没有pip，先安装pip3：</p><p><code>apt-get install python3-pip</code></p><p>安装angr</p><p><code>pip3 install angr</code></p><p>安装driller</p><p><code>pip3 install git+https://github.com.cnpmjs.org/angr/tracer</code></p><p><code>pip3 install git+https://github.com.cnpmjs.org/shellphish/driller</code></p><p>安装afl（可选）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir afl-latest</span><br><span class="line"><span class="built_in">cd</span> afl-latest</span><br><span class="line">wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz</span><br><span class="line">tar xf afl-latest.tgz</span><br><span class="line"><span class="built_in">cd</span> afl-2.52b</span><br><span class="line">make</span><br><span class="line"><span class="built_in">cd</span> qemu_mode</span><br><span class="line">wget -O patches/memfd.diff https://salsa.debian.org/qemu-team/qemu/raw/ubuntu-bionic-2.11/debian/patches/ubuntu/lp1753826-memfd-fix-configure-test.patch</span><br><span class="line">sed -i <span class="string">&#x27;/syscall.diff/a patch -p1 &lt;../patches/memfd.diff || exit 1&#x27;</span> build_qemu_support.sh</span><br><span class="line">./build_qemu_support.sh</span><br></pre></td></tr></table></figure><p>安装shellphish-afl</p><p><code>pip3 install git+https://github.com.cnpmjs.org/shellphish/shellphish-afl</code></p><p>但我使用这种方法会报错</p><p>于是我选择clone下来，执行setup.py</p><p><code>git clone[https://github.com.cnpmjs.org/shellphish/shellphish-afl.git](https://github.com.cnpmjs.org/shellphish/shellphish-afl.git)</code></p><p><code>cd shellphish-afl/</code></p><p><code>python3 [setup.py](http://setup.py/) install</code></p><p>安装fuzzer</p><p><code>pip3 install git+https://github.com.cnpmjs.org/shellphish/fuzzer</code></p><p>测试：</p><p><code>shellphuzz --help</code></p><p><img src="/2021/11/09/shellphish-fuzzer%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Untitled.png"></p><p><img src="/2021/11/09/shellphish-fuzzer%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Untitled%201.png"></p><p>参考链接：</p><p><a href="https://github.com/shellphish/fuzzer">https://github.com/shellphish/fuzzer</a></p><p><a href="https://github.com/shellphish/shellphish-afl">https://github.com/shellphish/shellphish-afl</a></p><p><a href="https://blog.grimm-co.com/2020/05/guided-fuzzing-with-driller.html">https://blog.grimm-co.com/2020/05/guided-fuzzing-with-driller.html</a></p><p>附Dockerfile：</p><p><a href="Dockerfile.txt">Dockerfile</a></p>]]></content>
    
    
    <summary type="html">搭建shellphish-fuzzer环境，用于python调用AFL</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
    <category term="AEG" scheme="http://example.com/tags/AEG/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell反混淆学习</title>
    <link href="http://example.com/2021/11/01/PowerShell%E5%8F%8D%E6%B7%B7%E6%B7%86/"/>
    <id>http://example.com/2021/11/01/PowerShell%E5%8F%8D%E6%B7%B7%E6%B7%86/</id>
    <published>2021-11-01T08:01:18.000Z</published>
    <updated>2021-11-09T08:50:10.007Z</updated>
    
    <content type="html"><![CDATA[<p>PowerShell功能十分强大，其有很多优点：例如易于导入模块，能够访问核心API和远程命令，也正是由于这些优点使其成为攻击者执行无文件攻击的首选工具之一。</p><span id="more"></span><h1 id="常见混淆方式"><a href="#常见混淆方式" class="headerlink" title="常见混淆方式"></a>常见混淆方式</h1><p>例如：变换大小写、字符串分割、将变量插入命令语句中（最常见的是-f格式转换）、变量中增加反引号“`”、字符串之间添加空格、字符转换ASCII码、利用replace函数替换、base64加密等等……</p><p>如图所示：</p><p><img src="/2021/11/01/PowerShell%E5%8F%8D%E6%B7%B7%E6%B7%86/Untitled.png"></p><h2 id="人工去混淆"><a href="#人工去混淆" class="headerlink" title="人工去混淆"></a>人工去混淆</h2><p>先通过几个例子来了解PowerShell样本例子来了解去混淆的方式</p><h3 id="iex"><a href="#iex" class="headerlink" title="iex"></a>iex</h3><p>例如：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.( <span class="variable">$SHEllID</span>[<span class="number">1</span>]+<span class="variable">$shEllid</span>[<span class="number">13</span>]+<span class="string">&#x27;x&#x27;</span>) (( <span class="string">&#x27;118&amp;105N64J100J25V19J4&amp;5&amp;26~25f3&amp;25N64G64C100~4f5_30C15Z25~64~67f9G56Z47C43N62V47f46V106Z37~36V112~106&amp;67&amp;114V101_120V120~101N120C122&amp;123_126V64V67&amp;9N56Z47_43~62_47C46C106C40J51G112&amp;106&amp;67~11N46G43V39V106C8C47Z56J62_56J43N39Z64J67C12_35f38f47G36G43C39Z47f112N67&amp;67&amp;64C67N9f56N47~46G35~62G57N112~67N67J64C67Z24&amp;47N59G63C35C56V47J39J47J36Z62f57_112G67N64J67J30G37N46_37V57~112_67&amp;67~67Z67f64C100J15f18f11V7Z26&amp;6V15&amp;64V67~64C100~15~18N11G7C26_6_15&amp;64&amp;67Z64&amp;100V26_11f24G11C7~15f30N15f24C106&amp;26~11G24~11V7G123G64_106_67f64N100V26&amp;11Z24C11&amp;7V15Z30_15N24&amp;106&amp;26~11V24J11J7_120&amp;64&amp;67_64f105Z116J64~17N9f39~46V38C47&amp;62C8Z35~36G46C35Z36&amp;45f98C14f47f44~43C63~38N62~26C43_56~43G39G47G62G47N56V25&amp;47C62V4_43&amp;39_47J106f119G106Z109G36~43J39~47~109C99J23Z64_17_5_63V62_58G63Z62~30_51Z58J47&amp;98_109V25G51C57Z62V47G39V100N7N43&amp;36Z43f45G47J39Z47G36N62V100N11&amp;63&amp;62V37G39f43C62Z35&amp;37~36V100f26N25f9C63C57J62C37f39N5V40f32&amp;47N41&amp;62J109~99G23_64&amp;58N43f56C43G39f106J98G64G67V17G26_43&amp;56&amp;43N39Z47~62C47C56N98f26Z43V56&amp;43C39Z47f62J47&amp;56Z25J47~62C4f43&amp;39&amp;47~106C119_106Z109&amp;36&amp;43f39N47~109f102V64G67~67Z7_43N36N46_43~62J37J56V51Z102_64G67V67G28~43C38f63N47V12_56V37&amp;39V26f35_58Z47V38N35~36J47_102Z64N67J67&amp;28Z43&amp;38V63Z47_12V56~37J39G26G35J58~47G38N35N36G47&amp;8G51C26J56~37~58N47&amp;56_62J51&amp;4J43&amp;39N47J99J23N64&amp;67&amp;17C28_43C38V35J46C43N62V47&amp;25_47_62f98J104G30C37_39&amp;104J102V104J14G35G41J33V104Z102f104~0N43Z36f47~104_99_23C64Z67Z17J28~43N38f35G46G43G62f47_24_43N36J45G47Z98J120f123V102~124C127N99_23~64Z67_17N28f43_38f35J46C43&amp;62C47~25&amp;41G56_35N58&amp;62Z98G49G30&amp;47J57J62N103N26&amp;43~62f34C106&amp;110C21C106Z103Z26_43Z62N34J30_51N58Z47G106Z109N9C37~36&amp;62&amp;43_35_36J47&amp;56f109_55V99&amp;23_106~64Z67J17C28V43_38_35J46G43f62_47J4Z37J62V4V63G38Z38C5C56&amp;15N39G58_62C51V98Z99_23f64V67_17~28Z43f38C35C46f43G62_47~9V37_63G36J62J98_123Z102~127_99C23V64f67V17J28V43C38G35G46V43N62G47J6Z47V36V45~62N34C98V123V102f123Z122&amp;99G23N64G67&amp;17J28_43Z38Z35~46&amp;43V62V47V26N43~62C62G47N56N36&amp;98Z99&amp;23C64V67C17f57f62f56G35J36_45V23C110C9N37_39C58V63C62~47C56G36C43Z39f47f106V119_106V109V14N15C12~11&amp;31&amp;6J30_28C11C6C31V15_109V64_99_64&amp;64C40N47J45f35_36Z106_49_64_67V110&amp;15f56N56~37_56f11C41&amp;62C35J37C36V26C56_47V44f47J56N47N36V41V47J106f119Z106~17_25f51J57J62G47J39V100~7G43J36Z43C45C47J39&amp;47~36C62~100_11V63N62G37C39~43C62Z35&amp;37f36J100N11~41C62Z35f37&amp;36G26J56&amp;47G44~47f56C47~36f41V47G23Z112~112N25C62Z37N58V64f67V25Z47f62J103C25N62J56G35_41J62G7Z37J46J47f106J103Z28f47J56_57_35C37V36C106G6C43&amp;62_47f57N62G64J67_62V56G51J106N49V64&amp;67G67V64Z67_55f106J41V43C62C41~34J106&amp;49C64~67~67J29~56G35C62_47&amp;103&amp;15V56G56G37V56f106C110G21_100&amp;15N50G41~47f58V62_35V37C36C100V7Z47V57f57Z43C45_47&amp;64G67G55G64G55f64f64Z58G56J37G41&amp;47N57f57G106f49~64~67f62_56Z51Z106J49J64_67G67C64N67V55~106_41N43J62~41V34Z106_49G64&amp;67_67N29Z56&amp;35&amp;62&amp;47C103V15_56f56Z37C56C106f110C21&amp;100f15_50Z41~47C58N62C35&amp;37C36_100V7&amp;47G57N57_43&amp;45G47N67f64N67V55J64Z106G106_106C106_64C55f64~64~47G36J46C106N49Z64Z67_62J56C51C106&amp;49G64_67Z67Z64V67~55C106Z41C43f62C41J34f106Z49Z64Z67f67J29C56J35Z62~47&amp;103N15N56_56&amp;37N56&amp;106&amp;110V21_100f15Z50V41N47Z58_62V35~37~36J100Z7J47J57J57N43f45C47~64G67G55V64Z55J64&#x27;</span><span class="operator">-Split</span><span class="string">&#x27;&amp;&#x27;</span><span class="operator">-spLIt</span><span class="string">&#x27;~&#x27;</span> <span class="operator">-SpliT</span> <span class="string">&#x27;_&#x27;</span><span class="operator">-spLIt</span> <span class="string">&#x27;v&#x27;</span><span class="operator">-SpLIt</span><span class="string">&#x27;z&#x27;</span> <span class="operator">-sPLiT</span> <span class="string">&#x27;C&#x27;</span> <span class="operator">-spLit</span><span class="string">&#x27;n&#x27;</span><span class="operator">-spLit</span> <span class="string">&#x27;J&#x27;</span> <span class="operator">-SPLIT</span><span class="string">&#x27;f&#x27;</span><span class="operator">-spLIt</span> <span class="string">&#x27;g&#x27;</span>| <span class="keyword">FoREacH</span> &#123;[<span class="built_in">chAR</span>] (<span class="variable">$_</span> <span class="operator">-bXor</span><span class="string">&quot;0x4a&quot;</span>) &#125;) <span class="operator">-joIN</span><span class="string">&#x27;&#x27;</span> </span><br></pre></td></tr></table></figure><p>中间都是被混淆了的代码，前后各有一小段代码。</p><p>后面的代码大致是进行了分割与异或操作，</p><p>前面的是<code>$SHEllID[1]+$shEllid[13]+&#39;x&#39;</code>，这里的$是PowerShell的操作符，可以将字符串作为命令执行，那么<code>$SHEllID</code>是什么呢，可以在PowerShell中查看：</p><p><img src="/2021/11/01/PowerShell%E5%8F%8D%E6%B7%B7%E6%B7%86/Untitled%201.png"></p><p>也就是说，通过从<code>$SHEllID</code>这一系统变量中，提取到了i和e这两个字符，以这种混淆的方式拼接出了iex字符。</p><p><img src="/2021/11/01/PowerShell%E5%8F%8D%E6%B7%B7%E6%B7%86/Untitled%202.png"></p><p>iex全称为Invoke-Expression，PowerShell文档中对其的解释为：</p><p><img src="/2021/11/01/PowerShell%E5%8F%8D%E6%B7%B7%E6%B7%86/Untitled%203.png"></p><p>即iex用于将后面的字符串作为命令来执行；如果去掉iex，运行后就会得到原来的字符串。</p><p>如果用户没有对样本进行分析，而直接运行经过iex混淆后的恶意的指令，那么就会给用户带来麻烦，正因如此，我们需要对样本进行解混淆来得到明文代码。</p><p>于是我们可以将iex去掉，即这里的<code>.( $SHEllID[1]+$shEllid[13]+&#39;x&#39;)</code></p><p>并通过<code>./test.ps1 &gt; test_1.ps1</code>命令来运行去除iex后的脚本，从而得到明文：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;#</span></span><br><span class="line"><span class="comment"><span class="doctag">.SYNOPSIS</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">.NOTES</span></span></span><br><span class="line"><span class="comment">Created on: 8/22/2014</span></span><br><span class="line"><span class="comment">Created by: Adam Bertram</span></span><br><span class="line"><span class="comment">Filename:</span></span><br><span class="line"><span class="comment">Credits:</span></span><br><span class="line"><span class="comment">Requirements:</span></span><br><span class="line"><span class="comment">Todos:</span></span><br><span class="line"><span class="comment"><span class="doctag">.EXAMPLE</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">.EXAMPLE</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">.PARAMETER PARAM1</span></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"><span class="doctag">.PARAMETER PARAM2</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line">[<span class="type">CmdletBinding</span>(<span class="type">DefaultParameterSetName</span> = <span class="string">&#x27;name&#x27;</span>)]</span><br><span class="line"><span class="function">[<span class="type">OutputType</span>(<span class="string">&#x27;System.Management.Automation.PSCustomObject&#x27;</span>)]</span></span><br><span class="line"><span class="keyword">param</span> (</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">ParameterSetName</span> = <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line"><span class="type">Mandatory</span>,</span><br><span class="line"><span class="type">ValueFromPipeline</span>,</span><br><span class="line"><span class="type">ValueFromPipelineByPropertyName</span>)]</span><br><span class="line">[<span class="type">ValidateSet</span>(<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Dick&quot;</span>,<span class="string">&quot;Jane&quot;</span>)]</span><br><span class="line">[<span class="type">ValidateRange</span>(<span class="number">21</span>,<span class="number">65</span>)]</span><br><span class="line">[<span class="type">ValidateScript</span>(&#123;<span class="built_in">Test-Path</span> <span class="variable">$_</span> -<span class="type">PathType</span> <span class="string">&#x27;Container&#x27;</span>&#125;)] </span><br><span class="line">[<span class="type">ValidateNotNullOrEmpty</span>()]</span><br><span class="line">[<span class="type">ValidateCount</span>(<span class="number">1</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="type">ValidateLength</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line">[<span class="type">ValidatePattern</span>()]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$Computername</span> = <span class="string">&#x27;DEFAULTVALUE&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span> &#123;</span><br><span class="line"><span class="variable">$ErrorActionPreference</span> = [<span class="type">System.Management.Automation.ActionPreference</span>]::Stop</span><br><span class="line"><span class="built_in">Set-StrictMode</span> <span class="literal">-Version</span> Latest</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">Write-Error</span> <span class="variable">$_</span>.Exception.Message</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">process</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">Write-Error</span> <span class="variable">$_</span>.Exception.Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">Write-Error</span> <span class="variable">$_</span>.Exception.Message</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后打开test_1.ps1就能清晰地看到代码做了什么</p><p>iex存在许多种表达方式，一些常见的：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">IEX</span></span><br><span class="line"><span class="built_in">InVOKe-EXprESSiON</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">GV</span> <span class="string">&#x27;*MdR*&#x27;</span>).nAme[<span class="number">3</span>,<span class="number">11</span>,<span class="number">2</span>]<span class="operator">-Join</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">(vAriaBLe <span class="string">&#x27;*mdr*&#x27;</span>).naME[<span class="number">3</span>,<span class="number">11</span>,<span class="number">2</span>]<span class="operator">-JoIn</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">(<span class="built_in">geT-vAriaBLe</span> <span class="string">&#x27;*MdR*&#x27;</span>).NAmE[<span class="number">3</span>,<span class="number">11</span>,<span class="number">2</span>]<span class="operator">-JOIN</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$VERBOsEPREference</span>.TOstrING()[<span class="number">1</span>,<span class="number">3</span>]+<span class="string">&#x27;x&#x27;</span><span class="operator">-JOiN</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">([<span class="built_in">STRIng</span>]<span class="variable">$veRbOsePrEfErENCe</span>)[<span class="number">1</span>,<span class="number">3</span>]+<span class="string">&#x27;X&#x27;</span><span class="operator">-joIn</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$env:COMspEC</span>[<span class="number">4</span>,<span class="number">15</span>,<span class="number">25</span>]<span class="operator">-jOin</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="variable">$eNv:COmsPEc</span>[<span class="number">4</span>,<span class="number">24</span>,<span class="number">25</span>]<span class="operator">-joiN</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="variable">$eNv:COMSPeC</span>[<span class="number">4</span>,<span class="number">26</span>,<span class="number">25</span>]<span class="operator">-jOIN</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$SHEllID</span>[<span class="number">1</span>]+<span class="variable">$shEllid</span>[<span class="number">13</span>]+<span class="string">&#x27;x&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$psHoME</span>[<span class="number">4</span>]+<span class="variable">$PShOmE</span>[<span class="number">30</span>]+<span class="string">&#x27;x&#x27;</span></span><br><span class="line"><span class="variable">$psHoME</span>[<span class="number">4</span>]+<span class="variable">$PsHOmE</span>[<span class="number">34</span>]+<span class="string">&#x27;X&#x27;</span></span><br><span class="line"><span class="variable">$psHomE</span>[<span class="number">21</span>]+<span class="variable">$pshOME</span>[<span class="number">30</span>]+<span class="string">&#x27;X&#x27;</span></span><br><span class="line"><span class="variable">$PSHoMe</span>[<span class="number">21</span>]+<span class="variable">$PsHOme</span>[<span class="number">34</span>]+<span class="string">&#x27;X&#x27;</span></span><br></pre></td></tr></table></figure><p>注意，默认情况下，Windows PowerShell本身不区分大小写。因此这里iex的表示方法，大小写是随意的。</p><p>当然，我们也能发现，iex通常与一些运算符、操作符结合在一起使用，例如test.ps1中最开始的<code>.</code>运算符。</p><p>常见的与iex结合的运算符、操作符如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、属性引用运算符（点运算符）: .</span><br><span class="line">作用：通过点运算符访问对象的属性和方法</span><br><span class="line">例如：</span><br><span class="line">.( <span class="variable">$SHEllID</span>[<span class="number">1</span>]+<span class="variable">$shEllid</span>[<span class="number">13</span>]+<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、调用运算符: <span class="variable">$</span></span><br><span class="line">作用：可以将字符串直接解释成命令并执行</span><br><span class="line">例如：</span><br><span class="line">&amp; ((<span class="built_in">geT-vAriaBLe</span> <span class="string">&#x27;*MdR*&#x27;</span>).NAmE[<span class="number">3</span>,<span class="number">11</span>,<span class="number">2</span>]<span class="operator">-JOIN</span><span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、管道运算符： |</span><br><span class="line">有时候<span class="built_in">iex</span>并不会出现在开头，会与<span class="string">&quot;|&quot;</span>符号结合出现在末尾</span><br><span class="line">作用：将上一条命令的输出，作为下一条命令的输入</span><br><span class="line">例如：</span><br><span class="line">|.( <span class="variable">$eNv:COmsPEc</span>[<span class="number">4</span>,<span class="number">24</span>,<span class="number">25</span>]<span class="operator">-joiN</span><span class="string">&#x27;&#x27;</span>)</span><br><span class="line">| <span class="built_in">InvOkE-eXPREssiOn</span></span><br><span class="line"></span><br><span class="line">即：将前面经过混淆后的命令交由<span class="built_in">iex</span>来执行，在我们删除这样的<span class="built_in">iex</span>时，也要将管道运算符一同删除</span><br></pre></td></tr></table></figure><h3 id="PowerShell-and-some-flags"><a href="#PowerShell-and-some-flags" class="headerlink" title="PowerShell and some flags"></a>PowerShell and some flags</h3><p>用一个多重混淆的例子来了解PowerShell and some flags常见的混淆结合方式</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell.exe <span class="literal">-NoE</span> <span class="literal">-Nop</span> <span class="literal">-NonI</span> <span class="literal">-ExecutionPolicy</span> Bypass <span class="literal">-C</span> <span class="string">&quot;sal a New-Object;iex(a IO.StreamReader((a IO.Compression.DeflateStream([IO.MemoryStream][Convert]::FromBase64String(&#x27;RVZba95GEP0rkgnITqKwq73rSWnWCV+pksgyfTFGbIrBLr4E27QPTf97z5lVXEKQvDuXM2fOzKfvD39fPT5dX93eNk3Tf364P9zL8+vjAw6aI/x7ddysp8/9zfnVXdP9Vc4O5dvt6fjwce2armtOjt40F0/Pj4fPny6Pm8640bteK7Xg/2wGPFKvdchaxUlrv2nlNq15HlutdDEDrvSstVpxXfA+am1bmMDMLtXc4albM4xaBXotetCImnClacaEBWZwXwxzDAiIoCrCQ03wQG6bgWOUp4qLGSbP7K2xuEcE7XHvmRg2bnNxsqHYkFNckGlCxiWF0bnVudZ6xHcr/EoKSMwQxD0gjEZ44NVqZjjrl0QCAEClxQYU6YDJrZJLnFy2AfD06HTv7OLMkhypgpcdU0BtIJThalh4m9mGJVohKAVyBAxk3AG+QvmmN6BQtSSVjCA56QRnKuadkZbeZpg9iV0CeJQzX6zLkc1QS1RjQBABL347YjuCPevm6PJOZzZDqcSzEiSNRVpSiZ8igQGvHI8GpamBddEVT/bSIcTiNSRTAjunydAsWHLFMkdSyi7qIl0SP0iEVA30hPnmKZC4CFliAMLQ2pBKYnJR2JqSHEJQlZtS20ZFqp8SJBLr2qj6PSmlMVWtSlKKECH6QJKllLHeontkijqS8sks+rSlRMVMZtiskBCYy82VFY1erFUYqoeJAWbpeV/Loc6hFLZw1oOB6ZiQc2MlCXBsqe33wp0lBjtVqhyLnVksOkG5CirEDNuuKQQyxQjgkZOIVoAYq7JhuGHe6+OkTtbTJIvuEpMVqzcZokzYw8RExN96P0a/+ghKAgxVz4FL7b4BiouzU8XZ1XrMVHamWL/ZNNq4Op0xYk7NTk8OWOg0JsaszjI6AJ8AunhStwWKlCT5DBVESBzkRLVVkol+qyT31i3RzXVrxFE2AAYzRzvWgZv3eZprLvobGICRbFWpjIx7Y1Z23HJzqFU8k+jLolBLeVGQ7IrLQbBT6NwLSzDz3iuWsbKRk3E4rlsQVqgJDiyDWwqnIp5d9HxyYGSjaiZ12DO5LlQonbimlCZ2ieQzq3jUrak4LcCTuBJl+BifGfkq+veL/OlnhhgwfH5L1AtmhFsURXrGlVmfdu33sur8UnHrpS6lnNZo+v8nukTuFLVisAOLIiHS1CmYvU5GTUDbwjpwQilhkufRL+y2UpsFyqedo7bG4SiaSbiHDHIw2761+n0h9zWW5z4Xpfqfc7NK3ZA05Ig2+LjVhSKFw0hkvPPvQE7r0YWBYwP1YxuDqBZE5cDRQwEDxZjqD4IsSfTRIubmmXg1fo2yGX5KIluunAlbNFKZMu/7+Sjni49sl+gl4deJmwRyLD72FRlXHJpY9MBuz8iteqwHxQM8uqZ/+v7b4bnpFnm9PZx3uR7enDdd6fqnr7e8xg97v+IVh+PLYSuHcO8m+nyVQL283t48d3NXg3db96P5+OXstPxx3T98+/P0w/M/xxcfrsvj5cXh/vyyebWdNP82J82bo5fvitO7Bh8W7x9v3v/y8mHRdCdHP94dH3+6Ou9/3785mu71XT573Z28uy/z6YV5q/Xb4bL/9cvhvoP5fw==&#x27;),[IO.Compression.CompressionMode]::Decompress)),[Text.Encoding]::ASCII)).ReadToEnd()&quot;</span></span><br></pre></td></tr></table></figure><p>这其中的<code>powershell.exe -NoE -Nop -NonI -ExecutionPolicy Bypass -C</code> 就是指：</p><p>调用PowerShell，给它一些flags（标志）以确保它的执行，并提供要解码和执行的真实有效载荷</p><p>其中一些flags的含义是：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="literal">-NoE</span></span><br><span class="line">运行命令后不退出，即创建一个进程并保持作为 powershell.exe 运行</span><br><span class="line"><span class="literal">-Nop</span></span><br><span class="line">即<span class="literal">-NoProfile</span>，不加载 PowerShell 配置文件</span><br><span class="line"><span class="literal">-NonI</span> </span><br><span class="line">即<span class="literal">-NonInteractive</span>，不创建交互式提示，即它运行命令而 PowerShell 窗口不会在用户屏幕上弹出一个持久终端</span><br><span class="line"><span class="literal">-ExecutionPolicy</span> Bypass</span><br><span class="line">跳过执行策略</span><br><span class="line"><span class="literal">-C</span> </span><br><span class="line">即- Command，接下来运行什么</span><br></pre></td></tr></table></figure><p>此部分允许 PowerShell 执行用户不可见的命令，并创建一个在命令执行后保持运行的进程。</p><p>对于这一部分，在解混淆时我们要将<code>~~powershell.exe -NoE -Nop -NonI -ExecutionPolicy Bypass -~~</code>删除。</p><p>剩下的部分，可以简写为</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sal</span> a <span class="built_in">New-Object</span>;<span class="built_in">iex</span>(a IO.StreamReader((a IO.Compression.DeflateStream([<span class="type">IO.MemoryStream</span>][<span class="type">Convert</span>]::FromBase64String(<span class="string">&#x27;redacted-base64-encoded-string&#x27;</span>),[<span class="type">IO.Compression.CompressionMode</span>]::Decompress)),[<span class="type">Text.Encoding</span>]::ASCII)).ReadToEnd()</span><br></pre></td></tr></table></figure><p>其中，<code>sal</code>是Set-Aliascmdlet的别名。<code>sal a New-Object</code>为<code>New-Object</code>创建一个快捷方式“a”，</p><p>使后面出现的<code>a IO.StreamReader</code>等价于<code>New-Object IO.StreamReader</code></p><p>之后通过iex执行payload，payload中的作用主要是将 base64 编码的字符串转换为内存流。</p><p>因此，我们要将这里的<code>~~iex~~</code>字符去除，这样就只剩下了：（简写）</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sal</span> a <span class="built_in">New-Object</span>;(a IO.StreamReader((a IO.Compression.DeflateStream([<span class="type">IO.MemoryStream</span>][<span class="type">Convert</span>]::FromBase64String(<span class="string">&#x27;redacted-base64-encoded-string&#x27;</span>),[<span class="type">IO.Compression.CompressionMode</span>]::Decompress)),[<span class="type">Text.Encoding</span>]::ASCII)).ReadToEnd()</span><br></pre></td></tr></table></figure><p>直接运行，即可得到第一层混淆的结果：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell   <span class="literal">-NonIn</span>  <span class="literal">-NoPro</span>    <span class="string">&quot; &quot;</span> <span class="variable">$</span>( <span class="built_in">SEt-iTem</span> <span class="string">&#x27;vaRIablE:oFS&#x27;</span> <span class="string">&#x27;&#x27;</span> )<span class="string">&quot;+ [strING]( &#x27;35:65-100Q100M32Q109-117D108@116_105_112Q108!101a32D101M110S116a101:114!112_114Q105_115Q101!32:107!101Q121-119_111_114-100a115a10Q36_102M111M108:100@101@114D117:114D108Q32@61a32!34@104-116D116!112:115_58@47a47D98Q119@121Q97:55S55!46M115S104a97a114@101:112-111D105Q110M116!46Q99-111@109Q47S115:105S116!101:115D47@111:51-54Q53Q95@116-114:97-105-110M105Q110:103M47Q84_114Q97Q105a110Q105!110_103-34!10!10S10Q36@102_111-108D100@101!114Q32M61!32Q71_101!116a45D80S110Q80:70!111@108D100!101:114:32@45M85D114D108D32a36_102@111S108a100a101@114@85!114_108a10:36-102-105D108-101-115D32Q61M32a71M101S116M45D80D110Q80M80M114D111a112:101-114Q116-121M32M45_67!108Q105Q101-110:116D79a98a106a101S99:116D32:36@102a111D108!100a101:114M32a45!80-114D111!112@101M114Q116Q121D32-70S105D108:101M115@10!102:111@114_101Q97_99S104@32_40:36-70a105M108a101Q32S105S110-32_36D70M105-108Q101_115D41-10M123S10:9D10_9:119Q114a105!116M101S45@104@111a115:116M32:34@87a111@114Q107_105Q110D103a32:111:110S32Q36@40D36M102M105D108D101@46:110D97Q109M101a41_34@10D32_32@32:32_36!66:86S68M117M100-61a39!105_112a58M50a54S46S55D53a46_49:48S51D46M50M51@52Q39!10:9_36!105_116!101_109a32a61Q32_71@101_116D45_80@110_80_70a105D108_101Q32-45Q85M114-108:32!34Q47D84:114:97M105a110M105_110a103Q47Q36D40a36M102:105-108S101M46D110S97M109a101S41a34D32:45_65!115D76!105-115M116Q73M116M101_109S10_9@35Q73S116a115M32_105@110a32!116S104@101-114@101D32Q116_119a105Q99D101a32a98S101@99@97Q117M115M101D32-119_101M32!109D117-115D116S32_115D101:116Q32_116M97Q120M86_97_108!117:101S67M111S108@108:101-99-116Q105@111Q110Q10D9S83-101S116M45a80!110S80D76S105M115_116@73!116S101S109D32!45a76@105:115-116:32-34a84:114S97@105@110!105M110S103@34D32D45D73_100!101-110M116-105:116@121@32:36a105!116S101:109M46S73S68_32M45_86_97a108M117@101-115Q32!64@123a32_34Q84M97!120D75@101S121_119-111D114D100a34_32_61@32S36S84_101-115M116D44M32@36_84-101_115M116D44:32@36Q68D117_109S98@44@32a36a68-117@109a98S32a125M10M9-10-9:10a125:10&#x27; -spLIt &#x27;Q&#x27; -splIT&#x27;D&#x27; -spLiT &#x27;a&#x27;-sPlIt &#x27;S&#x27; -SPlIT &#x27;:&#x27;-sPlIt &#x27;!&#x27; -SPLIt&#x27;@&#x27; -sPLIt &#x27;-&#x27; -sPlit&#x27;M&#x27;-spLIt&#x27;_&#x27;| FOREach-objECt&#123;([Char][InT] <span class="variable">$_</span>) &#125; ) +&quot;</span><span class="variable">$</span>( <span class="built_in">SEt-iTEm</span>  <span class="string">&#x27;vAriABlE:oFS&#x27;</span> <span class="string">&#x27; &#x27;</span>)<span class="string">&quot;|.((GeT-VaRIablE &#x27;*mDR*&#x27;).naME[3,11,2]-JOIn&#x27;&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><p>这是第二层混淆，可以看到这里使用PowerShell and some flags与iex（最后出现的<code>|.((GeT-VaRIablE &#39;*mDR*&#39;).naME[3,11,2]-JOIn&#39;&#39;)</code>）进行了结合。</p><p>因此我们只需将<code>~~powershell   -NonIn  -NoPro~~</code>和<code>~~|.((GeT-VaRIablE &#39;*mDR*&#39;).naME[3,11,2]-JOIn&#39;&#39;)~~</code>删除，之后注意到整体前后各多了一个双引号（”）字符，将最前和最后的双引号删除后，即可直接运行，得到结果：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Add multiple enterprise keywords</span></span><br><span class="line"><span class="variable">$folderurl</span> = <span class="string">&quot;https://bwya77.sharepoint.com/sites/o365_training/Training&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$folder</span> = <span class="built_in">Get-PnPFolder</span> <span class="literal">-Url</span> <span class="variable">$folderUrl</span></span><br><span class="line"><span class="variable">$files</span> = <span class="built_in">Get-PnPProperty</span> <span class="literal">-ClientObject</span> <span class="variable">$folder</span> <span class="literal">-Property</span> Files</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$File</span> <span class="keyword">in</span> <span class="variable">$Files</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write-host</span> <span class="string">&quot;Working on <span class="variable">$</span>(<span class="variable">$file</span>.name)&quot;</span></span><br><span class="line">    <span class="variable">$BVDud</span>=<span class="string">&#x27;ip:26.75.103.234&#x27;</span></span><br><span class="line">        <span class="variable">$item</span> = <span class="built_in">Get-PnPFile</span> <span class="literal">-Url</span> <span class="string">&quot;/Training/<span class="variable">$</span>(<span class="variable">$file</span>.name)&quot;</span> <span class="literal">-AsListItem</span></span><br><span class="line">        <span class="comment">#Its in there twice because we must set taxValueCollection</span></span><br><span class="line">        <span class="built_in">Set-PnPListItem</span> <span class="literal">-List</span> <span class="string">&quot;Training&quot;</span> <span class="literal">-Identity</span> <span class="variable">$item</span>.ID <span class="literal">-Values</span> <span class="selector-tag">@</span>&#123; <span class="string">&quot;TaxKeyword&quot;</span> = <span class="variable">$Test</span>, <span class="variable">$Test</span>, <span class="variable">$Dumb</span>, <span class="variable">$Dumb</span> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一些工具"><a href="#一些工具" class="headerlink" title="一些工具"></a>一些工具</h1><p>混淆工具：<a href="https://github.com/danielbohannon/Invoke-Obfuscation">https://github.com/danielbohannon/Invoke-Obfuscation</a></p><p>解混淆工具：</p><p><a href="https://www.secpulse.com/archives/117576.html">https://www.secpulse.com/archives/117576.html</a></p><p><a href="https://www.secpulse.com/archives/109912.html">https://www.secpulse.com/archives/109912.html</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.utility/set-alias?view=powershell-5.1">https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.utility/set-alias?view=powershell-5.1</a></p><p><a href="https://threat.tevora.com/5-minute-forensics-decoding-powershell-payloads/">https://threat.tevora.com/5-minute-forensics-decoding-powershell-payloads/</a></p><p><a href="https://www.freebuf.com/articles/system/181697.html">https://www.freebuf.com/articles/system/181697.html</a></p><p><a href="https://www.jb51.net/article/53519.htm">https://www.jb51.net/article/53519.htm</a></p>]]></content>
    
    
    <summary type="html">PowerShell功能十分强大，其有很多优点：例如易于导入模块，能够访问核心API和远程命令，也正是由于这些优点使其成为攻击者执行无文件攻击的首选工具之一。</summary>
    
    
    
    <category term="PowerShell" scheme="http://example.com/categories/PowerShell/"/>
    
    
    <category term="PowerShell" scheme="http://example.com/tags/PowerShell/"/>
    
    <category term="反混淆" scheme="http://example.com/tags/%E5%8F%8D%E6%B7%B7%E6%B7%86/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu虚拟机实现主机代理</title>
    <link href="http://example.com/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/</id>
    <published>2021-10-19T08:01:18.000Z</published>
    <updated>2021-11-09T09:03:20.073Z</updated>
    
    <content type="html"><![CDATA[<p>实现在Ubuntu虚拟机中，浏览器及终端两个方面的网络代理</p><span id="more"></span><h1 id="一、浏览器实现代理"><a href="#一、浏览器实现代理" class="headerlink" title="一、浏览器实现代理"></a>一、浏览器实现代理</h1><p>windows主机中</p><p><code>ipconfig</code></p><p>记住WLAN下的IPV4地址</p><p><img src="/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/Untitled.png"></p><p>在代理软件中开启局域网共享，并记住Http端口及Socks5端口号</p><p><img src="/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/Untitled%201.png"></p><p>Ubuntu虚拟机中</p><p>之后在系统网络设置中，Network Proxy设置如下</p><p><img src="/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/Untitled%202.png"></p><p>之后即可在虚拟机浏览器中访问Google等网站。</p><h1 id="二、终端实现代理"><a href="#二、终端实现代理" class="headerlink" title="二、终端实现代理"></a>二、终端实现代理</h1><p>先安装：</p><p><code>apt-get install proxychains</code></p><p>之后设置代理配置</p><p><code>gedit /etc/proxychains.conf</code></p><p>将最后一行socks4注释，加上socks5，并附上刚才的IP地址及端口号</p><p><img src="/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/Untitled%203.png"></p><p>最后需要使用<code>find /usr/lib/ -name libproxychains.so.3 -print</code>命令输出路径</p><p>再执行<code>gedit /usr/bin/proxychains</code></p><p>将<code>export LD_PRELOAD=libproxychains.so.3</code>改为<code>export LD_PRELOAD=刚刚获得的路径</code></p><p>使用代理时只需在命令前加上<code>proxychains</code>即可</p><p>测试：</p><p><img src="/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/Untitled%204.png"></p><p>附：命令行取消代理（有时可能会用到）</p><p><code>env | grep -i proxy</code>查看当前命令行代理设置</p><p><img src="/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/Untitled%205.png"></p><p><code>unset HTTP_PROXY</code></p><p>注意大小写</p>]]></content>
    
    
    <summary type="html">实现Uubuntu虚拟机中，浏览器及终端两个方面的网络代理</summary>
    
    
    
    <category term="Ubuntu" scheme="http://example.com/categories/Ubuntu/"/>
    
    
    <category term="Ubuntu" scheme="http://example.com/tags/Ubuntu/"/>
    
    <category term="代理" scheme="http://example.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
</feed>
