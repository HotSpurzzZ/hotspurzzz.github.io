<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HotSpurzzZ</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-22T01:24:44.066Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>HotSpurzzZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LibFuzzer 基础使用</title>
    <link href="http://example.com/2022/09/10/LibFuzzer%20%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/09/10/LibFuzzer%20%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-09-10T02:00:00.000Z</published>
    <updated>2022-09-22T01:24:44.066Z</updated>
    
    <content type="html"><![CDATA[<p>~~</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>LibFuzzer是单进程<code>in-process</code>，覆盖引导<code>coverage-based</code>，进化<code>evolutionary</code>的模糊测试引擎。</p><p>LibFuzzer 与被测目标库链接，并通过特定的模糊入口点（又称“目标函数”）将模糊输入提供给目标库。然后，模糊器跟踪到达了代码的哪些区域，并在输入数据的语料库上生成突变，以最大化代码覆盖率。</p><p>LibFuzzer的代码覆盖率由LLVM的<a href="https://clang.llvm.org/docs/SanitizerCoverage.html">SanitizerCoverage</a> 工具提供。</p><h1 id="Fuzz-Target-模糊目标"><a href="#Fuzz-Target-模糊目标" class="headerlink" title="Fuzz Target 模糊目标"></a>Fuzz Target 模糊目标</h1><p>在库上使用 libFuzzer 的第一步是实现一个Fuzz Target：一个接受字节数组并使用被测 API 对这些字节做一些有趣的事情的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fuzz_target.cc</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *Data, <span class="keyword">size_t</span> Size)</span> </span>&#123;</span><br><span class="line">  DoSomethingInterestingWithMyAPI(Data, Size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// Values other than 0 and -1 are reserved for future use.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，Fuzz Target不以任何方式依赖于libFuzzer，因此也可以与其他Fuzzing engines（如AFL）一起使用</p><p>关于Fuzz Target的一些重要事项：</p><ol><li>Fuzzing engines 会在相同程序上使用不同的输入多次执行Fuzz Target</li><li>必须能接受任何类型的输入（空的、巨大的、格式错误的等）</li><li>在任何输入上都不能exit</li><li>可以使用线程，但理想情况下，所有线程都应该在函数结束时加入</li><li>必须尽可能具有确定性</li><li>必须很快</li><li>通常，目标范围越小越好</li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>Clang从6.0开始包括LibFuzzer，无需额外安装</p><p>构建fuzzer binary，在编译和链接期间使用-fsanitize=fuzzer标志，也可以与sanitizer结合使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -g -O1 -fsanitize=fuzzer                         mytarget.c <span class="comment"># Builds the fuzz target w/o sanitizers</span></span><br><span class="line">clang -g -O1 -fsanitize=fuzzer,address                 mytarget.c <span class="comment"># Builds the fuzz target with ASAN</span></span><br><span class="line">clang -g -O1 -fsanitize=fuzzer,signed-integer-overflow mytarget.c <span class="comment"># Builds the fuzz target with a part of UBSAN</span></span><br><span class="line">clang -g -O1 -fsanitize=fuzzer,memory                  mytarget.c <span class="comment"># Builds the fuzz target with MSAN</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fuzz_me.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FuzzMe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *Data, <span class="keyword">size_t</span> DataSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> DataSize &gt;= <span class="number">3</span> &amp;&amp;</span><br><span class="line">      Data[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp;</span><br><span class="line">      Data[<span class="number">1</span>] == <span class="string">&#x27;U&#x27;</span> &amp;&amp;</span><br><span class="line">      Data[<span class="number">2</span>] == <span class="string">&#x27;Z&#x27;</span> &amp;&amp;</span><br><span class="line">      Data[<span class="number">3</span>] == <span class="string">&#x27;Z&#x27;</span>;  <span class="comment">// :‑&lt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *Data, <span class="keyword">size_t</span> Size)</span> </span>&#123;</span><br><span class="line">  FuzzMe(Data, Size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用libfuzzer和asan编译、运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ clang++-11 -g -fsanitize=address,fuzzer -O0 fuzz_me.cc</span><br><span class="line">$ ./a.out</span><br><span class="line">INFO: Seed: 4103274391</span><br><span class="line">INFO: Loaded 1 modules   (7 inline 8-bit counters): 7 [0x5a8ed0, 0x5a8ed7), </span><br><span class="line">INFO: Loaded 1 PC tables (7 PCs): 7 [0x56c840,0x56c8b0), </span><br><span class="line">INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes</span><br><span class="line">INFO: A corpus is not provided, starting from an empty corpus</span><br><span class="line"><span class="comment">#2INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 30Mb</span></span><br><span class="line"><span class="comment">#5NEW    cov: 4 ft: 4 corp: 2/4b lim: 4 exec/s: 0 rss: 31Mb L: 3/3 MS: 3 CopyPart-InsertByte-InsertByte-</span></span><br><span class="line"><span class="comment">#904NEW    cov: 5 ft: 5 corp: 3/7b lim: 11 exec/s: 0 rss: 31Mb L: 3/3 MS: 4 ChangeByte-ShuffleBytes-ShuffleBytes-CMP- DE: &quot;F\x00&quot;-</span></span><br><span class="line"><span class="comment">#7046NEW    cov: 6 ft: 6 corp: 4/10b lim: 68 exec/s: 0 rss: 31Mb L: 3/3 MS: 2 ChangeBit-ChangeByte-</span></span><br><span class="line">=================================================================</span><br><span class="line">==133103==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200002bf33 at pc 0x000000551af3 bp 0x7ffc8ed21370 sp 0x7ffc8ed21368</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">artifact_prefix=<span class="string">&#x27;./&#x27;</span>; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这代表构建了一个fuzzer并发现了一个错误，其中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO: Seed: 4103274391</span><br></pre></td></tr></table></figure><p>指fuzzer从这个随机种子开始</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes</span><br><span class="line">INFO: A corpus is not provided, starting from an empty corpus</span><br></pre></td></tr></table></figure><p>默认情况下，libFuzzer假设所有输入都是4096字节或更小，使用参数<code>-max_len=N</code>更改，或使用非空语料库运行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 30Mb</span></span><br><span class="line"><span class="comment">#5NEW    cov: 4 ft: 4 corp: 2/4b lim: 4 exec/s: 0 rss: 31Mb L: 3/3 MS: 3 CopyPart-InsertByte-InsertByte-</span></span><br><span class="line"><span class="comment">#904NEW    cov: 5 ft: 5 corp: 3/7b lim: 11 exec/s: 0 rss: 31Mb L: 3/3 MS: 4 ChangeByte-ShuffleBytes-ShuffleBytes-CMP- DE: &quot;F\x00&quot;-</span></span><br><span class="line"><span class="comment">#7046NEW    cov: 6 ft: 6 corp: 4/10b lim: 68 exec/s: 0 rss: 31Mb L: 3/3 MS: 2 ChangeBit-ChangeByte-</span></span><br></pre></td></tr></table></figure><p>libFuzzer至少尝试了7046个输入，并发现了4个输入，总共10个字节（<code>corp: 4/10b</code>） 一共覆盖了6个覆盖点（可以视为基本块）（<code>cov: 6</code>）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==133103==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200002bf33 at pc 0x000000551af3 bp 0x7ffc8ed21370 sp 0x7ffc8ed21368</span><br></pre></td></tr></table></figure><p>在其中一个输入上，AddressSanitizer 检测到<code>heap-buffer-overflow</code>错误并中止了执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">artifact_prefix=<span class="string">&#x27;./&#x27;</span>; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60</span><br></pre></td></tr></table></figure><p>在退出进程之前，libFuzzer 在磁盘上创建了一个文件，其中包含触发崩溃的字节。可以对其进行崩溃重现</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./a.out crash-0eb8e4ed029b774d80f2b66408203801cb982a60</span><br></pre></td></tr></table></figure><h1 id="Heartbleed-心脏滴血"><a href="#Heartbleed-心脏滴血" class="headerlink" title="Heartbleed 心脏滴血"></a>H<strong><strong>eartbleed 心脏滴血</strong></strong></h1><p><a href="https://en.wikipedia.org/wiki/Heartbleed">Heartbleed</a>（又名 CVE-2014-0160）是<a href="http://www.openssl.org/">OpenSSL 加密库</a>中的一个严重安全漏洞，后来发现，通过模糊测试可以很容易地发现这个错误</p><p>使用<a href="https://github.com/google/fuzzer-test-suite%E6%8F%90%E4%BE%9B%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%8C%85%E5%90%AB%E4%BA%86%E7%8E%B0%E6%88%90%E7%9A%84%E8%84%9A%E6%9C%AC%E6%9D%A5%E4%B8%BA%E5%90%84%E7%A7%8D%E7%9B%AE%E6%A0%87%E6%9E%84%E5%BB%BAFuzzer%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%AD%98%E5%9C%A8%E2%80%9Cheartbleed%E2%80%9D%E9%94%99%E8%AF%AF%E7%9A%84openssl-1.0.1f">https://github.com/google/fuzzer-test-suite提供的例子，包含了现成的脚本来为各种目标构建Fuzzer，包括存在“heartbleed”错误的openssl-1.0.1f</a></p><p>下面为openssl-1.0.1f 构建Fuzzer：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/google/fuzzer-test-suite.git</span><br><span class="line">$ <span class="built_in">cd</span> fuzzer-test-suite</span><br><span class="line">$ mkdir ./heartbleed</span><br><span class="line">$ <span class="built_in">cd</span> ./heartbleed</span><br><span class="line">$ ../openssl-1.0.1f/build.sh</span><br></pre></td></tr></table></figure><p>这将下载受影响的openssl源码，并为存在错误的特定API构建Fuzzer，参阅<a href="https://github.com/google/fuzzer-test-suite/blob/master/openssl-1.0.1f/target.cc">openssl-1.0.1f/target.cc</a></p><p>运行Fuzzer：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./openssl-1.0.1f-fsanitize_fuzzer</span><br></pre></td></tr></table></figure><p>几秒钟后可以看到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#163297REDUCE cov: 651 ft: 1053 corp: 76/4013b lim: 1021 exec/s: 40824 rss: 397Mb L: 15/381 MS: 1 PersAutoDict- DE: &quot;\x01\x00\x00\x00\x00\x00\x00\x00&quot;-</span></span><br><span class="line"><span class="comment">#163917REDUCE cov: 651 ft: 1053 corp: 76/4011b lim: 1021 exec/s: 40979 rss: 397Mb L: 27/381 MS: 1 EraseBytes-</span></span><br><span class="line"><span class="comment">#165332REDUCE cov: 651 ft: 1053 corp: 76/4009b lim: 1030 exec/s: 41333 rss: 397Mb L: 13/381 MS: 4 ShuffleBytes-InsertByte-ChangeByte-EraseBytes-</span></span><br><span class="line"><span class="comment">#167837REDUCE cov: 651 ft: 1053 corp: 76/4008b lim: 1050 exec/s: 41959 rss: 397Mb L: 14/381 MS: 4 CopyPart-ChangeByte-ChangeByte-EraseBytes-</span></span><br><span class="line"><span class="comment">#168004REDUCE cov: 651 ft: 1053 corp: 76/4005b lim: 1050 exec/s: 42001 rss: 397Mb L: 11/381 MS: 1 EraseBytes-</span></span><br><span class="line">=================================================================</span><br><span class="line">==153177==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x629000009748 at pc 0x00000051f8d7 bp 0x7ffed58fa250 sp 0x7ffed58f9a18</span><br><span class="line">READ of size 65292 at 0x629000009748 thread T0</span><br><span class="line">    <span class="comment">#0 0x51f8d6 in __asan_memcpy (/root/Desktop/fuzzer-test-suite/heartbleed/openssl-1.0.1f-fsanitize_fuzzer+0x51f8d6)</span></span><br><span class="line">    <span class="comment">#1 0x55e863 in tls1_process_heartbeat /root/Desktop/fuzzer-test-suite/heartbleed/BUILD/ssl/t1_lib.c:2586:3</span></span><br><span class="line">    <span class="comment">#2 0x5c9c9a in ssl3_read_bytes /root/Desktop/fuzzer-test-suite/heartbleed/BUILD/ssl/s3_pkt.c:1092:4</span></span><br><span class="line">    <span class="comment">#3 0x5ce0a3 in ssl3_get_message /root/Desktop/fuzzer-test-suite/heartbleed/BUILD/ssl/s3_both.c:457:7</span></span><br></pre></td></tr></table></figure><h1 id="corpus语料库"><a href="#corpus语料库" class="headerlink" title="corpus语料库"></a>corpus语料库</h1><p>libFuzzer 这样的覆盖引导模糊器依赖于被测代码的样本输入语料库。理想情况，语料库会为被测目标提供各种有效及无效输入。之后Fuzzer会根据当前语料库中的样本生成随机突变。</p><p>当然libFuzzer 可以在没有任何初始种子的情况下工作，但可能效率会降低</p><p>尝试另一个目标：<a href="https://github.com/google/fuzzer-test-suite/tree/master/woff2-2016-05-06">Woff2</a></p><p>构建：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir woff</span><br><span class="line">$ <span class="built_in">cd</span> woff</span><br><span class="line">$ ../woff2-2016-05-06/build.sh</span><br></pre></td></tr></table></figure><p>运行Fuzzer：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./woff2-2016-05-06-fsanitize_fuzzer</span><br></pre></td></tr></table></figure><p>可能会看到 fuzzer 卡住了——它正在运行数百万个输入，但找不到许多新的代码路径</p><p>在这种情况下，需要去找到一些触发足够代码路径的输入——越多越好。woff2 fuzz 目标使用.woff2格式的网络字体，因此可以去找任何此类文件。刚刚执行的构建脚本已经下载了一个包含一些.woff2 文件的项目并将其放入目录./seeds/中。</p><p>我们需要将woff2 fuzzer与种子语料库一起使用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir my_corpus</span><br><span class="line">./woff2-2016-05-06-fsanitize_fuzzer my_corpus/ seeds/</span><br></pre></td></tr></table></figure><p>当基于 libFuzzer 的 fuzzer 使用一个目录作为参数执行时，它将首先递归地从每个目录中读取文件并在所有目录上执行目标函数。然后，任何触发有新代码路径的输入都将被写回第一个语料库目录（在本例中为<code>MY_CORPUS</code>）</p><p>可以看到，cov覆盖数量大幅提高（相比之前的600多），并且在不断增长</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./woff2-2016-05-06-fsanitize_fuzzer my_corpus  seeds/               </span><br><span class="line">INFO: Seed: 2513206469</span><br><span class="line">INFO: Loaded 1 modules   (11107 inline 8-bit counters): 11107 [0x799050, 0x79bbb3), </span><br><span class="line">INFO: Loaded 1 PC tables (11107 PCs): 11107 [0x723120,0x74e750), </span><br><span class="line">INFO:        0 files found <span class="keyword">in</span> my_corpus</span><br><span class="line">INFO:      677 files found <span class="keyword">in</span> seeds/</span><br><span class="line">INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 168276 bytes</span><br><span class="line">INFO: seed corpus: files: 677 min: 1b max: 168276b total: 43813862b rss: 32Mb</span><br><span class="line"><span class="comment">#678INITED cov: 991 ft: 3436 corp: 448/27Mb exec/s: 678 rss: 377Mb</span></span><br><span class="line"><span class="comment">#1024pulse  cov: 991 ft: 3436 corp: 448/27Mb lim: 68784 exec/s: 512 rss: 391Mb</span></span><br><span class="line"><span class="comment">#1364NEW    cov: 991 ft: 3438 corp: 449/27Mb lim: 68784 exec/s: 682 rss: 391Mb L: 67832/68784 MS: 1 ChangeByte-</span></span><br></pre></td></tr></table></figure><p>libFuzzer 尝试的输入大小现在受到 168276 的限制，这是种子语料库中最大文件的大小。可以用<code>-max_len=N</code> 进行改变</p><p>可以随时中断 fuzzer 并使用相同的命令行重新启动它。它将从它停止的地方开始</p><h1 id="并行运行"><a href="#并行运行" class="headerlink" title="并行运行"></a>并行运行</h1><p>另一种提高模糊测试效率的方法是使用更多的 CPU。如果你用它运行模糊器，<code>-jobs=N</code>它将产生 N 个独立的作业，但不超过你拥有的核心数量的一半；用于<code>-workers=M</code>设置允许的并行作业数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./woff2-2016-05-06-fsanitize_fuzzer MY_CORPUS/ seeds/ -<span class="built_in">jobs</span>=8</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Google官方教程：<a href="https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md">https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md</a></p><p>LLVM官方文档：<a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a></p><p>Libfuzzer-workshop：<a href="https://github.com/Dor1s/libfuzzer-workshop/">https://github.com/Dor1s/libfuzzer-workshop/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;~~&lt;/p&gt;</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="LibFuzzer" scheme="http://example.com/tags/LibFuzzer/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读 -- &quot;AURORA - Statistical Crash Analysis for Automated Root Cause Explanation&quot;</title>
    <link href="http://example.com/2022/07/10/AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Ro/"/>
    <id>http://example.com/2022/07/10/AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Ro/</id>
    <published>2022-07-10T02:00:00.000Z</published>
    <updated>2022-09-21T06:46:48.030Z</updated>
    
    <content type="html"><![CDATA[<p>Author: Tim Blazytko, Moritz Schlögel, Cornelius Aschermann, Ali Abbasi, Joel Frank, Simon Wörner, and Thorsten Holz, Ruhr-Universität Bochum<br>Code: <a href="https://github.com/RUB-SysSec/aurora">https://github.com/RUB-SysSec/aurora</a><br>Topic: Root Cause<br>URL: <a href="https://www.usenix.org/conference/usenixsecurity20/presentation/blazytko">https://www.usenix.org/conference/usenixsecurity20/presentation/blazytko</a><br>Where: 29th USENIX Security Symposium<br>Year: 2020<br>Introducetion: 根因分析：一种采用Fuzz+动态执行+数理统计的方法</p><span id="more"></span><p>本文只是学习并记录笔记，如有错误或不足请谅解指正，谢谢！</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><ul><li>已有的解决方案及不足：各种依赖于反向执行和反向污点分析等技术的方法（如POMP 2017）。不足：这些技术可能只限于某些crash类型，或者只为分析人员提供汇编指令，但没有提供有关故障的更多说明</li><li>解决的问题：不仅能识别二进制程序崩溃的根本原因，还可以为分析人员提供了该位置产生崩溃的解释；相对于以往的工作，能够识别对于不存在数据依赖关系的错误（如类型混淆错误）</li><li>本文提出的创新方案概述：<ul><li>从导致崩溃的输出开始，生产一组不同的相似输入（部分会导致崩溃、另一部分正常运行）</li><li>执行输入时，跟踪程序状态，生成<code>predicates</code> （例如：产生崩溃与不产生崩溃输入之间的行为差异的简单布尔表达式）</li><li>通过<code>predicates</code> ，揭示根本原因的位置，并提供了该位置产生崩溃的解释</li></ul></li><li>实验效果  在25个软件漏洞上评估，表明：再复杂的bug，AURORA也能发现根本原因（修复与崩溃之间有数百万条指令），并且能够处理root cause和crash之间不存在数据依赖的错误，例如类型混淆错误。</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><hr><p>找到新的崩溃输入已较为容易和自动化，而对崩溃分类、处理还需要人工完成</p><ol><li>修复时间成本大：FUZZ—无数崩溃—负责修复—不堪重负</li><li>crash分类不准确：通常采用某一种度量进行分类（覆盖率或者调用栈的hash），一般每一类有一个crash就够了。但该分类方法容易不准确，且可能产生太多的类</li><li>如何定位崩溃原因？（通常崩溃的根本原因比崩溃位置更早）（当前方法：ASAN+手动回溯分析）</li></ol><h1 id="AURORA框架"><a href="#AURORA框架" class="headerlink" title="AURORA框架"></a>AURORA框架</h1><hr><ol><li>选择一个crash input文件，并产生一组相似的输入（一些会导致崩溃，另一些不会）</li><li>对于每个新的输入，执行、跟踪程序内部状态（每条指令的控制流信息、寄存器值），以此创建一组<code>predicates</code> （布尔表达式）</li><li>根据predicates，<strong>计算</strong>此输入是否会导致崩溃（怎么计算？） predicates ：会获取感兴趣的行为，如：是否执行了某一特定分支、寄存器是否包含可疑的小数</li></ol><h1 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h1><hr><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>作者举例 Ruby code  mruby解释器   类型混淆错误（type confusion bug）：</p><p><img src="/2022/07/10/AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Ro/Untitled.png"></p><ul><li>异常类型<code>NotImplementedError</code>被修改为字符串类型的别名。因此，将来创建的每个<code>NotImplementedError</code>实例都将是一个字符串，而不是预期的异常。</li><li>调用Module.constants函数，但函数不存在，触发<code>NotImplementedError</code>，实际上生成一个字符串对象</li><li>传递给mruby的自定义异常处理函数，函数假定对象具有异常属性，因此不检查，并添加”Module.constants not implemented”至该字符串对象上</li><li>最终在取消指针引用的时候，将长度字段解释为地址，非法内存访问，程序崩溃</li></ul><p>修复：在异常处理函数中添加类型检查</p><h2 id="根因分析通常采用的方法"><a href="#根因分析通常采用的方法" class="headerlink" title="根因分析通常采用的方法"></a>根因分析通常采用的方法</h2><ul><li>人工调试：时间成本长，复杂</li><li>sanitizer：ASAN、MSAN等，但不能识别上述类型混淆错误</li><li>反向污点分析：近期对这一方向的研究比较多，如：<strong><strong>REPT（2018 usenix）、RETracer（2016 IEEE）、POMP（2017 usenix）</strong></strong>，<strong>DEEPVSA（2019 usenix）</strong>但同样对于上述类型混淆错误不起作用（崩溃点与根本原因地址之间没有直接的数据流）</li><li>crash勘察：AFL crash exploration mode 将崩溃的输入作为种子，变异生成新的输入，保留仍导致崩溃的输入。这些输入会有新的路径覆盖。</li></ul><p>fuzz过程的一个问题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于作者给出的例子，为了对crash的根本原因有新的见解，需要崩溃探索模式来触发与类型混淆相关的新行为，即：Fuzzer需要向NotImplementedError分配除了String的另一种类型，而AFL的突变模式大概率会变成如“Stringgg”或“STRR”之类的内容。</span><br><span class="line">因此，使用基于语法的模糊器，如NAUTILUS: Fishing for Deep Bugs with Grammars。这些模糊器可以识别出String是Rudy的语法元素，并替换为其他元素，如Fuzzer选择“Hash”时，崩溃点与“String”不同，这有利于分析，因为比较两个输入表明崩溃可能与NotImplementedError的类型有关。</span><br></pre></td></tr></table></figure><h1 id="AURORA设计"><a href="#AURORA设计" class="headerlink" title="AURORA设计"></a><strong><strong>AURORA</strong></strong>设计</h1><p>核心思想：<strong>定位崩溃和非崩溃输入之间的行为差异</strong>。首先创建与崩溃相关的程序行为数据集，然后监控相关的输入行为，最后对它们进行比较分析。这是基于这样一种观点，即崩溃的输入在某种程度上必须从语义上偏离非崩溃的输入。直观地说，程序执行过程中导致偏差的第一个相关行为是根本原因。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>首先创建两组输入：导致崩溃的输入、不导致崩溃的输入（理想情况：导致崩溃的输入都是同一个根本原因） 方法：将崩溃输入作为种子进行崩溃探索fuzzing（AFL crash exploration mode）<a href="https://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html">https://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html</a></li><li>跟踪每一个输入的执行，将差异与结果联系起来，使用<code>predicates</code> 来形式化这一过程，具体跟踪的数据如下：<ol><li>对于<strong>执行的每条指令</strong>，我们记录所有修改的寄存器(包括通用寄存器和标志寄存器)的最小值和最大值（原因：限制循环导致的数据量。为什么合理？作者认为，导致崩溃的值通常以最小值或最大值的形式出现）</li><li>记录了每次内存写入的最大和最小存储值</li><li>没有收集有关目标地址的信息，由于：“we did not observe any benefit in tracing the memory addresses used”</li><li>保存粗略的控制流图</li><li>收集栈和堆的地址范围来测试某些指针是否使有效的堆栈指针</li><li>不跟踪共享库（减小开支）</li><li>消除对那些-从经验上来说-对在一个给定的二进制程序中发现错误不感兴趣的代码的追踪</li></ol></li><li>结果：向分析人员提供崩溃相关解释和地址的列表，按它们（predicates ）的预测质量和执行时间排序</li></ol><h2 id="Predicates"><a href="#Predicates" class="headerlink" title="Predicates"></a>Predicates</h2><ul><li>目的：以predicates（谓词）的形式区分崩溃与非崩溃运行之间的差异行为</li><li><strong>组成（一个三元组）</strong><ul><li>语义描述（如布尔表达式）e. g., “the maximum value of rax at this position is less than 2”           O(n ∗ log(n))              around 1,000 per instruction</li><li>被求值的指令地址</li><li>表示区分崩溃和非崩溃的能力的分数</li></ul></li></ul><p>换句话说，当谓词的计算结果为真时，分数表示认为会导致崩溃的概率。</p><p>得分较高的谓词标识了在根本原因和崩溃位置之间的路径上的某个代码位置。</p><p>最后，先按分数对这些谓词进行排序，然后按它们的执行顺序进行排序。给出这个排序后的谓词列表，人工分析人员就可以手动分析该错误。</p><ul><li>具体形成predicates的步骤：<ul><li>通过跟踪输入的行为获得结果：<ul><li>收集所有输入的控制流程图转换</li><li>之后，计算指令集（由地址标识），这些指令与基于谓词的分析相关</li><li>为每条指令生成许多谓词，保存分数最高的谓词</li></ul></li></ul></li></ul><h2 id="Predicates-Type"><a href="#Predicates-Type" class="headerlink" title="Predicates Type"></a>Predicates Type</h2><ul><li><strong>Control-flow Predicates</strong><ul><li>has_edge_to：给定一条从 x 至 y 的控制流边，至少有一条从 x 到 y 的转换</li><li>always_taken_to：从 x 出发的每个传出边都已被带到 y</li></ul>  最后，统计successor的数量（什么意思？需要看代码理解）</li><li><strong>Register and Memory Predicates</strong>  对于每条指令，根据：写入寄存器或内存的所有值中的最小值和最大值，生成表达式，来生成谓词  表达式示例：<code>r = max(Rax) &lt; c</code> （如何构造？下面介绍）<ul><li>is_heap_ptr(R)</li><li>is_stack_ptr(R)</li></ul></li><li><strong>Flag Predicates</strong>  检查carry, zero and overflow flag</li></ul><h2 id="Predicates-Evaluation"><a href="#Predicates-Evaluation" class="headerlink" title="Predicates  Evaluation"></a>Predicates  Evaluation</h2><p>每条指令，生成并测试所有类型的谓词，并存储得分最高的谓词。</p><p>谓词的质量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">谓词的质量，即，它对目标应用程序实际行为的预测程度</span><br><span class="line">如果在给定的输入上崩溃，则谓词的计算结果应为True；反之，为False；</span><br><span class="line">若能预测所有测试用例的结果（崩溃 or 非崩溃），则是完美的，但基本不可能。因此，作者为谓词引入了概率</span><br></pre></td></tr></table></figure><p>谓词三元组</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 语义描述（如布尔表达式：r = max(rax) &lt; 2）</span><br><span class="line">- 被求值的指令地址</span><br><span class="line">- 表示区分崩溃和非崩溃的能力的分数</span><br></pre></td></tr></table></figure><p>对于每个谓词，有两个核心点：</p><p>①布尔表达式的判定数？②分数怎么计算？</p><p><strong>判定数c的形成：（时间复杂度：O(n ∗ log(n))）</strong></p><p>假如现存在以下四个输入文件，两个crash，两个non-crash；假设其中在某一条指令上，max(rax)的值如下</p><p><img src="/2022/07/10/AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Ro/Untitled%201.png"></p><ol><li>对于所有输入文件中，同一条指令中，该寄存器的值进行排序</li><li>首先设判定数等于第一个value，即：<code>c = 0x08</code>，此时，对于布尔表达式 <code>r = max(rax) &lt; c</code>，四个都是false 其中，<code>Cf = 2 , Ct = 0 , Nf = 0 , Nt = 2</code>  ,带入作者的公式： <img src="/2022/07/10/AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Ro/Untitled%202.png"> 即： <img src="/2022/07/10/AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Ro/Untitled%203.png"> <img src="/2022/07/10/AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Ro/Untitled%204.png"> score = 0，表明这个c不是理想的值</li><li>将判定数设为第二个value，重复步骤2，以此类推，发现当判定数c值为0x400254时，score = 1 ，最理想</li></ol><p><strong>分数计算：</strong></p><ol><li>设某一条指令中，一个谓词的语义描述为：<code>r = min(Rax) &lt; c ，c = 0xff</code></li><li>一共有1013个崩溃输入，2412个非崩溃输入 统计得到： Crash input :           False = 1013,  True = 0 Non-crash input :   False = 2000,  True = 412</li><li>使用公式 <img src="/2022/07/10/AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Ro/Untitled%205.png"> 此时，谓词的分数为： <img src="/2022/07/10/AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Ro/Untitled%206.png"></li></ol><p>可以看到，判定数计算和分数计算的步骤几乎一致，也就是说，计算判定数的同时，就把分数也计算出来了。</p><p>同时作者还提到，绝大多数谓词与root cause无关，因此只保留分数大于0.9的谓词。</p><p>最后还对每个合适的谓词设置条件断点，并记录执行顺序。</p><hr><p>回到前面作者提及的<code>Ruby code  mruby解释器   类型混淆错误</code> 的例子：</p><p><img src="/2022/07/10/AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Ro/Untitled%207.png"></p><p><img src="/2022/07/10/AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Ro/Untitled%208.png"></p><p>根据前面的步骤，可以分析得出，在触发崩溃的样本中，类型值被赋予了16（string类型），其应当是18，所以根本原因谓词的本身条件是：<code>min(rax) &lt; 17</code></p><h2 id="Ranking"><a href="#Ranking" class="headerlink" title="Ranking"></a>Ranking</h2><ul><li>主要因素：谓词的分数  通过统计分析，每条指令获得一条最佳谓词，其分数表示谓词区分崩溃和非崩溃输入的程度。但大多数谓词是与崩溃无关的，因此作者筛选掉分数小于0.9的谓词，剩下的谓词确定了与错误有关的位置。  作者认为，程序执行前期的谓词更有可能对应于根本原因。</li><li>次要因素：谓词的执行顺序（解决分数并列问题）  为了知道每个谓词的执行顺序，作者为谓词设置了条件断点。执行输入时，计算每个断点在程序中的顺序。由于每个输入执行的路径不同，谓词的执行顺序不同，因此作者对每个谓词的断点进行平均求值。</li></ul><h1 id="开发与实验"><a href="#开发与实验" class="headerlink" title="开发与实验"></a>开发与实验</h1><ul><li>输入数据集：作者对AFL(版本2.52b)进行了修改，将本来要丢弃的非崩溃输入保存到非崩溃输入集。</li><li>跟踪输入执行：作者为英特尔PIN[40]（3.7版）实现了一个pintool，依靠英特尔的通用和特定架构的检测API，提取相关信息。</li><li>合成谓词解释：Rust  写的。合成、评估、排序所有谓词；条件断点使用ptrace syscall；使用addr2line获得谓词的函数名、行数。</li></ul><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ul><li>环境：Ubuntu 18.04     32核(基于Intel Xeon Silver 4114，2.20 GHz)和224 GiB RAM的云VM   禁用ASLR</li><li>对象：<ul><li>10个堆缓冲区溢出</li><li>1个空指针引用</li><li>3个整数溢出</li><li>1个栈溢出</li><li>2个类型混淆（缺少类型检查）</li><li>3个未初始化变量</li><li>5个UAF</li></ul>  他们都有崩溃验证文件及官方修补文件</li></ul><p><img src="/2022/07/10/AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Ro/Untitled%209.png" alt="结果分析"></p><ul><li>Top 50 指提取出来的前50个谓词，与根因是否存在直接关联</li><li>SLOC指需要检查的源代码行数量</li></ul><p><img src="/2022/07/10/AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Ro/Untitled%2010.png" alt="指令数分析"></p><ul><li>第一、二格：root cause 至崩溃点之间的指令数（最大、平均）</li><li>第三格：程序开始执行至崩溃点之间的指令数（平均）</li></ul><p>最后是时间成本分析</p><p><img src="/2022/07/10/AURORA%20Statistical%20Crash%20Analysis%20for%20Automated%20Ro/Untitled%2011.png" alt="时间成本分析（单位：小时）"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>解决了root cause 与崩溃点之间无数据流情况下的根因分析问题</li><li>核心思想：定位崩溃与非崩溃之间的<strong>行为差异</strong>（通过数理统计）</li><li>根因分析成功率及时间效率都较高（可以用更多实验来复现）</li></ol>]]></content>
    
    
    <summary type="html">根因分析：一种采用Fuzz + 动态执行 + 数理统计的方法</summary>
    
    
    
    <category term="Root Cause Analysis" scheme="http://example.com/categories/Root-Cause-Analysis/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="Dynamic Analysis" scheme="http://example.com/tags/Dynamic-Analysis/"/>
    
    <category term="Root Cause Analysis" scheme="http://example.com/tags/Root-Cause-Analysis/"/>
    
    <category term="Paper Reading" scheme="http://example.com/tags/Paper-Reading/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读 -- &quot;POMP- Postmortem Program Analysis with Hardware-Enhanced Post-Crash Artifacts&quot;</title>
    <link href="http://example.com/2022/06/27/POMP%20Postmortem%20Program%20Analysis%20with%20Hardware-Enh/"/>
    <id>http://example.com/2022/06/27/POMP%20Postmortem%20Program%20Analysis%20with%20Hardware-Enh/</id>
    <published>2022-06-27T02:00:00.000Z</published>
    <updated>2022-09-21T10:00:28.977Z</updated>
    
    <content type="html"><![CDATA[<p>Author: Jun Xu, The Pennsylvania State University;<br>Code: <a href="https://github.com/junxzm1990/pomp">https://github.com/junxzm1990/pomp</a><br>Topic: Root Cause, Taint<br>URL: <a href="https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/xu-jun">https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/xu-jun</a><br>Where: 26th USENIX Security Symposium<br>Year: 2017<br>Introducetion: 根因分析：使用了数据流、反向污点分析</p><span id="more"></span><p>本文只是学习并记录笔记，如有错误或不足请谅解指正，谢谢！</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>core dump（核心转储）拥有许多信息，但不能作为定位程序崩溃的调试信息，因为它携带的信息只说明了程序到达崩溃点的部分时间顺序。</p><p>随着硬件辅助处理器跟踪的出现，可以跟踪程序执行，并将其集成至core dump中，并提供了更多的有关程序崩溃的线索，但这依然需要许多的人工工作来完成崩溃诊断。</p><p>POMP：自动化地对crash进行分析（引入了一种新的逆向执行机制来构造程序崩溃之前所遵循的数据流），通过使用数据流，POMP执行向后的污点分析，并突出显示那些实际上导致崩溃的程序语句。</p><h1 id="背景与问题"><a href="#背景与问题" class="headerlink" title="背景与问题"></a>背景与问题</h1><p>对程序的崩溃分析主要集中在找出程序造成crash的控制流与数据流。</p><p>崩溃分析的主要技术：</p><ul><li>Record-and-replay  方法：记录程序崩溃的过程，之后回放这一过程记录。（例如：PANDA-RE）  优点：对程序崩溃的根因分析有很大的好处，可以在崩溃之前重构控制流和数据流  缺点：实际上，对程序插桩以及开销要求较大，未被广泛采用</li><li>core dump分析  方法：直接使用程序崩溃时产生的core dump进行进行分析  优点：不需要程序插桩，也不依赖程序执行的记录  缺点：由于只有故障的快照，因此只能推断出与程序崩溃有关的部分控制流和数据流信息</li></ul><p>硬件辅助处理器跟踪方面的进步改善了这一情况（Intel PT   一个新的硬件特性的出现），使得可以跟踪执行的指令，并保存在一个循环的缓冲区中。这不仅可以检查崩溃时的程序状态，还可以完全重构导致崩溃的控制流。但由于指令数量庞大，还是需要手动分析哪些是导致崩溃的指令。</p><p>已有的方案：</p><p>结合静态程序分析和使用Intel PT的动态程序分析的合作和自适应形式。但在分析内存破坏漏洞(例如缓冲区溢出或UAF)导致的崩溃时不太有效。因为内存破坏漏洞允许攻击者操纵控制或数据流，而静态程序分析严重依赖于程序执行不会违反控制或数据流完整性的假设。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>本文提出POMP：自动化精确定位与崩溃相关的语句。考虑到静态分析不可靠（流会被劫持）。POMP“逆向执行”机制，通过crash，重建程序崩溃之前执行的数据流，然后利用反向污染分析来确定导致崩溃的关键指令。</p><p>假设一个崩溃后的工件携带了所有实际导致崩溃的指令。</p><p><strong>例子：</strong></p><p><img src="/2022/06/27/POMP%20Postmortem%20Program%20Analysis%20with%20Hardware-Enh/Untitled.png"></p><p>对于该存在crash的程序，由于第7行的溢出，第16行会产生崩溃，崩溃后，执行跟踪，并捕获内存状态。如下图所示：</p><p><img src="/2022/06/27/POMP%20Postmortem%20Program%20Analysis%20with%20Hardware-Enh/Untitled%201.png"></p><p>其中，A18和test代表指令和函数的地址。</p><p>但这里存在内存别名问题，例如：A14执行后寄存器eax中的值同时依赖于指令A12和A13，但是，指令A12和A14中显示的[ebp+0x8]和[eax]指示的内存可能是彼此的别名，就无法确定A14中的定义是否中断了来自A12和A13的数据流。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>依靠Intel PT来跟踪程序的控制流，并将其集成到崩溃后的工件中。<ol><li>PT通过捕获每个硬件线程上的软件执行信息来工作，有了控制流传输和程序二进制，就可以完全重建执行指令的跟踪</li></ol></li><li>重构数据流（与程序崩溃有关的数据流）<ol><li>引入一种逆向执行机制来恢复内存占用</li></ol></li></ol><p>使用这种逆向执行机制，POMP可以轻松地在执行每条指令之前恢复机器状态，还能自动验证内存别名</p><p>以上图为例：在逆向执行完成A19指令的操作后，可以恢复eax寄存器的值，从而恢复A19之前的内存占用（即T18时的内存占用情况）；而A18是一个算术指令，因此又可以恢复A18之前（T17）时的内存占用情况……</p><p>A17：<code>ret</code> 等价于 <code>mov eip ,[esp]    add esp ,0x4</code></p><p>A16：<code>pop ebp</code>等价于 <code>mov ebp, [esp]    add esp ,0x4</code> </p><p>通过上述处理指令的方案，逆向执行可以进一步恢复内存占用。</p><p>而对于A15 <code>mov eax, 0x0</code>，由于A14中的<code>[eax]</code>和A12中的<code>[ebp+0x8]</code>可能访问的是同一内存地址，不能确定A12中的<code>[ebp+0x8]</code>能否在指令A15执行之前到达现场？（内存别名问题）</p><p>解决内存别名的方法：</p><ol><li><a href="https://link.springer.com/chapter/10.1007/978-3-540-24723-4_2">值集分析算法</a>（value-set analysis algorithm）：不可用，因为其要求符合标准的编译规则，但程序产生崩溃通常违反这一规则</li><li>假设验证：使用逆向执行创建两个假设（①是同一个地址的不同别名；②与一相反），然后模拟指令的逆运算测试这两种假设<ol><li>假设① 是同一个地址，则对于A14与A15来说，T14的信息约束为：<ol><li><code>eax = ebp + 0x8</code></li><li><code>eax = [ebp + 0x8] + 0x4</code></li><li><code>[eax] = 0x2</code></li></ol></li><li>假设② 不是同一个地址：<ol><li><code>eax ≠ ebp + 0x8</code></li><li><code>eax = [ebp + 0x8] + 0x4</code></li><li><code>[eax] = 0x2</code></li></ol></li></ol> 通过查看T14的内存占用，可以发现假设②成立，因为假设①第i条不成立。</li></ol><p>POMP使用<strong>反向污点分析</strong>自动化完成这一过程。</p><p>例如：本例最后的eax错误值来自于A19的传递，将<code>[ebp-0xC]</code>复制到eax中，而通过检查恢复的内存占用情况，可以发现<code>[ebp-0xC]</code>与A14中的<code>[eax]</code>指向同一个地址（0xff1c），这就意味着这个错误值实际上是从A14传播来的，因此就找到了造成崩溃的相关指令：A19与A14</p><h2 id="1、逆向执行"><a href="#1、逆向执行" class="headerlink" title="1、逆向执行"></a>1、逆向执行</h2><h3 id="Use-Define链"><a href="#Use-Define链" class="headerlink" title="Use-Define链"></a>Use-Define链</h3><p>首先解析执行路径。对于路径中的每条指令，根据指令的语义提取相应的变量的Use-Define。然后将它们链接到先前构造的Use-Define链中。</p><p>例如：</p><p><img src="/2022/06/27/POMP%20Postmortem%20Program%20Analysis%20with%20Hardware-Enh/Untitled%202.png"></p><p>一个定义包括三个元素：指令ID、Use-Define的变量、变量的值。每次在Use-Define链上增加时，会检查相应的定义与使用，并确定是否可以获取相应的值。</p><p>例如，在上图中，A18红圆圈内的值是通过T18内存状态获取的，而use:esp的值是通过语义推导计算获取的（esp = esp -0x4）</p><p>在Use-Define使用过程中，会遇到以下问题：试图给一个由内存区域表示的变量赋值，但该区域的地址不能通过使用链上的信息来解析</p><p>例如：A14的内存写操作中，地址由eax表示，但在这个示例的Use-Define中：</p><p><img src="/2022/06/27/POMP%20Postmortem%20Program%20Analysis%20with%20Hardware-Enh/Untitled%203.png"></p><p>可以看到A13中的def: eax没有任何值，但它影响到了A14的节点。这样的话，A14的def: [eax]就有可能阻塞A12中的use: [ebp+0x08]，因为他们可能是同一个地址。</p><p>这里作者选择：对于这些未知的内存写入，作为一个插入标记，并阻塞之前的Use-Def的使用。确保不会给内存占用的恢复过程引入错误。</p><p>静态切片也可以用于发现Use-Def。但作者利用恢复的内存占用来进一步查找Use-Def关系，并处理了内存别名问题。</p><h3 id="内存别名验证"><a href="#内存别名验证" class="headerlink" title="内存别名验证"></a>内存别名验证</h3><p>针对内存别名问题，作者采用的方法是：</p><p>遍历链上的每个节点，检查新传播的数据流是否导致冲突，一般有两种冲突类型：①不一致的数据依赖 ②无效的数据依赖关系（会使程序在实际崩溃点之前出错）</p><p><img src="/2022/06/27/POMP%20Postmortem%20Program%20Analysis%20with%20Hardware-Enh/Untitled%204.png"></p><p>假设A2 <code>def[R2]</code>与A4 <code>def[R5]</code>作为阻碍数据流传播的中间标签，在假设[R4]与[R5]不是同一个地址基础上，中间标签之间的数据流可以传播，如果证明[R4]与[R5]不是同一个地址，则继续假设[R1]与[R2]不是同一个地址……以此类推。最坏的情况是，在逆向执行的过程中，每条指令的反向操作都需要别名验证。因此作者对这种情况进行了限制（最多两次递归），相对高效。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>程序执行会调用系统调用，这会锁定到内核空间中，但作者没有将Inter PT设置为跟踪内核空间，通常来说逆向执行会产生路径丢失的问题。然鹅大多数系统调用不会对用户空间的寄存器和内存做出改变，因此可以忽略，对于会影响内存空间的系统调用：</p><ul><li>对于可能影响寄存器的系统调用，作者只是在use-define链上引入一个定义  例如：系统调用read会把返回值保存在eax中，就会在use-define链相应的位置添加：<code>def: eax = ?</code></li><li>对于可能影响内存内容的系统调用，检查受该调用影响的内存区域  通过使用在调用之前执行的指令来确定起始地址以及内存区域的大小，因为起始地址和大小通常由参数表示，这些参数在调用之前由这些指令处理。（按照这个过程，如果我们的算法确定了内存区域的大小，它将相应地向链追加定义。否则，将该系统调用视为一个中间标记，它将阻止通过该调用的传播3。这背后的原因是，非确定性内存区域可能与用户空间中的任何内存区域重叠。）</li></ul><h2 id="2、反向污点分析-Backward-Taint-Analysis"><a href="#2、反向污点分析-Backward-Taint-Analysis" class="headerlink" title="2、反向污点分析 Backward Taint Analysis"></a>2、反向污点分析 Backward Taint Analysis</h2><p>确定真正与程序崩溃有关的指令。</p><p>通常，程序崩溃原因：</p><p>①执行无效命令：<strong>eip</strong>是一个错误的值</p><p>②引用无效地址：<strong>通用寄存器</strong>指向错误的地址（例如<a href="https://www.notion.so/POMP-Postmortem-Program-Analysis-with-Hardware-Enhanced-Post-Crash-Artifacts-409ffaaeabfd49819f30ac909c5ab212">最上面的表格</a> 中的eax）</p><p>标识了错误点（eip或通用寄存器）后，POMP会污染这个错误点，并进行反向污点传播。</p><p>在这个过程中：</p><ol><li>POMP使用获取的Use-Def链，并识别污染变量的定义Def（这种识别的标准是确保定义可以在没有任何其他干预定义的情况下到达污点变量）<ol><li>例如：在上表中，将eax作为初试污点变量后，POMP会选择链上的A19：<code>def：eax = [ebp - 0xc]</code>，因为这里不会受到干预而达到污染变量eax。</li></ol></li><li>从确定的定义中，POMP解析该定义并将污染传递给新变量<ol><li>由于定义中包含的任何变量都可能导致污染变量的破坏，POMP选择传递污染变量包括所有操作数、基寄存器和索引寄存器</li><li>例如：通过解析Def A19：<code>def：eax = [ebp - 0xc]</code>，POMP标识变量ebp和[ebp-0xc]，并将污染传递给这两个变量。</li></ol></li></ol><p><strong>特点</strong>：这种污染传播策略可以保证POMP不会遗漏程序崩溃的根本原因，尽管它会过度污染一些实际上不会导致崩溃的变量。</p><p>注意：</p><ul><li>当将污点传递给由内存访问指示的变量（例如[R0]）时，注意 POMP 可能无法识别与内存对应的地址（R0的值可能未知），出现这种情况，POMP 就会停止该变量的污点传播，因为污点可能会传播到具有 def:[Ri] 形式定义的任何变量</li><li>反向污点传播过程中，POMP可能会遇到链上的一个定义，该定义会干预传播。<ul><li>例如：已知污点变量[R0]和定义 def：[R1]，其中R1未知，此时不能缺点R0和R1是否是同一个值，即是否将污点从R0传播至R1？</li><li>解决方法：采用前面的假设验证思想，但实际上这种方法不一定有效，当无法判断时，只能对变量采用“过度污染”，以确保不会遗漏崩溃的根本原因。</li></ul></li></ul><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><p>POMP两部分</p><p>① 逆向执行 和 逆反向污点分析</p><p>65个不同的指令处理程序来执行反向执行和反向污染分析</p><p>构建了核心转储和指令解析器（基于libelf和libdisasm）</p><p>② 使用Intel PT跟踪程序执行</p><p>使Inter PT 在物理地址表模式（ToPA）下运行，这可以在多个不连续的物理内存区域中存储PT数据包。</p><p>效果：</p><p><img src="/2022/06/27/POMP%20Postmortem%20Program%20Analysis%20with%20Hardware-Enh/Untitled%205.png"></p><p>把人工分析作为基本事实，并将它们与Pomp得到的指令进行了比较。验证了POMP在故障诊断中的有效性。</p><p>检测有效性的重点包括：</p><ol><li>检查崩溃的根本原因是否包含在Pomp自动识别的指令集中</li><li>调查Pomp的输出是否覆盖了我们手动跟踪的最小指令集</li><li>Pomp是否可以显著削减软件开发人员手动检查的消耗</li></ol><p>不足：</p><ul><li>过度污染问题：存在，但微不足道</li></ul>]]></content>
    
    
    <summary type="html">介绍了动态污点分析及符号执行，总结了这些技术的框架及关键问题</summary>
    
    
    
    <category term="Root Cause Analysis" scheme="http://example.com/categories/Root-Cause-Analysis/"/>
    
    
    <category term="Root Cause Analysis" scheme="http://example.com/tags/Root-Cause-Analysis/"/>
    
    <category term="Paper Reading" scheme="http://example.com/tags/Paper-Reading/"/>
    
    <category term="Backward Taint Analysis" scheme="http://example.com/tags/Backward-Taint-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读 -- &quot;All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution&quot;</title>
    <link href="http://example.com/2022/05/23/All%20You%20Ever%20Wanted%20to%20Know%20About%20Dynamic%20Taint%20An/"/>
    <id>http://example.com/2022/05/23/All%20You%20Ever%20Wanted%20to%20Know%20About%20Dynamic%20Taint%20An/</id>
    <published>2022-05-23T02:00:00.000Z</published>
    <updated>2022-09-21T06:53:08.488Z</updated>
    
    <content type="html"><![CDATA[<p>Author: Edward J. Schwartz, Thanassis Avgerinos, David Brumley Carnegie Mellon University<br>Topic: Dynamic, Sym_exe, Taint<br>URL: <a href="https://ieeexplore.ieee.org/document/5504796?reload=true">https://ieeexplore.ieee.org/document/5504796?reload=true</a><br>Where: IEEE Symposium on Security and Privacy<br>Year: 2010<br>Introducetion: 介绍了动态污点分析及符号执行，总结了这些技术的框架及关键问题</p><span id="more"></span><p>本文只是学习并记录笔记，如有错误或不足请谅解指正，谢谢！</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><ul><li><strong>要解决的问题：</strong>动态污点分析与正向符号执行虽然被广泛使用，但没有正式定义的算法、没有总结这些技术的关键问题</li><li><strong>已有的解决方案：</strong>无</li><li><strong>本文提出的创新方案概述：</strong>精确地描述了动态污点分析和正向符号执行的算法，作为对通用语言运行时语义的扩展；强调了在安全环境中使用这些技术时的重要实现选择、常见陷阱和注意事项</li><li><strong>效果：</strong>本文将动态污点分析形式化，展示如何使用我们的形式化来梳理和描述各种安全应用程序中常见的实现细节、注意事项和选择</li></ul><h1 id="概念与介绍"><a href="#概念与介绍" class="headerlink" title="概念与介绍"></a>概念与介绍</h1><hr><p>动态污点分析运行一个程序，观察哪些计算受到预定义污点源（如用户输入）的影响。</p><p>动态正向符号执行自动构建描述程序执行路径的逻辑公式，从而将执行推理问题减少到逻辑领域。</p><p>这两种分析可以结合使用，以构建仅表示依赖于受污染值的执行部分的公式。</p><p>两种技术的应用领域：</p><ul><li>未知漏洞检查（Unknown Vulnerability Detection）：动态污点分析可以通过监测是否执行了用户输入来防止代码注入攻击</li><li>自动生成输入过滤器（Automatic Input Filter Generation）：符号执行可用于自动生成输入过滤器，检测并删除输入流中的漏洞</li><li>恶意软件分析（Malware Analysis）</li><li>生成测试用例（Test Case Generation）</li></ul><h1 id="一种中间语言-SIMPLE（略过）"><a href="#一种中间语言-SIMPLE（略过）" class="headerlink" title="一种中间语言-SIMPLE（略过）"></a>一种中间语言-SIMPLE（略过）</h1><hr><p>作者设计了一种中间语言：SIMPIL  来演示动态污染分析和正向符号执行的关键方面，并介绍了该语言的语法、操作语义</p><p>SIMPIL示例：</p><p><img src="/2022/05/23/All%20You%20Ever%20Wanted%20to%20Know%20About%20Dynamic%20Taint%20An/Untitled.png"></p><h1 id="动态污点分析"><a href="#动态污点分析" class="headerlink" title="动态污点分析"></a><strong>动态污点分析</strong></h1><hr><p>tip：污点分析<strong>三元组&lt;sources, sinks, sanitizers&gt;</strong></p><ul><li>目的：跟踪信息源（sources）和污点汇聚点（sinks）之间的信息流</li><li>相关基本概念：<ul><li><strong>T</strong>：任何依赖于从污染源派生的数据来计算的程序值，都被认为是受污染的</li><li><strong>F</strong>：任何其他值都被认为是未受污染的</li><li><strong>污点策略P</strong>：准确地确定程序执行时污点如何流动，哪些操作引入新污点，以及对受污点的值执行什么检查</li></ul></li><li>可能出现的错误errors：<ul><li>过度污染：动态污点分析可能将不是从污点源派生的值标记为污点</li><li>缺失污染：可能会遗漏从sources到sinks的信息流</li></ul></li></ul><h2 id="Dynamic-Taint-Policies-污点策略"><a href="#Dynamic-Taint-Policies-污点策略" class="headerlink" title="Dynamic Taint Policies 污点策略"></a>Dynamic Taint Policies 污点策略</h2><ul><li>属性（对应以下三个规则）：<ul><li>新的污点是怎么被<strong>引入</strong>到程序中的</li><li>污点是如何在指令执行时<strong>传播</strong>的</li><li>在执行期间，如何<strong>检查</strong>污点</li></ul></li><li>污点引入规则（Taint introduction rules）：指定如何将污点引入系统<ul><li>污点策略通常会区分输入源：<ul><li>面向互联网的网络输入源 可能会引入污染</li><li>从可信配置文件读取的文件描述符 可能不会</li></ul></li></ul></li><li>污点传播规则（Taint propagation rules）：指定来自受污染或未受污染操作数的数据的污染状态  通常使用命题逻辑来表达传播策略，例如，t1 ∨ t2 表示如果 t1 被污染或 t2 被污染，则结果被污染</li><li>污点检查（Taint Checking）  污染状态值通常用于确定程序的运行时行为，例如，如果跳转目标地址被污染，则攻击检测器可能会暂停执行</li></ul><h2 id="一种典型的污点策略"><a href="#一种典型的污点策略" class="headerlink" title="一种典型的污点策略"></a>一种典型的污点策略</h2><p>受污染跳转策略（ tainted jump policy）</p><p><img src="/2022/05/23/All%20You%20Ever%20Wanted%20to%20Know%20About%20Dynamic%20Taint%20An/Untitled%201.png"></p><ul><li>目标：保护潜在易受攻击的程序免受控制流劫持攻击</li><li>该策略的主要思想：从输入派生的值永远不会覆盖控制流值、返回地址、函数指针，确保免受此类攻击</li><li>过程：该策略将所有<code>input()</code>的值标记为污染，然后引入程序中，传播污点  <img src="/2022/05/23/All%20You%20Ever%20Wanted%20to%20Know%20About%20Dynamic%20Taint%20An/Untitled%202.png">  如在上图中（污点引入、污点传播、污点检查），检测到<code>input()</code>值最终可能污染y，程序停机</li><li>缺点：不适用所有应用场景（没考虑输入值是否使内存地址受到污染 即上表中Pmem）<strong>Q：为什么没这样做</strong></li></ul><h2 id="Challenges-and-Opportunities-挑战与机遇"><a href="#Challenges-and-Opportunities-挑战与机遇" class="headerlink" title="Challenges and Opportunities 挑战与机遇"></a>Challenges and Opportunities 挑战与机遇</h2><h3 id="（1）Tainted-Addresses-："><a href="#（1）Tainted-Addresses-：" class="headerlink" title="（1）Tainted Addresses ："></a>（1）<strong>Tainted Addresses ：</strong></h3><ul><li>区分<strong>存储地址</strong>和<strong>存储单元值</strong> 并不总是合适的（如上面的典型策略）</li><li>如下面的程序，使用tainted jump policy并不会识别攻击：  <img src="/2022/05/23/All%20You%20Ever%20Wanted%20to%20Know%20About%20Dynamic%20Taint%20An/Untitled%203.png"></li><li>改进策略：采用<code>tainted addresses policy</code>（表5），若地址或单元值之一被污染，则结果也判定被污染  但这种改进策略也存在问题：过度污染。举例tcpdump（每次重要运行都会导致taint error）  <img src="/2022/05/23/All%20You%20Ever%20Wanted%20to%20Know%20About%20Dynamic%20Taint%20An/Untitled%204.png"></li></ul><h3 id="（2）Time-of-Detection-vs-Time-of-Attack-："><a href="#（2）Time-of-Detection-vs-Time-of-Attack-：" class="headerlink" title="（2）Time of Detection vs. Time of Attack ："></a>（2）<strong>Time of Detection vs. Time of Attack</strong> ：</h3><p>动态污染分析可能会太晚发出警报，不能保证在此之前程序的完整性没有被破坏。</p><ul><li>例如：典型的返回地址覆盖利用漏洞（shellcode覆盖返回地址）中， tainted jump policy可以检测到此类漏洞，但是在第一次覆盖返回地址时不会引发error，只有稍后进行跳转时才会引发、报告漏洞。在这之间，有可能产生其他error。<ul><li><strong>问题</strong>：动态污点分析跟踪的信息太少，<strong>很难</strong>验证返回地址的位置是否被覆盖（canary？1998）答：</li></ul></li></ul><p>基于污点的攻击检测工具通常显示检测时间至攻击时间的间隔</p><h3 id="（3）控制流污点分析（Control-flow-taint）"><a href="#（3）控制流污点分析（Control-flow-taint）" class="headerlink" title="（3）控制流污点分析（Control-flow taint）"></a>（3）控制流污点分析（Control-flow taint）</h3><p>纯动态污点分析不能计算控制依赖关系，因此不能完成基于控制流的污点分析（因为动态分析一次只在一条路径上执行）</p><p>部分解决方法：</p><ul><li>补充静态分析，以此计算控制依赖关系</li><li>试探法（heuristics）：根据场景做出选择是否过度/缺失污染</li></ul><h3 id="4）消除污点（Sanitization）"><a href="#4）消除污点（Sanitization）" class="headerlink" title="4）消除污点（Sanitization）"></a>4）消除污点（Sanitization）</h3><p>动态污点分析只会增加污点的数量，不会主动删除污点。随着程序的执行，被污染的值会越来越多，降低了污染精度。</p><ul><li>检查<strong>常量函数</strong>：<ul><li>一些污点分析工具（<a href="http://bitblaze.cs.berkeley.edu/">TEMU</a>、<a href="https://valgrind.org/docs/newsome2005.pdf">TaintCheck</a>）检查常量函数，以去除不必要的污点</li><li>例子：X86中常使用 <code>B = A XOR A</code> 这种语句来对寄存器清零。即B的值不依赖于A。但若A被污染，默认的污点分析策略会判断B也被污染</li></ul></li><li>某些领域中，将<strong>加密散列函数的输出</strong>视为无污染值：加密函数的输入可能是用户指定的，但<strong>很难</strong>找到会导致加密散列函数输出任意值的输入。  <a href="https://dl.acm.org/doi/10.1145/1554339.1554349">Newsome等人</a>通过量化用户对函数的输出可以施加多少控制，以此来自动识别这种情况。</li><li>可能存在依赖于程序的消除。例如，如果程序逻辑本身执行清理，则攻击检测器可能希望不污染值</li></ul><h1 id="符号执行-FORWARD-SYMBOLIC-EXECUTION"><a href="#符号执行-FORWARD-SYMBOLIC-EXECUTION" class="headerlink" title="符号执行 FORWARD SYMBOLIC EXECUTION"></a>符号执行 FORWARD SYMBOLIC EXECUTION</h1><hr><p>正向符号执行 —&gt;构建表示程序执行的逻辑公式 —&gt;  对程序不同输入进行推理</p><ul><li>优势：可以一次推理多个输入，推断不同的分支</li><li>与常规执行的区别：用符号替代具体的值</li></ul><p><img src="/2022/05/23/All%20You%20Ever%20Wanted%20to%20Know%20About%20Dynamic%20Taint%20An/Untitled%205.png"></p><p>详细理解符号执行，可以看：</p><p><a href="https://www.notion.so/Symbolic-Execution-for-Software-Testing-Three-Decades-Later-ddec41dd5bbb431bb60b2c6d1aa931e0">Symbolic Execution for Software Testing: Three Decades Later</a></p><h2 id="Challenges-and-Opportunities-挑战与机遇-1"><a href="#Challenges-and-Opportunities-挑战与机遇-1" class="headerlink" title="Challenges and Opportunities 挑战与机遇"></a>Challenges and Opportunities 挑战与机遇</h2><p>问题：符号内存；处理系统调用；路径选择。</p><h3 id="（1）Symbolic-Memory-Addresses-符号内存地址"><a href="#（1）Symbolic-Memory-Addresses-符号内存地址" class="headerlink" title="（1）Symbolic Memory Addresses 符号内存地址"></a>（1）Symbolic Memory Addresses 符号内存地址</h3><ul><li>原理：<ul><li>具体执行时，使用具体值；符号执行时，使用表达式。</li><li>从符号表达式load时，表示从任何符合条件的地址处load</li><li>store到符号地址时，表示能覆盖任何符合条件的地址</li></ul></li></ul><p>问题：</p><ul><li><strong>别名问题</strong>，两个内存操作引用同一地址时，就会出现潜在的地址别名<ul><li>例如：  <code>store( addr1 , v )</code>   <code>z = load( addr2 )</code>  若：addr1 = addr2，则为别名，load到z中的值为v  若：addr1 ≠ addr2，则不会load v，  因此，符号内存地址也可能导致混叠问题</li><li>解决方法：<ul><li>去除符号地址，不重名（<a href="http://bitblaze.cs.berkeley.edu/">Vine</a> 可以根据名称选择性地将所有内存地址重写为标量）  例如上面的例子可以改写为：  <code>mem_addr1 = v</code>  <code>z = mem_addr2</code></li><li>SMT求解器进行推理  <code>mem1 = (mem0 with mem0[addr1] = v) ^ z =mem1[addr2]</code> （暂时没看懂）  理解：addr1处的值 = v  ，mem1 = mem0</li><li>别名分析（静态分析），推断两个引用是否指向同一个地址</li></ul></li><li>以往工作：  大多数工作没有专门解决符号地址的问题。  KLEE采用别名分析+SMT求解器；DART[35]、CUTE[56]只处理线性约束的公式，不能处理一般化的符号引用  访问线性地址时，可以解线性方程组，查看是否有别名（2010前没有相关工作）</li></ul></li><li>路径选择<ul><li>存在路径爆炸的问题，需要良好的路径选择策略：<ul><li>设置循环迭代次数上限</li><li>深度优先搜索：如KLEE和EXE，并设置最大深度</li><li>混合测试：符号执行+实际执行；变形策略：generational search：单次符号执行生成多个具体的测试输入</li><li>随机路径策略：如KLEE。符号执行引擎通过从根节点到叶节点的随机遍历状态树来选择状态，浅层路径，可以防止执行卡住</li><li>启发式：探索路径，提高覆盖率</li></ul></li></ul></li><li>符号跳转问题<ul><li>指：GOTO跳转目标不是具体位置，而可能是一个表达式</li><li>解决方法：<ul><li>符号执行+实际执行：观察下一个jump的目标。缺点：只探索已知的跳转目标</li><li>SMT求解器：条件取反求解其他路径</li><li>静态分析：源码级间接跳跃分析通常采用指针分析的形式，二进制级跳转静态分析用于识别跳转目标表达式中哪些值会被引用</li></ul></li></ul></li><li>处理系统、库函数问题<ul><li>系统调用会引入新的符号变量</li><li>解决方法：<ul><li>创建函数的总结（summaries）：描述在具体调用相应代码时发生的副作用的模型，但需要手动生成</li><li>混合执行：先实际执行，得到系统调用的返回值，再在符号执行中使用该值。但结果不一定可靠，因为每次调用不一定返回相同的值（如时间相关函数）。</li></ul></li></ul></li><li>性能<ul><li>a)程序分支数量的运行时间指数，b)公式数量的指数，以及c)每个分支的公式大小的指数</li><li>解决方法：<ul><li>硬件提升</li><li>赋予变量不同名称</li><li>识别公式冗余</li><li>识别独立的子公式：将多次使用过的公式保存缓存，如KLEE和EXE</li><li>使用weakest precondition计算公式。如<a href="https://www.cylab.cmu.edu/_files/pdfs/tech_reports/CMUCyLab10002.pdf">一种算法</a>，在使用该算法之前，必须将程序转换为动态单赋值形式</li></ul></li></ul></li><li>混合执行（Mixed）<ul><li>根据程序的应用及类型，将符号输入限制为某些形式，可能会比较合适</li><li>例子：server的配置文件不需要符号化（一般不允许改写配置文件），而网络包数据需要符号化</li></ul></li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ol><li>自动化测试用例生成（提高代码覆盖率）：符号执行</li><li>过滤器自动生成：符号执行</li><li>自动网络协议解析：动态污点分析</li></ol><p>其他：恶意软件分析、污点分析框架（动静结合）等</p><p>其他作者的笔记：</p><p><a href="https://www.jianshu.com/p/62bac645c034">https://www.jianshu.com/p/62bac645c034</a></p>]]></content>
    
    
    <summary type="html">介绍了动态污点分析及符号执行，总结了这些技术的框架及关键问题</summary>
    
    
    
    <category term="Taint Analysis" scheme="http://example.com/categories/Taint-Analysis/"/>
    
    
    <category term="Dynamic Analysis" scheme="http://example.com/tags/Dynamic-Analysis/"/>
    
    <category term="Paper Reading" scheme="http://example.com/tags/Paper-Reading/"/>
    
    <category term="Symbol Execution" scheme="http://example.com/tags/Symbol-Execution/"/>
    
    <category term="Taint Analysis" scheme="http://example.com/tags/Taint-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>AFL插桩（二）LLVM模式插桩</title>
    <link href="http://example.com/2022/05/21/AFL%E6%8F%92%E6%A1%A9%EF%BC%88%E4%BA%8C%EF%BC%89LLVM%E6%A8%A1%E5%BC%8F%E6%8F%92%E6%A1%A9/"/>
    <id>http://example.com/2022/05/21/AFL%E6%8F%92%E6%A1%A9%EF%BC%88%E4%BA%8C%EF%BC%89LLVM%E6%A8%A1%E5%BC%8F%E6%8F%92%E6%A1%A9/</id>
    <published>2022-05-21T02:00:00.000Z</published>
    <updated>2022-09-22T01:24:46.668Z</updated>
    
    <content type="html"><![CDATA[<p>~~</p><span id="more"></span><h2 id="一、LLVM模式插桩概述"><a href="#一、LLVM模式插桩概述" class="headerlink" title="一、LLVM模式插桩概述"></a>一、LLVM模式插桩概述</h2><p>AFL的 <code>llvm_mode</code> 可以实现编译器级别的插桩，可以替代 <code>afl-gcc</code> 或 <code>afl-clang</code> 使用的比较“粗暴”的汇编级别的重写的方法</p><p>优点：</p><ul><li>编译器可以进行很多优化以提升效率</li><li>可以实现CPU无关，可以在非 x86 架构上进行fuzz</li><li>可以更好地处理多线程目标</li></ul><p>AFL的 <code>llvm_mode</code> 文件夹下包含3个文件：</p><ul><li><code>afl-llvm-rt.o.c</code> 文件主要是重写了 <code>afl-as.h</code> 文件中的 <code>main_payload</code> 部分，方便调用</li><li><code>afl-llvm-pass.so.cc</code> 文件主要是当通过 <code>afl-clang-fast</code> 调用 clang 时，这个pass被插入到 LLVM 中，告诉编译器添加与 <code>afl-as.h</code> 中大致等效的代码</li><li><code>afl-clang-fast.c</code> 文件本质上是 clang 的 wrapper，最终调用的还是 clang 。但是与 <code>afl-gcc</code> 一样，会进行一些参数处理。</li></ul><p><code>llvm_mode</code> 的插桩思路就是通过编写pass来实现信息记录，对每个基本块都插入探针，具体代码在 <code>afl-llvm-pass.so.cc</code> 文件中，初始化和forkserver操作通过链接完成</p><p>Clang 编译器，从源码至机器码的流程如下：</p><p><img src="/2022/05/21/AFL%E6%8F%92%E6%A1%A9%EF%BC%88%E4%BA%8C%EF%BC%89LLVM%E6%A8%A1%E5%BC%8F%E6%8F%92%E6%A1%A9/Untitled.png"></p><p>代码首先由编译器前端clang处理后得到中间代码IR，然后经过各 LLVM Pass 进行优化和转换，最终交给编译器后端生成机器码，其中LLVM Pass 可以在中间过程处理 IR 、用户自定义的内容，可以用来遍历、修改 IR 以达到<strong>插桩</strong>、优化、静态分析等目的。</p><p>AFL进入llvm_mode进行编译<code>afl-clang-fast</code>（注意：llvm和clang版本要一致）</p><p>一个坑：最开始使用的llvm和clang版本是14版本，但编译会报错；改为11版本可以正常编译</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root @ zzz in ~/Desktop/AFL/llvm_mode on git:master o [14:18:42] C:2</span></span><br><span class="line">$ make all</span><br><span class="line">[*] Checking <span class="keyword">for</span> working <span class="string">&#x27;llvm-config&#x27;</span>...</span><br><span class="line">[*] Checking <span class="keyword">for</span> working <span class="string">&#x27;clang&#x27;</span>...</span><br><span class="line">[*] Checking <span class="keyword">for</span> <span class="string">&#x27;../afl-showmap&#x27;</span>...</span><br><span class="line">[+] All <span class="built_in">set</span> and ready to build.</span><br><span class="line">clang -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/<span class="built_in">local</span>/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/<span class="built_in">local</span>/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  afl-clang-fast.c -o ../afl-clang-fast </span><br><span class="line">ln -sf afl-clang-fast ../afl-clang-fast++</span><br><span class="line">clang++ `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fpic -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DVERSION=\&quot;2.57b\&quot; -Wno-variadic-macros -shared afl-llvm-pass.so.cc -o ../afl-llvm-pass.so `llvm-config --ldflags` </span><br><span class="line">clang -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/<span class="built_in">local</span>/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/<span class="built_in">local</span>/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  -fPIC -c afl-llvm-rt.o.c -o ../afl-llvm-rt.o</span><br><span class="line">[*] Building 32-bit variant of the runtime (-m32)... failed (that<span class="string">&#x27;s fine)</span></span><br><span class="line"><span class="string">[*] Building 64-bit variant of the runtime (-m64)... success!</span></span><br><span class="line"><span class="string">[*] Testing the CC wrapper and instrumentation output...</span></span><br><span class="line"><span class="string">unset AFL_USE_ASAN AFL_USE_MSAN AFL_INST_RATIO; AFL_QUIET=1 AFL_PATH=. AFL_CC=clang ../afl-clang-fast -O3 -funroll-loops -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign -DAFL_PATH=\&quot;/usr/local/lib/afl\&quot; -DBIN_PATH=\&quot;/usr/local/bin\&quot; -DVERSION=\&quot;2.57b\&quot;  ../test-instr.c -o test-instr </span></span><br><span class="line"><span class="string">../afl-showmap -m none -q -o .test-instr0 ./test-instr &lt; /dev/null</span></span><br><span class="line"><span class="string">echo 1 | ../afl-showmap -m none -q -o .test-instr1 ./test-instr</span></span><br><span class="line"><span class="string">[+] All right, the instrumentation seems to be working!</span></span><br><span class="line"><span class="string">[+] All done! You can now use &#x27;</span>../afl-clang-fast<span class="string">&#x27; to compile programs.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># root @ zzz in ~/Desktop/AFL/llvm_mode on git:master o [14:19:27] </span></span><br><span class="line"><span class="string">$ llvm-config --version     </span></span><br><span class="line"><span class="string">11.1.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># root @ zzz in ~/Desktop/AFL/llvm_mode on git:master o [14:19:41] </span></span><br><span class="line"><span class="string">$ clang --version</span></span><br><span class="line"><span class="string">Ubuntu clang version 11.1.0-6</span></span><br><span class="line"><span class="string">Target: x86_64-pc-linux-gnu</span></span><br><span class="line"><span class="string">Thread model: posix</span></span><br><span class="line"><span class="string">InstalledDir: /usr/bi</span></span><br></pre></td></tr></table></figure><h2 id="二、afl-clang-fast"><a href="#二、afl-clang-fast" class="headerlink" title="二、afl-clang-fast"></a>二、<strong>afl-clang-fast</strong></h2><p>afl-clang-fast实际上是CC/CXX的wrapper。它定义了一些宏，设置了一些参数，最终调用真正的编译器（CC指代C语言编译器，CXX指代C++编译器）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Main entry point */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_TRACE_PC</span></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-clang-fast [tpcg] &quot;</span> cBRI VERSION  cRST <span class="string">&quot; by &lt;lszekeres@google.com&gt;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-clang-fast &quot;</span> cBRI VERSION  cRST <span class="string">&quot; by &lt;lszekeres@google.com&gt;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^USE_TRACE_PC */</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">        <span class="string">&quot;for clang, letting you recompile third-party code with the required runtime\n&quot;</span></span><br><span class="line">        <span class="string">&quot;instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;  CC=%s/afl-clang-fast ./configure\n&quot;</span></span><br><span class="line">        <span class="string">&quot;  CXX=%s/afl-clang-fast++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;In contrast to the traditional afl-clang tool, this version is implemented as\n&quot;</span></span><br><span class="line">        <span class="string">&quot;an LLVM pass and tends to offer improved performance with slow programs.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC and AFL_CXX. Setting\n&quot;</span></span><br><span class="line">        <span class="string">&quot;AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">        BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ANDROID__</span></span><br><span class="line">  <span class="comment">// 查找必备库&#x27;afl-llvm-rt.o&#x27; 或 &#x27;afl-llvm-pass.so&#x27;</span></span><br><span class="line">  find_obj(argv[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 设置CC或者CXX的参数</span></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line">  <span class="comment">// 调用execvp来执行CC或者CXX</span></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="keyword">char</span>**)cc_params);</span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、afl-llvm-pass"><a href="#三、afl-llvm-pass" class="headerlink" title="三、afl-llvm-pass"></a>三、<strong>afl-llvm-pass</strong></h2><p><code>afl-llvm-pass.so.cc</code>实现了 LLVM-mode 下的一个插桩 LLVM Pass</p><p>llvm_mode是怎么插桩的呢？答：IRBuilder</p><ul><li>afl-llvm-pass中，只有一个pass : <strong>AFLCoverage</strong>  该pass会在每一个基础块的第一个可插入指令处插桩，检测 <strong>控制流的覆盖程度</strong>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AFLCoverage</span> :</span> <span class="keyword">public</span> ModulePass &#123;</span><br></pre></td></tr></table></figure></li><li><code>runOnModule</code>函数首先找出当前线程上下文中所对应的IntegerType，并且打印banner  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AFLCoverage::runOnModule</span><span class="params">(Module &amp;M)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  LLVMContext &amp;C = M.getContext();</span><br><span class="line"></span><br><span class="line">  IntegerType *Int8Ty  = IntegerType::getInt8Ty(C);</span><br><span class="line">  IntegerType *Int32Ty = IntegerType::getInt32Ty(C);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Show a banner */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> be_quiet = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-llvm-pass &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lszekeres@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li>之后获取预设的插桩密度（插桩率）  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Decide instrumentation ratio */</span></span><br><span class="line"><span class="comment">// 获取代码的插桩率（0-100）</span></span><br><span class="line"><span class="keyword">char</span>* inst_ratio_str = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> inst_ratio = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (inst_ratio_str) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || !inst_ratio ||</span><br><span class="line">      inst_ratio &gt; <span class="number">100</span>)</span><br><span class="line">    FATAL(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 1 and 100)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>获取全局变量中指向共享内存的指针，以及上一个基础块的编号；这个共享内存上存放着各个控制流流经次数的计数器  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get globals for the SHM region and the previous location. Note that</span></span><br><span class="line"><span class="comment">   __afl_prev_loc is thread-local. */</span></span><br><span class="line"><span class="comment">// 指向  用于输出控制流覆盖次数的共享内存  的指针</span></span><br><span class="line">GlobalVariable *AFLMapPtr =</span><br><span class="line">    <span class="keyword">new</span> GlobalVariable(M, PointerType::get(Int8Ty, <span class="number">0</span>), <span class="literal">false</span>,</span><br><span class="line">                       GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">&quot;__afl_area_ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AFLPrevLoc 用来表示前一个基本块的编号</span></span><br><span class="line">GlobalVariable *AFLPrevLoc = <span class="keyword">new</span> GlobalVariable(</span><br><span class="line">    M, Int32Ty, <span class="literal">false</span>, GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">&quot;__afl_prev_loc&quot;</span>,</span><br><span class="line">    <span class="number">0</span>, GlobalVariable::GeneralDynamicTLSModel, <span class="number">0</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li><li>获取上述这些信息后，for循环开始遍历所有基本块，进行插桩：<ul><li>首先寻找BB中适合插入桩代码的位置，然后通过初始化 <code>IRBuilder</code> 实例执行插入：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Instrument all the things! */</span></span><br><span class="line"><span class="keyword">int</span> inst_blocks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;F : M)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;BB : F) &#123;</span><br><span class="line">    <span class="comment">// 在每一个基础块前都插入代码。先查找插入点</span></span><br><span class="line">    BasicBlock::iterator IP = BB.getFirstInsertionPt();</span><br><span class="line">    IRBuilder&lt;&gt; IRB(&amp;(*IP));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据代码插桩率，随机插桩</span></span><br><span class="line">    <span class="keyword">if</span> (AFL_R(<span class="number">100</span>) &gt;= inst_ratio) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure></li><li>插入<code>load</code>指令，获取当前基础块与上一个基础块的编号  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 随机获取当前的基础块编号</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cur_loc = AFL_R(MAP_SIZE);</span><br><span class="line">ConstantInt *CurLoc = ConstantInt::get(Int32Ty, cur_loc);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Load prev_loc */</span></span><br><span class="line"><span class="comment">// 加载上一个基础块的编号</span></span><br><span class="line">LoadInst *PrevLoc = IRB.CreateLoad(AFLPrevLoc);</span><br><span class="line"><span class="comment">// Metadata在这里可以看作是一种调试信息</span></span><br><span class="line">PrevLoc-&gt;setMetadata(M.getMDKindID(<span class="string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));</span><br><span class="line">Value *PrevLocCasted = IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());</span><br></pre></td></tr></table></figure></li><li>插入<code>load</code>指令，获取共享内存地址；并通过上述两个编号，调用 <code>CreateGEP</code> 函数获取共享内存中指定index的地址  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Load SHM pointer */</span></span><br><span class="line">  <span class="comment">// 获取指向共享内存的指针</span></span><br><span class="line">  LoadInst *MapPtr = IRB.CreateLoad(AFLMapPtr);</span><br><span class="line">  MapPtr-&gt;setMetadata(M.getMDKindID(<span class="string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));</span><br><span class="line">  <span class="comment">// GEP: GetElementPtr</span></span><br><span class="line">  <span class="comment">// 根据当前基础块与上一个基础块的编号，计算指向特定地址的指针</span></span><br><span class="line">  Value *MapPtrIdx =</span><br><span class="line">      IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));</span><br></pre></td></tr></table></figure></li><li>插入<code>load</code>指令，获取对应index地址的值；同时插入<code>add</code>指令，使该地址上的计数器递增；再插入<code>store</code>指令写入新值，并更新共享内存  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Update bitmap */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该指针上的counter值自增一</span></span><br><span class="line">LoadInst *Counter = IRB.CreateLoad(MapPtrIdx);</span><br><span class="line">Counter-&gt;setMetadata(M.getMDKindID(<span class="string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));</span><br><span class="line">Value *Incr = IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, <span class="number">1</span>));</span><br><span class="line">IRB.CreateStore(Incr, MapPtrIdx)</span><br><span class="line">    -&gt;setMetadata(M.getMDKindID(<span class="string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));</span><br></pre></td></tr></table></figure></li><li>右移<code>cur_loc</code> ，插入<code>store</code>指令，设置<code>__afl_prev_loc</code>，作为下一个插桩基础块的 “上一个基础块编号”  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set prev_loc to cur_loc &gt;&gt; 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前基础块的编号右移1位后，存入AFLPrevLoc</span></span><br><span class="line">StoreInst *Store =</span><br><span class="line">    IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc &gt;&gt; <span class="number">1</span>), AFLPrevLoc);</span><br><span class="line">Store-&gt;setMetadata(M.getMDKindID(<span class="string">&quot;nosanitize&quot;</span>), MDNode::get(C, None));</span><br><span class="line"></span><br><span class="line">inst_blocks++;</span><br></pre></td></tr></table></figure>  之所以要将当前基础块编号右移一位，是因为当基础块跳转<code>A-&gt;A</code>和<code>B-&gt;B</code>，或<code>A-&gt;B</code>和<code>B-&gt;A</code>，它们的编号做异或后的结果是相同的，无法区分，所以其中一个编号要右移一位。</li><li>当前基础块插桩完成，开始遍历下一个基础块</li></ul></li><li>当插桩完成后，输出相关信息并返回  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Say something nice. */</span></span><br><span class="line"><span class="comment">// 完成插桩</span></span><br><span class="line"><span class="keyword">if</span> (!be_quiet) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!inst_blocks) WARNF(<span class="string">&quot;No instrumentation targets found.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> OKF(<span class="string">&quot;Instrumented %u locations (%s mode, ratio %u%%).&quot;</span>,</span><br><span class="line">           inst_blocks, getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>) ? <span class="string">&quot;hardened&quot;</span> :</span><br><span class="line">           ((getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) ?</span><br><span class="line">            <span class="string">&quot;ASAN/MSAN&quot;</span> : <span class="string">&quot;non-hardened&quot;</span>), inst_ratio);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li><li>总结：<ul><li>该pass插桩主要完成以下几点：<ul><li>随机计算出当前基础块的编号</li><li>通过当前基础块编号与上一个基础块编号，计算出共享内存中对应的索引值idx  这块共享内存的实质就是一个<code>hashtable</code></li><li>__afl_area_ptr[idx]++</li><li>设置<code>__afl_prev_loc</code>为当前的基础块编号，当前基础块插桩结束，准备插桩下一个基础块</li></ul></li><li>作用：<ul><li>当有控制流到达当前基础块时，其共享内存对应位置，用于计数的值就会加一</li><li>而AFL可以根据该共享内存上的数据来判断控制流的覆盖程度，调整输入样本，使控制流能够覆盖更多的基础块</li></ul></li><li>缺点：<ul><li>编号存在碰撞。不过根据AFL文档中的介绍，对于不是很复杂的目标，碰撞概率还是可以接受的  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Branch cnt | Colliding tuples | Example targets</span><br><span class="line">------------+------------------+-----------------</span><br><span class="line">      <span class="number">1</span>,<span class="number">000</span> | <span class="number">0.75</span>%            | giflib, lzo</span><br><span class="line">      <span class="number">2</span>,<span class="number">000</span> | <span class="number">1.5</span>%             | zlib, tar, xz</span><br><span class="line">      <span class="number">5</span>,<span class="number">000</span> | <span class="number">3.5</span>%             | libpng, libwebp</span><br><span class="line">     <span class="number">10</span>,<span class="number">000</span> | <span class="number">7</span>%               | libxml</span><br><span class="line">     <span class="number">20</span>,<span class="number">000</span> | <span class="number">14</span>%              | sqlite</span><br><span class="line">     <span class="number">50</span>,<span class="number">000</span> | <span class="number">30</span>%              | -</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>示例  设置<code>export AFL_PATH=/root/Desktop/AFL</code>，使其可以找到<code>afl-llvm-rt.o</code> 和 <code>afl-llvm-pass.so</code>  使用<code>afl-clang-fast</code>，对源码进行插桩，得到插桩后的IR指令  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@zzZ:/home/zzz/Desktop/AFL# ./afl-clang-fast -S -emit-llvm test.c </span><br><span class="line">afl-clang-fast <span class="number">2.57b</span> by &lt;lszekeres@google.com&gt;</span><br><span class="line">afl-llvm-pass <span class="number">2.57b</span> by &lt;lszekeres@google.com&gt;</span><br><span class="line">[+] Instrumented <span class="number">5</span> locations (non-hardened mode, ratio <span class="number">100</span>%).</span><br><span class="line">root@zzZ:/home/zzz/Desktop/AFL<span class="meta"># gedit test.ll</span></span><br></pre></td></tr></table></figure>  其中，源码test.c：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> *null = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, buffer, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">if</span> (buffer[<span class="number">0</span>] == <span class="string">&#x27;6&#x27;</span> &amp;&amp; buffer[<span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; buffer[<span class="number">2</span>] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">    i = *null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No problem&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  插桩后的IR指令：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">; ModuleID = <span class="string">&#x27;test.c&#x27;</span></span><br><span class="line">source_filename = <span class="string">&quot;test.c&quot;</span></span><br><span class="line">target datalayout = <span class="string">&quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line">target triple = <span class="string">&quot;x86_64-pc-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line">@.str = <span class="keyword">private</span> unnamed_addr constant [<span class="number">11</span> x i8] c<span class="string">&quot;No problem\00&quot;</span>, align <span class="number">1</span></span><br><span class="line">@__afl_area_ptr = external global i8*</span><br><span class="line">@__afl_prev_loc = external <span class="keyword">thread_local</span> global i32</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local i32 @main(i32 %<span class="number">0</span>, i8** %<span class="number">1</span>) #<span class="number">0</span> !dbg !<span class="number">7</span> &#123;</span><br><span class="line">  %<span class="number">3</span> = load i32, i32* @__afl_prev_loc, align <span class="number">4</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">4</span> = load i8*, i8** @__afl_area_ptr, align <span class="number">8</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">5</span> = <span class="keyword">xor</span> i32 %<span class="number">3</span>, <span class="number">3216</span></span><br><span class="line">  %<span class="number">6</span> = getelementptr i8, i8* %<span class="number">4</span>, i32 %<span class="number">5</span></span><br><span class="line">  %<span class="number">7</span> = load i8, i8* %<span class="number">6</span>, align <span class="number">1</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">8</span> = add i8 %<span class="number">7</span>, <span class="number">1</span></span><br><span class="line">  store i8 %<span class="number">8</span>, i8* %<span class="number">6</span>, align <span class="number">1</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  store i32 <span class="number">1608</span>, i32* @__afl_prev_loc, align <span class="number">4</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">9</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">10</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">11</span> = alloca i8**, align <span class="number">8</span></span><br><span class="line">  %<span class="number">12</span> = alloca [<span class="number">3</span> x i8], align <span class="number">1</span></span><br><span class="line">  %<span class="number">13</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">14</span> = alloca i32*, align <span class="number">8</span></span><br><span class="line">  store i32 <span class="number">0</span>, i32* %<span class="number">9</span>, align <span class="number">4</span></span><br><span class="line">  store i32 %<span class="number">0</span>, i32* %<span class="number">10</span>, align <span class="number">4</span></span><br><span class="line">  call <span class="keyword">void</span> @llvm.dbg.declare(metadata i32* %<span class="number">10</span>, metadata !<span class="number">14</span>, metadata !DIExpression()), !dbg !<span class="number">15</span></span><br><span class="line">  store i8** %<span class="number">1</span>, i8*** %<span class="number">11</span>, align <span class="number">8</span></span><br><span class="line">  call <span class="keyword">void</span> @llvm.dbg.declare(metadata i8*** %<span class="number">11</span>, metadata !<span class="number">16</span>, metadata !DIExpression()), !dbg !<span class="number">17</span></span><br><span class="line">  call <span class="keyword">void</span> @llvm.dbg.declare(metadata [<span class="number">3</span> x i8]* %<span class="number">12</span>, metadata !<span class="number">18</span>, metadata !DIExpression()), !dbg !<span class="number">22</span></span><br><span class="line">  %<span class="number">15</span> = bitcast [<span class="number">3</span> x i8]* %<span class="number">12</span> to i8*, !dbg !<span class="number">22</span></span><br><span class="line">  call <span class="keyword">void</span> @llvm.<span class="built_in">memset</span>.p0i8.i64(i8* align <span class="number">1</span> %<span class="number">15</span>, i8 <span class="number">0</span>, i64 <span class="number">3</span>, i1 <span class="literal">false</span>), !dbg !<span class="number">22</span></span><br><span class="line">  call <span class="keyword">void</span> @llvm.dbg.declare(metadata i32* %<span class="number">13</span>, metadata !<span class="number">23</span>, metadata !DIExpression()), !dbg !<span class="number">24</span></span><br><span class="line">  call <span class="keyword">void</span> @llvm.dbg.declare(metadata i32** %<span class="number">14</span>, metadata !<span class="number">25</span>, metadata !DIExpression()), !dbg !<span class="number">27</span></span><br><span class="line">  store i32* null, i32** %<span class="number">14</span>, align <span class="number">8</span>, !dbg !<span class="number">27</span></span><br><span class="line">  %<span class="number">16</span> = getelementptr inbounds [<span class="number">3</span> x i8], [<span class="number">3</span> x i8]* %<span class="number">12</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>, !dbg !<span class="number">28</span></span><br><span class="line">  %<span class="number">17</span> = call i64 @read(i32 <span class="number">0</span>, i8* %<span class="number">16</span>, i64 <span class="number">3</span>), !dbg !<span class="number">29</span></span><br><span class="line">  %<span class="number">18</span> = getelementptr inbounds [<span class="number">3</span> x i8], [<span class="number">3</span> x i8]* %<span class="number">12</span>, i64 <span class="number">0</span>, i64 <span class="number">0</span>, !dbg !<span class="number">30</span></span><br><span class="line">  %<span class="number">19</span> = load i8, i8* %<span class="number">18</span>, align <span class="number">1</span>, !dbg !<span class="number">30</span></span><br><span class="line">  %<span class="number">20</span> = sext i8 %<span class="number">19</span> to i32, !dbg !<span class="number">30</span></span><br><span class="line">  %<span class="number">21</span> = icmp eq i32 %<span class="number">20</span>, <span class="number">54</span>, !dbg !<span class="number">32</span></span><br><span class="line">  br i1 %<span class="number">21</span>, label %<span class="number">22</span>, label %<span class="number">53</span>, !dbg !<span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="number">22</span>:                                               ; preds = %<span class="number">2</span></span><br><span class="line">  %<span class="number">23</span> = load i32, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">34</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">24</span> = load i8*, i8** @__afl_area_ptr, align <span class="number">8</span>, !dbg !<span class="number">34</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">25</span> = <span class="keyword">xor</span> i32 %<span class="number">23</span>, <span class="number">40101</span>, !dbg !<span class="number">34</span></span><br><span class="line">  %<span class="number">26</span> = getelementptr i8, i8* %<span class="number">24</span>, i32 %<span class="number">25</span>, !dbg !<span class="number">34</span></span><br><span class="line">  %<span class="number">27</span> = load i8, i8* %<span class="number">26</span>, align <span class="number">1</span>, !dbg !<span class="number">34</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">28</span> = add i8 %<span class="number">27</span>, <span class="number">1</span>, !dbg !<span class="number">34</span></span><br><span class="line">  store i8 %<span class="number">28</span>, i8* %<span class="number">26</span>, align <span class="number">1</span>, !dbg !<span class="number">34</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  store i32 <span class="number">20050</span>, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">34</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">29</span> = getelementptr inbounds [<span class="number">3</span> x i8], [<span class="number">3</span> x i8]* %<span class="number">12</span>, i64 <span class="number">0</span>, i64 <span class="number">1</span>, !dbg !<span class="number">34</span></span><br><span class="line">  %<span class="number">30</span> = load i8, i8* %<span class="number">29</span>, align <span class="number">1</span>, !dbg !<span class="number">34</span></span><br><span class="line">  %<span class="number">31</span> = sext i8 %<span class="number">30</span> to i32, !dbg !<span class="number">34</span></span><br><span class="line">  %<span class="number">32</span> = icmp eq i32 %<span class="number">31</span>, <span class="number">50</span>, !dbg !<span class="number">35</span></span><br><span class="line">  br i1 %<span class="number">32</span>, label %<span class="number">33</span>, label %<span class="number">53</span>, !dbg !<span class="number">36</span></span><br><span class="line"></span><br><span class="line"><span class="number">33</span>:                                               ; preds = %<span class="number">22</span></span><br><span class="line">  %<span class="number">34</span> = load i32, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">37</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">35</span> = load i8*, i8** @__afl_area_ptr, align <span class="number">8</span>, !dbg !<span class="number">37</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">36</span> = <span class="keyword">xor</span> i32 %<span class="number">34</span>, <span class="number">39935</span>, !dbg !<span class="number">37</span></span><br><span class="line">  %<span class="number">37</span> = getelementptr i8, i8* %<span class="number">35</span>, i32 %<span class="number">36</span>, !dbg !<span class="number">37</span></span><br><span class="line">  %<span class="number">38</span> = load i8, i8* %<span class="number">37</span>, align <span class="number">1</span>, !dbg !<span class="number">37</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">39</span> = add i8 %<span class="number">38</span>, <span class="number">1</span>, !dbg !<span class="number">37</span></span><br><span class="line">  store i8 %<span class="number">39</span>, i8* %<span class="number">37</span>, align <span class="number">1</span>, !dbg !<span class="number">37</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  store i32 <span class="number">19967</span>, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">37</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">40</span> = getelementptr inbounds [<span class="number">3</span> x i8], [<span class="number">3</span> x i8]* %<span class="number">12</span>, i64 <span class="number">0</span>, i64 <span class="number">2</span>, !dbg !<span class="number">37</span></span><br><span class="line">  %<span class="number">41</span> = load i8, i8* %<span class="number">40</span>, align <span class="number">1</span>, !dbg !<span class="number">37</span></span><br><span class="line">  %<span class="number">42</span> = sext i8 %<span class="number">41</span> to i32, !dbg !<span class="number">37</span></span><br><span class="line">  %<span class="number">43</span> = icmp eq i32 %<span class="number">42</span>, <span class="number">97</span>, !dbg !<span class="number">38</span></span><br><span class="line">  br i1 %<span class="number">43</span>, label %<span class="number">44</span>, label %<span class="number">53</span>, !dbg !<span class="number">39</span></span><br><span class="line"></span><br><span class="line"><span class="number">44</span>:                                               ; preds = %<span class="number">33</span></span><br><span class="line">  %<span class="number">45</span> = load i32, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">40</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">46</span> = load i8*, i8** @__afl_area_ptr, align <span class="number">8</span>, !dbg !<span class="number">40</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">47</span> = <span class="keyword">xor</span> i32 %<span class="number">45</span>, <span class="number">25417</span>, !dbg !<span class="number">40</span></span><br><span class="line">  %<span class="number">48</span> = getelementptr i8, i8* %<span class="number">46</span>, i32 %<span class="number">47</span>, !dbg !<span class="number">40</span></span><br><span class="line">  %<span class="number">49</span> = load i8, i8* %<span class="number">48</span>, align <span class="number">1</span>, !dbg !<span class="number">40</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">50</span> = add i8 %<span class="number">49</span>, <span class="number">1</span>, !dbg !<span class="number">40</span></span><br><span class="line">  store i8 %<span class="number">50</span>, i8* %<span class="number">48</span>, align <span class="number">1</span>, !dbg !<span class="number">40</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  store i32 <span class="number">12708</span>, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">40</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">51</span> = load i32*, i32** %<span class="number">14</span>, align <span class="number">8</span>, !dbg !<span class="number">40</span></span><br><span class="line">  %<span class="number">52</span> = load i32, i32* %<span class="number">51</span>, align <span class="number">4</span>, !dbg !<span class="number">42</span></span><br><span class="line">  store i32 %<span class="number">52</span>, i32* %<span class="number">13</span>, align <span class="number">4</span>, !dbg !<span class="number">43</span></span><br><span class="line">  br label %<span class="number">53</span>, !dbg !<span class="number">44</span></span><br><span class="line"></span><br><span class="line"><span class="number">53</span>:                                               ; preds = %<span class="number">44</span>, %<span class="number">33</span>, %<span class="number">22</span>, %<span class="number">2</span></span><br><span class="line">  %<span class="number">54</span> = load i32, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">45</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">55</span> = load i8*, i8** @__afl_area_ptr, align <span class="number">8</span>, !dbg !<span class="number">45</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">56</span> = <span class="keyword">xor</span> i32 %<span class="number">54</span>, <span class="number">59797</span>, !dbg !<span class="number">45</span></span><br><span class="line">  %<span class="number">57</span> = getelementptr i8, i8* %<span class="number">55</span>, i32 %<span class="number">56</span>, !dbg !<span class="number">45</span></span><br><span class="line">  %<span class="number">58</span> = load i8, i8* %<span class="number">57</span>, align <span class="number">1</span>, !dbg !<span class="number">45</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">59</span> = add i8 %<span class="number">58</span>, <span class="number">1</span>, !dbg !<span class="number">45</span></span><br><span class="line">  store i8 %<span class="number">59</span>, i8* %<span class="number">57</span>, align <span class="number">1</span>, !dbg !<span class="number">45</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  store i32 <span class="number">29898</span>, i32* @__afl_prev_loc, align <span class="number">4</span>, !dbg !<span class="number">45</span>, !nosanitize !<span class="number">2</span></span><br><span class="line">  %<span class="number">60</span> = call i32 @<span class="built_in">puts</span>(i8* getelementptr inbounds ([<span class="number">11</span> x i8], [<span class="number">11</span> x i8]* @.str, i64 <span class="number">0</span>, i64 <span class="number">0</span>)), !dbg !<span class="number">45</span></span><br><span class="line">  %<span class="number">61</span> = load i32, i32* %<span class="number">9</span>, align <span class="number">4</span>, !dbg !<span class="number">46</span></span><br><span class="line">  ret i32 %<span class="number">61</span>, !dbg !<span class="number">46</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nounwind readnone speculatable willreturn</span><br><span class="line">declare <span class="keyword">void</span> @llvm.dbg.declare(metadata, metadata, metadata) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: argmemonly nounwind willreturn writeonly</span><br><span class="line">declare <span class="keyword">void</span> @llvm.<span class="built_in">memset</span>.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #<span class="number">2</span></span><br><span class="line"></span><br><span class="line">declare dso_local i64 @read(i32, i8*, i64) #<span class="number">3</span></span><br><span class="line"></span><br><span class="line">declare dso_local i32 @<span class="built_in">puts</span>(i8*) #<span class="number">3</span></span><br><span class="line"></span><br><span class="line">attributes #<span class="number">0</span> = &#123; noinline nounwind optnone uwtable <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span>=<span class="string">&quot;0&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line">attributes #<span class="number">1</span> = &#123; nounwind readnone speculatable willreturn &#125;</span><br><span class="line">attributes #<span class="number">2</span> = &#123; argmemonly nounwind willreturn writeonly &#125;</span><br><span class="line">attributes #<span class="number">3</span> = &#123; <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">!llvm.dbg.cu = !&#123;!<span class="number">0</span>&#125;</span><br><span class="line">!llvm.<span class="keyword">module</span>.flags = !&#123;!<span class="number">3</span>, !<span class="number">4</span>, !<span class="number">5</span>&#125;</span><br><span class="line">!llvm.ident = !&#123;!<span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = distinct !DICompileUnit(language: DW_LANG_C99, file: !<span class="number">1</span>, producer: <span class="string">&quot;Ubuntu clang version 11.1.0-6&quot;</span>, isOptimized: <span class="literal">false</span>, runtimeVersion: <span class="number">0</span>, emissionKind: FullDebug, enums: !<span class="number">2</span>, splitDebugInlining: <span class="literal">false</span>, nameTableKind: None)</span><br><span class="line">!<span class="number">1</span> = !DIFile(filename: <span class="string">&quot;test.c&quot;</span>, directory: <span class="string">&quot;/root/Desktop/AFL&quot;</span>)</span><br><span class="line">!<span class="number">2</span> = !&#123;&#125;</span><br><span class="line">!<span class="number">3</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">&quot;Dwarf Version&quot;</span>, i32 <span class="number">4</span>&#125;</span><br><span class="line">!<span class="number">4</span> = !&#123;i32 <span class="number">2</span>, !<span class="string">&quot;Debug Info Version&quot;</span>, i32 <span class="number">3</span>&#125;</span><br><span class="line">!<span class="number">5</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">&quot;wchar_size&quot;</span>, i32 <span class="number">4</span>&#125;</span><br><span class="line">!<span class="number">6</span> = !&#123;!<span class="string">&quot;Ubuntu clang version 11.1.0-6&quot;</span>&#125;</span><br><span class="line"><span class="comment">/// other informations</span></span><br></pre></td></tr></table></figure>  可以看到插入了的IR代码：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%<span class="number">1</span> = load i32* @__afl_prev_loc, align <span class="number">4</span>, !nosanitize !<span class="number">25</span></span><br><span class="line">%<span class="number">2</span> = load i8** @__afl_area_ptr, align <span class="number">8</span>, !nosanitize !<span class="number">25</span></span><br><span class="line">%<span class="number">3</span> = <span class="keyword">xor</span> i32 %<span class="number">1</span>, <span class="number">47106</span></span><br><span class="line">%<span class="number">4</span> = sext i32 %<span class="number">3</span> to i64</span><br><span class="line">%<span class="number">5</span> = getelementptr i8* %<span class="number">2</span>, i64 %<span class="number">4</span></span><br><span class="line">%<span class="number">6</span> = load i8* %<span class="number">5</span>, align <span class="number">1</span>, !nosanitize !<span class="number">25</span></span><br><span class="line">%<span class="number">7</span> = add i8 %<span class="number">6</span>, <span class="number">1</span></span><br><span class="line">store i8 %<span class="number">7</span>, i8* %<span class="number">5</span>, align <span class="number">1</span>, !nosanitize !<span class="number">25</span></span><br><span class="line">store i32 <span class="number">23553</span>, i32* @__afl_prev_loc, align <span class="number">4</span>, !nosanitize !<span class="number">25</span></span><br></pre></td></tr></table></figure>  其中，<code>47106</code>是当前基本块的随机编号（key），<code>23553</code>是<code>47106 &gt;&gt; 1</code> 的结果</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;~~&lt;/p&gt;</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="AFL" scheme="http://example.com/tags/AFL/"/>
    
    <category term="Instrumentation" scheme="http://example.com/tags/Instrumentation/"/>
    
  </entry>
  
  <entry>
    <title>AFL插桩（一）概述与普通插桩</title>
    <link href="http://example.com/2022/05/15/AFL%E6%8F%92%E6%A1%A9%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E6%8F%92%E6%A1%A9/"/>
    <id>http://example.com/2022/05/15/AFL%E6%8F%92%E6%A1%A9%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E6%8F%92%E6%A1%A9/</id>
    <published>2022-05-15T02:00:00.000Z</published>
    <updated>2022-09-22T01:24:46.005Z</updated>
    
    <content type="html"><![CDATA[<p>~~</p><span id="more"></span><h2 id="一、插桩基础"><a href="#一、插桩基础" class="headerlink" title="一、插桩基础"></a>一、插桩基础</h2><ul><li>什么是插桩？  在AFL编译文件时候afl-gcc或其他插桩模块会在规定位置插入桩代码，可以理解为一个个的探针(但是没有暂停功能)，在后续fuzz的过程中会根据这些桩代码进行路径探索，测试，获取覆盖率等。</li></ul><p>详细了解插桩前，回顾下编译的四个阶段：</p><ul><li>预处理阶段：预处理器 (<code>cpp</code>) 根据以 <em><strong>#</strong></em> 开头的代码来修改原始的 C 程序。比如 <em>hello world</em> 程序将 <em>#include</em> 命令告诉预处理器读取 <em>stdio.h</em> 的内容，并插入到 <em>hello world</em> 程序中生成 <em>hello.i</em> 文件。</li><li>编译阶段：编译器 (<code>cc1</code>) 将 <em>hello.i</em> 文件翻译成汇编文件 <em>hello.s</em>。</li><li>汇编阶段：汇编器 (<code>as</code>) 将 <em>hello.s</em> 文件中的汇编指令翻译成机器语言指令，并把这些指令打包成_可重定位目标文件_，并按照<code>ELF</code>文件格式生成 <em>hello.o</em> 文件。</li><li>链接阶段：<em>hello world</em> 程序调用了 <em>printf</em> 函数，但是我们的源文件里并没有这个函数的代码，它是一个 C 语言标准库里的代码。链接阶段就由连接器 (<code>ld</code>) 来确定 <em>printf</em> 函数的地址，从而确保程序在执行时能正确调用 <em>printf</em> 函数。</li></ul><p><code>gcc</code>其实也是上面几个工具的一个 wrapper，首先<code>gcc</code>会调用<code>cpp</code>对代码进行预处理，然后将预处理后的文件交给<code>cc1</code>执行编译生成汇编文件，汇编器<code>as</code>将汇编文件作为输入生成机器码–目标文件，最后由连接器<code>ld</code>将目标文件链接生成可执行文件。</p><ul><li><p>一些名词：</p><ul><li>tuple 信息：源基本块 和 目标基本块 的配对组合称为 tuple</li><li>ASAN和MSAN：ASAN用来检测 **释放后使用(use-after-free)<strong>、</strong>多次释放(double-free)<strong>、</strong>缓冲区溢出(buffer overflows)和下溢(underflows)**的内存问题；对于未初始化的内存，需要使用MSAN</li><li>fork server：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们知道，在fuzz的时候，编译target完成后，就可以通过afl-fuzz开始fuzzing了。其大致思路是，对输入的seed文件不断地变化，并将这些mutated input喂给target执行，检查是否会造成崩溃。因此，fuzzing涉及到大量的fork和执行target的过程。</span><br><span class="line">为了更高效地进行上述过程，AFL实现了一套fork server机制。其基本思路是：启动target进程后，target会运行一个fork server；fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作。这样设计的最大好处，就是不需要调用execve()，从而节省了载入目标文件和库、解析符号地址等重复性工作。</span><br></pre></td></tr></table></figure></li></ul></li><li><p>AFL插桩模块</p><ul><li><code>afl-as.h, afl-as.c, afl-gcc.c</code>：普通插桩模式，针对源码插桩，编译器可以使用gcc，clang</li><li><code>llvm_mode</code>：llvm 插桩模式，针对源码插桩，编译器使用clang</li><li><code>qemu_mode</code>：qemu 插桩模式，针对二进制文件插桩</li></ul><p>  <img src="/2022/05/15/AFL%E6%8F%92%E6%A1%A9%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E6%8F%92%E6%A1%A9/Untitled.png"></p><p>  普通模式和 llvm 模式是针对目标程序提供源码的情况，显然相较汇编级的普通模式插桩，编译级的 llvm 模式插桩包含更多优化，在性能上会更佳些，而对仅提供二进制文件的目标程序则需借助 qemu 模式，其性能是最低的。</p></li><li><p>插桩目的：</p><ul><li>记录目标程序执行过程中的 tuple 信息，需保证在每个基本块上都有插入</li><li>必要的初始操作以及维护一个 forkserver（完成fork以及继续执行目标程序的操作）</li></ul></li></ul><p>本质上，AFL并不是独立的编译或汇编工具，而是一个wrapper（包装），进行插桩，最终还是要调用gcc完成。</p><h2 id="二、AFL的gcc-—-afl-gcc"><a href="#二、AFL的gcc-—-afl-gcc" class="headerlink" title="二、AFL的gcc  —  afl-gcc"></a>二、AFL的gcc  —  afl-gcc</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p><code>afl-gcc</code> 是GCC 或 clang 的一个wrapper（封装），只是会自动加上 <code>-B /usr/local/lib/afl -g -O3</code></p><p><code>afl-gcc</code>的主要作用是实现对于关键节点的代码插桩，属于汇编级，从而记录程序执行路径之类的关键信息，对程序的运行情况进行反馈。</p><h3 id="2、源码"><a href="#2、源码" class="headerlink" title="2、源码"></a>2、源码</h3><p>关键变量：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> u8*  as_path;                <span class="comment">/* Path to the AFL &#x27;as&#x27; wrapper      */</span></span><br><span class="line"><span class="keyword">static</span> u8** cc_params;              <span class="comment">/* Parameters passed to the real CC  */</span></span><br><span class="line"><span class="keyword">static</span> u32  cc_par_cnt = <span class="number">1</span>;         <span class="comment">/* Param count, including argv0      */</span></span><br><span class="line"><span class="keyword">static</span> u8   be_quiet,               <span class="comment">/* Quiet mode                        */</span></span><br><span class="line">            clang_mode;             <span class="comment">/* Invoked as afl-clang*?            */</span></span><br></pre></td></tr></table></figure><p>主要逻辑函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">find_as(argv[<span class="number">0</span>]);</span><br><span class="line">edit_params(argc, argv);</span><br><span class="line">execvp(cc_params[<span class="number">0</span>], (<span class="keyword">char</span>**)cc_params);</span><br></pre></td></tr></table></figure><ul><li><code>find_as(argv[0])</code><ul><li>作用：查找使用的汇编器<code>afl-as</code></li></ul></li><li><code>edit_params(argc, argv)</code><ul><li>作用：处理传入的编译参数，将确定好的参数放入 <code>cc_params[]</code> 数组</li></ul></li><li>调用 <code>execvp(cc_params[0], (cahr**)cc_params)</code> 执行 <code>afl-gcc</code></li></ul><h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p><code>afl-gcc.c</code> 用于生成 afl-gcc 文件，其实质是 gcc 的包装，并非一个独立的改进的 gcc 编译器。其指定了编译器的搜索路径，编译器默认优先使用该路径中的汇编器和链接器，即 <code>afl-as</code>，因此，实际的插桩工作发生在汇编的时候。</p><h2 id="三、AFL的普通插桩-—-afl-as-c"><a href="#三、AFL的普通插桩-—-afl-as-c" class="headerlink" title="三、AFL的普通插桩  —  afl-as.c"></a>三、AFL的普通插桩  —  afl-as.c</h2><h3 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h3><p><code>afl-as</code> 是 GNU as 的一个wrapper（封装），唯一目的是预处理由 GCC/clang 生成的汇编文件，并插入 <code>afl-as.h</code> 提供的插桩代码。 </p><p>使用 <code>afl-gcc / afl-clang</code> 编译程序时，工具链会自动调用它。该wapper的目标并不是为了实现向 <code>.s</code> 或 <code>asm</code> 代码块中插入手写的代码。</p><h3 id="2、源码-1"><a href="#2、源码-1" class="headerlink" title="2、源码"></a>2、源码</h3><p>关键变量：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> u8** as_params;          <span class="comment">/* Parameters passed to the real &#x27;as&#x27;   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8*  input_file;         <span class="comment">/* Originally specified input file      */</span></span><br><span class="line"><span class="keyword">static</span> u8*  modified_file;      <span class="comment">/* Instrumented file for the real &#x27;as&#x27;  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8   be_quiet,           <span class="comment">/* Quiet mode (no stderr output)        */</span></span><br><span class="line">            clang_mode,         <span class="comment">/* Running in clang mode?              是否运行在clang模式 */</span></span><br><span class="line">            pass_thru,          <span class="comment">/* Just pass data through?             只通过数据 */</span></span><br><span class="line">            just_version,       <span class="comment">/* Just show version?                  只显示版本 */</span></span><br><span class="line">            sanitizer;          <span class="comment">/* Using ASAN / MSAN                   是否使用ASAN/MSAN */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u32  inst_ratio = <span class="number">100</span>,   <span class="comment">/* Instrumentation probability (%)     插桩覆盖率（密度） */</span></span><br><span class="line">            as_par_cnt = <span class="number">1</span>;     <span class="comment">/* Number of params to &#x27;as&#x27;             */</span></span><br></pre></td></tr></table></figure><p><strong>main函数：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Main entry point */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  s32 pid;</span><br><span class="line">  u32 rand_seed;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  u8* inst_ratio_str = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);     <span class="comment">//插桩密度（1-100）</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line"></span><br><span class="line">  clang_mode = !!getenv(CLANG_ENV_VAR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-as &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It is a wrapper around GNU &#x27;as&#x27;,\n&quot;</span></span><br><span class="line">         <span class="string">&quot;executed by the toolchain whenever using afl-gcc or afl-clang. You probably\n&quot;</span></span><br><span class="line">         <span class="string">&quot;don&#x27;t want to run this program directly.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;Rarely, when dealing with extremely complex projects, it may be advisable to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;set AFL_INST_RATIO to a value less than 100 in order to reduce the odds of\n&quot;</span></span><br><span class="line">         <span class="string">&quot;instrumenting every discovered branch.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;tv, &amp;tz);                          <span class="comment">//获取当前时间</span></span><br><span class="line">  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();   <span class="comment">//根据当前时间生产随机种子</span></span><br><span class="line">  srandom(rand_seed);</span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line">  <span class="keyword">if</span> (inst_ratio_str) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || inst_ratio &gt; <span class="number">100</span>) </span><br><span class="line">      FATAL(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(AS_LOOP_ENV_VAR))</span><br><span class="line">    FATAL(<span class="string">&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  setenv(AS_LOOP_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When compiling with ASAN, we don&#x27;t have a particularly elegant way to skip</span></span><br><span class="line"><span class="comment">     ASAN-specific branches. But we can probabilistically compensate for</span></span><br><span class="line"><span class="comment">     that... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//当使用ASAN或MSAN时，AFL无法识别出特定的分支，导致插入很多无意义的桩代码，所以直接暴力地将插桩概率/3</span></span><br><span class="line">    sanitizer = <span class="number">1</span>;</span><br><span class="line">    inst_ratio /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!just_version) add_instrumentation();        <span class="comment">//插桩函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(pid = fork())) &#123;</span><br><span class="line">    execvp(as_params[<span class="number">0</span>], (<span class="keyword">char</span>**)as_params);</span><br><span class="line">    FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) unlink(modified_file);</span><br><span class="line">  <span class="built_in">exit</span>(WEXITSTATUS(status));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要步骤：</strong></p><ol><li>获取插桩密度，即<code>AFL_INST_RATIO</code>环境变量：控制检测每个分支的概率，取值为0到100%，设置为0时则只检测函数入口的跳转，而不会检测函数分支的跳转</li><li><code>gettimeofday(&amp;tv, &amp;tz)</code>：获取时区和时间，当前时间作为种子生成随机数，该随机数用来标识分支 ****key。 <code>srandom()</code>的随机种子 <code>rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();</code></li><li><code>edit_params(argc, argv)</code>：函数进行参数处理</li><li><code>add_instrumentation</code>函数进行<strong>插桩</strong>： 作用：处理输入文件，生成<code>modified_file</code> ，将<code>instrumentation</code>插入所有适当的位置。（注：<code>afl-as</code> 只对代码段进行插桩） 插桩步骤：<ol><li>打开<code>input_file</code>，以及<code>modified_file</code> ，做一些文件读写检查</li><li>进入while循环，读取<code>input_file</code>每一行 跳过标签、宏、注释、ad-hoc asm blocks、Intel blocks <strong>何时插桩？</strong><ul><li>第一处：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">        instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">      instrument_next = <span class="number">0</span>;</span><br><span class="line">      ins_lines++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>  这些判断变量涉及到函数后面的代码，其中<ul><li><code>instr_ok</code>：判断是否为代码</li><li><code>instrument_next</code>：是否为basic block，而afl-as 需要在每个基本块（basic block）中插桩<ul><li>basic block 标识符包含了冒号和点号，以点开头，中间是数字和字母，可以以此为判断是否为basic block依据（<code>^.L0:</code>或者 <code>^.LBB0_0:</code>这样的branch label）  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">1</span>, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"><span class="keyword">if</span> (!skip_next_label) instrument_next = <span class="number">1</span>; <span class="keyword">else</span> skip_next_label = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Function label (always instrumented, deferred mode). */</span></span><br><span class="line"></span><br><span class="line">        instrument_next = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>如果存在冒号，但不以点开头，则是函数<code>^func:</code>，直接设置<code>instrument_next = 1</code></li></ul></li><li>其他skip变量指跳过一些不需要的块</li></ul></li><li>第二处：  根据条件分支判断是否为基本块（需要插桩）  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Conditional branch instruction (jnz, etc). We append the instrumentation</span></span><br><span class="line"><span class="comment">       right after the branch (to instrument the not-taken path) and at the</span></span><br><span class="line"><span class="comment">       branch destination label (handled later on). */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">        ins_lines++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol> AFL插桩时重点关注的内容包括：<code>^main</code>， <code>^.L0</code>，<code>^.LBB0_0</code>，<code>^\tjnz foo</code> （_main函数， gcc和clang下的分支标记，条件跳转分支标记），这些内容通常标志了程序的流程变化，因此AFL会重点在这些位置进行插桩 完整<code>add_instrumentation</code>函数源码及注释如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Process input file, generate modified_file. Insert instrumentation in all</span></span><br><span class="line"><span class="comment">   the appropriate places. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_instrumentation</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> u8 line[MAX_LINE];</span><br><span class="line"></span><br><span class="line">  FILE* inf;</span><br><span class="line">  FILE* outf;</span><br><span class="line">  s32 outfd;</span><br><span class="line">  u32 ins_lines = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  u8  instr_ok = <span class="number">0</span>, skip_csect = <span class="number">0</span>, skip_next_label = <span class="number">0</span>,</span><br><span class="line">      skip_intel = <span class="number">0</span>, skip_app = <span class="number">0</span>, instrument_next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  u8* colon_pos;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input_file) &#123;                                              <span class="comment">//检查input_file及modified_file文件的读写</span></span><br><span class="line"></span><br><span class="line">    inf = fopen(input_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!inf) PFATAL(<span class="string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> inf = <span class="built_in">stdin</span>;</span><br><span class="line"></span><br><span class="line">  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);</span><br><span class="line"></span><br><span class="line">  outf = fdopen(outfd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!outf) PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) &#123;                           <span class="comment">//循环读取input_file文件，对每一行进行处理             </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In some cases, we want to defer writing the instrumentation trampoline</span></span><br><span class="line"><span class="comment">       until after all the labels, macros, comments, etc. If we&#x27;re in this</span></span><br><span class="line"><span class="comment">       mode, and if the line starts with a tab followed by a character, dump</span></span><br><span class="line"><span class="comment">       the trampoline now. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">        instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line">      <span class="comment">/*instr_ok：是否为代码</span></span><br><span class="line"><span class="comment">instrument_next ：是否为基本块</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,     <span class="comment">//插桩</span></span><br><span class="line">              R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">      instrument_next = <span class="number">0</span>;</span><br><span class="line">      ins_lines++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output the actual line, call it a day in pass-thru mode. */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(line, outf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pass_thru) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All right, this is where the actual fun begins. For one, we only want to</span></span><br><span class="line"><span class="comment">       instrument the .text section. So, let&#x27;s keep track of that in processed</span></span><br><span class="line"><span class="comment">       files - and let&#x27;s set instr_ok accordingly. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">//首先判断读入的行是否以‘\t’ 开头，本质上是在匹配.s文件中声明的段，然后判断line[1]是否为.</span></span><br><span class="line">      <span class="comment">/* OpenBSD puts jump tables directly inline with the code, which is</span></span><br><span class="line"><span class="comment">         a bit annoying. They use a specific format of p2align directives</span></span><br><span class="line"><span class="comment">         around them, so we use that as a signal. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;p2align &quot;</span>, <span class="number">8</span>) &amp;&amp;</span><br><span class="line">          <span class="built_in">isdigit</span>(line[<span class="number">10</span>]) &amp;&amp; line[<span class="number">11</span>] == <span class="string">&#x27;\n&#x27;</span>) skip_next_label = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">1</span>;    <span class="comment">//匹配成功，表示是代码段</span></span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t&quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section &quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;bss\n&quot;</span>, <span class="number">4</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;data\n&quot;</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect off-flavor assembly (rare, happens in gdb). When this is</span></span><br><span class="line"><span class="comment">       encountered, we set skip_csect until the opposite directive is</span></span><br><span class="line"><span class="comment">       seen, and we do not instrument. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code32&quot;</span>)) skip_csect = use_64bit;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect syntax changes, as could happen with hand-written assembly.</span></span><br><span class="line"><span class="comment">       Skip Intel blocks, resume instrumentation when back to AT&amp;T. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we&#x27;re in the right mood for instrumenting, check for function</span></span><br><span class="line"><span class="comment">       names or conditional labels. This is a bit messy, but in essence,</span></span><br><span class="line"><span class="comment">       we want to catch:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         ^main:      - function entry point (always instrumented)</span></span><br><span class="line"><span class="comment">         ^.L0:       - GCC branch label</span></span><br><span class="line"><span class="comment">         ^.LBB0_0:   - clang branch label (but only in clang mode)</span></span><br><span class="line"><span class="comment">         ^\tjnz foo  - conditional branches</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       ...but not:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         ^# BB#0:    - clang comments</span></span><br><span class="line"><span class="comment">         ^ # BB#0:   - ditto</span></span><br><span class="line"><span class="comment">         ^.Ltmp0:    - clang non-branch labels</span></span><br><span class="line"><span class="comment">         ^.LC0       - GCC non-branch labels</span></span><br><span class="line"><span class="comment">         ^.LBB0_0:   - ditto (when in GCC mode)</span></span><br><span class="line"><span class="comment">         ^\tjmp foo  - non-conditional jumps</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Additionally, clang and GCC on MacOS X follow a different convention</span></span><br><span class="line"><span class="comment">       with no leading dots on labels, hence the weird maze of #ifdefs</span></span><br><span class="line"><span class="comment">       later on.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skip_intel || skip_app || skip_csect || !instr_ok ||</span><br><span class="line">        line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Conditional branch instruction (jnz, etc). We append the instrumentation</span></span><br><span class="line"><span class="comment">       right after the branch (to instrument the not-taken path) and at the</span></span><br><span class="line"><span class="comment">       branch destination label (handled later on). */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"><span class="comment">//对于条件跳转指令，当随机数小于插桩密度时，进行插桩</span></span><br><span class="line">        <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">        ins_lines++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Label of some sort. This may be a branch destination, but we need to</span></span><br><span class="line"><span class="comment">       tread carefully and account for several different formatting</span></span><br><span class="line"><span class="comment">       conventions. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apple: L&lt;whatever&gt;&lt;digit&gt;: */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((colon_pos = <span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; <span class="built_in">isdigit</span>(*(colon_pos - <span class="number">1</span>))) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Everybody else: .L&lt;whatever&gt;: */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* .L0: or LBB0_0: style jump destination */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apple: L&lt;num&gt; / LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">1</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">1</span>, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* An optimization is possible here by adding the code only if the</span></span><br><span class="line"><span class="comment">             label is mentioned in the code in contexts other than call / jmp.</span></span><br><span class="line"><span class="comment">             That said, this complicates the code by requiring two-pass</span></span><br><span class="line"><span class="comment">             processing (messy with stdin), and results in a speed gain</span></span><br><span class="line"><span class="comment">             typically under 10%, because compilers are generally pretty good</span></span><br><span class="line"><span class="comment">             about not generating spurious intra-function jumps.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             We use deferred output chiefly to avoid disrupting</span></span><br><span class="line"><span class="comment">             .Lfunc_begin0-style exception handling calculations (a problem on</span></span><br><span class="line"><span class="comment">             MacOS X). */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!skip_next_label) instrument_next = <span class="number">1</span>; <span class="keyword">else</span> skip_next_label = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Function label (always instrumented, deferred mode). */</span></span><br><span class="line"></span><br><span class="line">        instrument_next = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ins_lines)</span><br><span class="line">    <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input_file) fclose(inf);</span><br><span class="line">  fclose(outf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!be_quiet) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ins_lines) WARNF(<span class="string">&quot;No instrumentation targets found%s.&quot;</span>,</span><br><span class="line">                          pass_thru ? <span class="string">&quot; (pass-thru mode)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> OKF(<span class="string">&quot;Instrumented %u locations (%s-bit, %s mode, ratio %u%%).&quot;</span>,</span><br><span class="line">             ins_lines, use_64bit ? <span class="string">&quot;64&quot;</span> : <span class="string">&quot;32&quot;</span>,</span><br><span class="line">             getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>) ? <span class="string">&quot;hardened&quot;</span> : </span><br><span class="line">             (sanitizer ? <span class="string">&quot;ASAN/MSAN&quot;</span> : <span class="string">&quot;non-hardened&quot;</span>),</span><br><span class="line">             inst_ratio);</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3、instrumentation-trampoline-和-main-payload"><a href="#3、instrumentation-trampoline-和-main-payload" class="headerlink" title="3、instrumentation trampoline 和 main_payload"></a>3、<strong><strong>instrumentation trampoline 和 main_payload</strong></strong></h3><p><code>trampoline</code>的含义是“蹦床”，直译过来就是“插桩蹦床”。可以直接使用英文更能表达出其代表的真实含义和作用，可以简单理解为桩代码</p><ul><li><strong><strong>trampoline_fmt_64/32</strong></strong>  根据前面内容知道，在64位环境下，AFL会插入 <code>trampoline_fmt_64</code>到文件中，在32位环境下，AFL会插入<code>trampoline_fmt_32</code>到文件中。  查看<code>afl-as.h</code> 头文件中，它们的定义：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal -16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edi,  0(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edx,  4(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%ecx,  8(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%eax, 12(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl $0x%08x, %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl 12(%%esp), %%eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  8(%%esp), %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  4(%%esp), %%edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  0(%%esp), %%edi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal 16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>  功能即：<ul><li>保存 <code>rdx</code>、 <code>rcx</code> 、<code>rax</code> 寄存器</li><li>将 <code>rcx</code> 的值设置为 <code>fprintf()</code> 函数将要打印的变量（key）内容（用于标记当前桩的随机id）</li><li>调用 <code>__afl_maybe_log</code> 函数</li><li>恢复寄存器</li></ul>  其中，实现插桩的核心代码是<code>__afl_maybe_log</code> 函数（具体汇编代码在<code>main_payload_32/64</code>内），其函数步骤、框架如下：  <img src="/2022/05/15/AFL%E6%8F%92%E6%A1%A9%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E6%8F%92%E6%A1%A9/Untitled%201.png">  其中：  <code>__afl_area_ptr</code>：共享内存地址；<br>  <code>__afl_prev_loc</code>：上一个插桩位置（id为R(100)随机数的值）；<br>  <code>__afl_fork_pid</code>：由fork产生的子进程的pid；<br>  <code>__afl_temp</code>：缓冲区；<br>  <code>__afl_setup_failure</code>：标志位，如果置位则直接退出；<br>  <code>__afl_global_area_ptr</code>：全局指针。</li><li><strong><strong>__afl_maybe_log</strong></strong>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__afl_maybe_log:</span><br><span class="line">    lahf</span><br><span class="line">    seto %al</span><br><span class="line">  <span class="comment">/* Check if SHM region is already mapped. */</span></span><br><span class="line">    movl  __afl_area_ptr, %edx</span><br><span class="line">    testl %edx, %edx</span><br><span class="line">    je    __afl_setup</span><br></pre></td></tr></table></figure>  其中：<ul><li><code>lahf</code>指令（加载状态标志位到<code>AH</code>）将EFLAGS寄存器的低八位复制到 <code>AH</code>，被复制的标志位包括：符号标志位（SF）、零标志位（ZF）、辅助进位标志位（AF）、奇偶标志位（PF）和进位标志位（CF），使用该指令可以方便地将标志位副本保存在变量中</li><li><code>seto</code>指令  溢出置位</li><li>判断 <code>__afl_area_ptr</code> 是否为NULL（检查共享内存是否进行了设置）：<ul><li>如果为NULL，跳转到 <code>__afl_setup</code> 函数进行设置</li><li>如果不为NULL，继续进行</li></ul></li></ul></li><li><strong>__afl_setup</strong>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__afl_setup:</span><br><span class="line">  <span class="comment">/* Do not retry setup if we had previous failures. */</span></span><br><span class="line">  cmpb $<span class="number">0</span>, __afl_setup_failure(%rip)</span><br><span class="line">  jne __afl_return</span><br><span class="line">  <span class="comment">/* Check out if we have a global pointer on file. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __APPLE__</span></span><br><span class="line">  movq  __afl_global_area_ptr@GOTPCREL(%rip), %<span class="function">rdx</span></span><br><span class="line"><span class="function">  <span class="title">movq</span>  <span class="params">(%rdx)</span>, %rdx</span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function">  movq  __<span class="title">afl_global_area_ptr</span><span class="params">(%rip)</span>, %rdx</span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !^__APPLE__ */</span></span></span></span><br><span class="line"><span class="function">  testq %rdx, %rdx</span></span><br><span class="line"><span class="function">  je    __afl_setup_first</span></span><br><span class="line"><span class="function">  movq %rdx, __<span class="title">afl_area_ptr</span><span class="params">(%rip)</span></span></span><br><span class="line"><span class="function">  jmp  __afl_store</span></span><br></pre></td></tr></table></figure>  主要作用为：初始化 <code>__afl_area_ptr</code> ，且只在运行到第一个桩时进行本次初始化  其中：<ul><li>如果 <code>__afl_setup_failure</code>不为0，直接跳转到 <code>__afl_return</code>返回</li><li>如果 <code>__afl_setup_failure</code>为0，检查 <code>__afl_global_area_ptr</code> 文件指针是否为NULL<ul><li>如果为NULL，跳转到 <code>__afl_setup_first</code> 进行接下来的工作</li><li>如果不为NULL，将 <code>__afl_global_area_ptr</code> 的值赋给 <code>__afl_area_ptr</code>，然后跳转到 <code>__afl_store</code></li></ul></li></ul></li><li><strong><strong>__afl_setup_first</strong></strong>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__afl_setup_first:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Save everything that is not yet saved and that may be touched by</span></span><br><span class="line"><span class="comment">     getenv() and several other libcalls we&#x27;ll be relying on. */</span></span><br><span class="line"></span><br><span class="line">  leaq <span class="number">-352</span>(%rsp), %rsp</span><br><span class="line"></span><br><span class="line">  movq %rax,   <span class="number">0</span>(%rsp)</span><br><span class="line">  movq %rcx,   <span class="number">8</span>(%rsp)</span><br><span class="line">  movq %rdi,  <span class="number">16</span>(%rsp)</span><br><span class="line">  movq %rsi,  <span class="number">32</span>(%rsp)</span><br><span class="line">  movq %r8,   <span class="number">40</span>(%rsp)</span><br><span class="line">  movq %r9,   <span class="number">48</span>(%rsp)</span><br><span class="line">  movq %r10,  <span class="number">56</span>(%rsp)</span><br><span class="line">  movq %r11,  <span class="number">64</span>(%rsp)</span><br><span class="line"></span><br><span class="line">  movq %xmm0,  <span class="number">96</span>(%rsp)</span><br><span class="line">  movq %xmm1,  <span class="number">112</span>(%rsp)</span><br><span class="line">  movq %xmm2,  <span class="number">128</span>(%rsp)</span><br><span class="line">  movq %xmm3,  <span class="number">144</span>(%rsp)</span><br><span class="line">  movq %xmm4,  <span class="number">160</span>(%rsp)</span><br><span class="line">  movq %xmm5,  <span class="number">176</span>(%rsp)</span><br><span class="line">  movq %xmm6,  <span class="number">192</span>(%rsp)</span><br><span class="line">  movq %xmm7,  <span class="number">208</span>(%rsp)</span><br><span class="line">  movq %xmm8,  <span class="number">224</span>(%rsp)</span><br><span class="line">  movq %xmm9,  <span class="number">240</span>(%rsp)</span><br><span class="line">  movq %xmm10, <span class="number">256</span>(%rsp)</span><br><span class="line">  movq %xmm11, <span class="number">272</span>(%rsp)</span><br><span class="line">  movq %xmm12, <span class="number">288</span>(%rsp)</span><br><span class="line">  movq %xmm13, <span class="number">304</span>(%rsp)</span><br><span class="line">  movq %xmm14, <span class="number">320</span>(%rsp)</span><br><span class="line">  movq %xmm15, <span class="number">336</span>(%rsp)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Map SHM, jumping to __afl_setup_abort if something goes wrong. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The 64-bit ABI requires 16-byte stack alignment. We&#x27;ll keep the</span></span><br><span class="line"><span class="comment">     original stack ptr in the callee-saved r12. */</span></span><br><span class="line"></span><br><span class="line">  pushq %r12</span><br><span class="line">  movq  %rsp, %r12</span><br><span class="line">  subq  $<span class="number">16</span>, %rsp</span><br><span class="line">  andq  $<span class="number">0xfffffffffffffff0</span>, %rsp</span><br><span class="line"></span><br><span class="line">  leaq .AFL_SHM_ENV(%rip), %<span class="function">rdi</span></span><br><span class="line"><span class="function">  <span class="title">CALL_L64</span><span class="params">(<span class="string">&quot;getenv&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  testq %rax, %rax</span></span><br><span class="line"><span class="function">  je    __afl_setup_abort</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  movq  %rax, %rdi</span></span><br><span class="line"><span class="function">  <span class="title">CALL_L64</span><span class="params">(<span class="string">&quot;atoi&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  xorq %rdx, %rdx   <span class="comment">/* shmat flags    */</span></span></span><br><span class="line"><span class="function">  xorq %rsi, %rsi   <span class="comment">/* requested addr */</span></span></span><br><span class="line"><span class="function">  movq %rax, %rdi   <span class="comment">/* SHM ID         */</span></span></span><br><span class="line"><span class="function">  <span class="title">CALL_L64</span><span class="params">(<span class="string">&quot;shmat&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  cmpq $-1, %rax</span></span><br><span class="line"><span class="function">  je   __afl_setup_abort</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="comment">/* Store the address of the SHM region. */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  movq %rax, %rdx</span></span><br><span class="line"><span class="function">  movq %rax, __<span class="title">afl_area_ptr</span><span class="params">(%rip)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span></span><br><span class="line"><span class="function">  movq %rax, __<span class="title">afl_global_area_ptr</span><span class="params">(%rip)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function">  movq __afl_global_area_ptr@<span class="title">GOTPCREL</span><span class="params">(%rip)</span>, %rdx</span></span><br><span class="line"><span class="function">  movq %rax, <span class="params">(%rdx)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span></span><br><span class="line"><span class="function">  movq %rax, %rdx</span></span><br></pre></td></tr></table></figure>  其中<ul><li>首先保存所有寄存器的值，包括 <code>xmm</code> 寄存器组</li><li>进行 <code>rsp</code>的对齐</li><li>获取环境变量 <code>__AFL_SHM_ID</code>，该环境变量保存的是共享内存的ID：<ul><li>如果获取失败，跳转到 <code>__afl_setup_abort</code></li><li>如果获取成功，调用 <code>_shmat</code> ，启用对共享内存的访问，启用失败跳转到 <code>__afl_setup_abort</code></li></ul></li><li>将 <code>_shmat</code>返回的共享内存地址存储在 <code>__afl_area_ptr</code> 和 <code>__afl_global_area_ptr</code> 变量中</li><li>最后运行 <code>__afl_forkserver</code></li></ul></li><li><strong>__afl_forkserver</strong>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__afl_forkserver:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enter the fork server mode to avoid the overhead of execve() calls. We</span></span><br><span class="line"><span class="comment">     push rdx (area ptr) twice to keep stack alignment neat. */</span></span><br><span class="line"></span><br><span class="line">  pushq %rdx</span><br><span class="line">  pushq %rdx</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Phone home and tell the parent that we&#x27;re OK. (Note that signals with</span></span><br><span class="line"><span class="comment">     no SA_RESTART will mess it up). If this fails, assume that the fd is</span></span><br><span class="line"><span class="comment">     closed because we were execve()d from an instrumented binary, or because</span></span><br><span class="line"><span class="comment">     the parent doesn&#x27;t want to use the fork server. */</span></span><br><span class="line"></span><br><span class="line">  movq $<span class="number">4</span>, %rdx               <span class="comment">/* length    */</span></span><br><span class="line">  leaq __afl_temp(%rip), %rsi <span class="comment">/* data      */</span></span><br><span class="line">  movq $<span class="string">&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;</span>, %rdi       <span class="comment">/* file desc */</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;write&quot;</span>)</span><br><span class="line"></span><br><span class="line">  cmpq $<span class="number">4</span>, %rax</span><br><span class="line">  jne  __afl_fork_resume</span><br></pre></td></tr></table></figure>  主要功能：向 <code>FORKSRV_FD+1</code> （也就是198+1）号描述符（即状态管道）中写 <code>__afl_temp</code> 中的4个字节，告诉 fork server 已经成功启动  完成后继续运行（<code>__afl_fork_wait_loop</code>函数）</li><li><strong>__afl_fork_wait_loop</strong>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__afl_fork_wait_loop:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wait for parent by reading from the pipe. Abort if read fails. */</span></span><br><span class="line"></span><br><span class="line">  movq $<span class="number">4</span>, %rdx               <span class="comment">/* length    */</span></span><br><span class="line">  leaq __afl_temp(%rip), %rsi <span class="comment">/* data      */</span></span><br><span class="line">  movq $<span class="string">&quot; STRINGIFY(FORKSRV_FD) &quot;</span>, %rdi             <span class="comment">/* file desc */</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">  cmpq $<span class="number">4</span>, %rax</span><br><span class="line">  jne  __afl_die</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Once woken up, create a clone of our process. This is an excellent use</span></span><br><span class="line"><span class="comment">     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly</span></span><br><span class="line"><span class="comment">     caches getpid() results and offers no way to update the value, breaking</span></span><br><span class="line"><span class="comment">     abort(), raise(), and a bunch of other things :-( */</span></span><br><span class="line"></span><br><span class="line">  CALL_L64(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line">  cmpq $<span class="number">0</span>, %rax</span><br><span class="line">  jl   __afl_die</span><br><span class="line">  je   __afl_fork_resume</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In parent process: write PID to pipe, then wait for child. */</span></span><br><span class="line"></span><br><span class="line">  movl %eax, __afl_fork_pid(%rip)</span><br><span class="line"></span><br><span class="line">  movq $<span class="number">4</span>, %rdx                   <span class="comment">/* length    */</span></span><br><span class="line">  leaq __afl_fork_pid(%rip), %rsi <span class="comment">/* data      */</span></span><br><span class="line">  movq $<span class="string">&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;</span>, %rdi             <span class="comment">/* file desc */</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;write&quot;</span>)</span><br><span class="line"></span><br><span class="line">  movq $<span class="number">0</span>, %rdx                   <span class="comment">/* no flags  */</span></span><br><span class="line">  leaq __afl_temp(%rip), %rsi     <span class="comment">/* status    */</span></span><br><span class="line">  movq __afl_fork_pid(%rip), %rdi <span class="comment">/* PID       */</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;waitpid&quot;</span>)</span><br><span class="line">  cmpq $<span class="number">0</span>, %rax</span><br><span class="line">  jle  __afl_die</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Relay wait status to pipe, then loop back. */</span></span><br><span class="line"></span><br><span class="line">  movq $<span class="number">4</span>, %rdx               <span class="comment">/* length    */</span></span><br><span class="line">  leaq __afl_temp(%rip), %rsi <span class="comment">/* data      */</span></span><br><span class="line">  movq $<span class="string">&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;</span>, %rdi         <span class="comment">/* file desc */</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;write&quot;</span>)</span><br><span class="line"></span><br><span class="line">  jmp  __afl_fork_wait_loop</span><br></pre></td></tr></table></figure><ul><li>等待fuzzer通过控制管道发送过来的命令，读入到 <code>__afl_temp</code> 中：<ul><li>读取失败，跳转到 <code>__afl_die</code> ，结束循环</li><li>读取成功，继续</li></ul></li><li>fork 一个子进程，子进程执行 <code>__afl_fork_resume</code></li><li>将子进程的pid赋给 <code>__afl_fork_pid</code>，并写到状态管道中通知父进程</li><li>等待子进程执行完成，写入状态管道告知 fuzzer</li><li>重新执行下一轮 <code>__afl_fork_wait_loop</code></li></ul></li><li><strong>__afl_fork_resume</strong>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__afl_fork_resume:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In child process: close fds, resume execution. */</span></span><br><span class="line"></span><br><span class="line">  movq $<span class="string">&quot; STRINGIFY(FORKSRV_FD) &quot;</span>, %<span class="function">rdi</span></span><br><span class="line"><span class="function">  <span class="title">CALL_L64</span><span class="params">(<span class="string">&quot;close&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  movq $&quot; <span class="title">STRINGIFY</span><span class="params">((FORKSRV_FD + <span class="number">1</span>))</span> &quot;, %rdi</span></span><br><span class="line"><span class="function">  <span class="title">CALL_L64</span><span class="params">(<span class="string">&quot;close&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  popq %rdx</span></span><br><span class="line"><span class="function">  popq %rdx</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  movq %r12, %rsp</span></span><br><span class="line"><span class="function">  popq %r12</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  movq  0<span class="params">(%rsp)</span>, %rax</span></span><br><span class="line"><span class="function">  movq  8<span class="params">(%rsp)</span>, %rcx</span></span><br><span class="line"><span class="function">  movq 16<span class="params">(%rsp)</span>, %rdi</span></span><br><span class="line"><span class="function">  movq 32<span class="params">(%rsp)</span>, %rsi</span></span><br><span class="line"><span class="function">  movq 40<span class="params">(%rsp)</span>, %r8</span></span><br><span class="line"><span class="function">  movq 48<span class="params">(%rsp)</span>, %r9</span></span><br><span class="line"><span class="function">  movq 56<span class="params">(%rsp)</span>, %r10</span></span><br><span class="line"><span class="function">  movq 64<span class="params">(%rsp)</span>, %r11</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  movq  96<span class="params">(%rsp)</span>, %xmm0</span></span><br><span class="line"><span class="function">  movq 112<span class="params">(%rsp)</span>, %xmm1</span></span><br><span class="line"><span class="function">  movq 128<span class="params">(%rsp)</span>, %xmm2</span></span><br><span class="line"><span class="function">  movq 144<span class="params">(%rsp)</span>, %xmm3</span></span><br><span class="line"><span class="function">  movq 160<span class="params">(%rsp)</span>, %xmm4</span></span><br><span class="line"><span class="function">  movq 176<span class="params">(%rsp)</span>, %xmm5</span></span><br><span class="line"><span class="function">  movq 192<span class="params">(%rsp)</span>, %xmm6</span></span><br><span class="line"><span class="function">  movq 208<span class="params">(%rsp)</span>, %xmm7</span></span><br><span class="line"><span class="function">  movq 224<span class="params">(%rsp)</span>, %xmm8</span></span><br><span class="line"><span class="function">  movq 240<span class="params">(%rsp)</span>, %xmm9</span></span><br><span class="line"><span class="function">  movq 256<span class="params">(%rsp)</span>, %xmm10</span></span><br><span class="line"><span class="function">  movq 272<span class="params">(%rsp)</span>, %xmm11</span></span><br><span class="line"><span class="function">  movq 288<span class="params">(%rsp)</span>, %xmm12</span></span><br><span class="line"><span class="function">  movq 304<span class="params">(%rsp)</span>, %xmm13</span></span><br><span class="line"><span class="function">  movq 320<span class="params">(%rsp)</span>, %xmm14</span></span><br><span class="line"><span class="function">  movq 336<span class="params">(%rsp)</span>, %xmm15</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  leaq 352<span class="params">(%rsp)</span>, %rsp</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  jmp  __afl_store</span></span><br></pre></td></tr></table></figure><ul><li>关闭子进程中的fd</li><li>恢复子进程的寄存器状态</li><li>jmp至<code>__afl_store</code></li></ul></li><li><strong>__afl_store</strong>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__afl_store:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Calculate and store hit for the code location specified in rcx. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  xorq __afl_prev_loc(%rip), %rcx</span><br><span class="line">  xorq %rcx, __afl_prev_loc(%rip)</span><br><span class="line">  shrq $<span class="number">1</span>, __afl_prev_loc(%rip)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^!COVERAGE_ONLY */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SKIP_COUNTS</span></span><br><span class="line">  orb  $<span class="number">1</span>, (%rdx, %rcx, <span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  incb (%rdx, %rcx, <span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^SKIP_COUNTS */</span></span></span><br></pre></td></tr></table></figure>  IDA查看：  <img src="/2022/05/15/AFL%E6%8F%92%E6%A1%A9%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E6%8F%92%E6%A1%A9/Untitled%202.png">  第一步的异或中的 <code>a4</code> ，其实是调用 <code>__afl_maybe_log</code> 时传入的参数（标记当前桩的随机ID）  而<code>_afl_prev_loc</code>是上一个桩的随机ID  经过两次异或之后，再将 <code>_afl_prev_loc</code> 右移一位作为新的 <code>_afl_prev_loc</code>，最后再共享内存中存储当前插桩位置的地方计数加一</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a></p><p><a href="https://github.com/google/AFL">https://github.com/google/AFL</a></p><p><a href="https://blog.csdn.net/further_eye/article/details/120842471">https://blog.csdn.net/further_eye/article/details/120842471</a></p><p><a href="https://bbs.pediy.com/thread-269536.htm">https://bbs.pediy.com/thread-269536.htm</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;~~&lt;/p&gt;</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="AFL" scheme="http://example.com/tags/AFL/"/>
    
    <category term="Instrumentation" scheme="http://example.com/tags/Instrumentation/"/>
    
  </entry>
  
  <entry>
    <title>03-LLVM Pass使用（传统Pass）</title>
    <link href="http://example.com/2022/05/10/03-LLVM%20Pass%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/05/10/03-LLVM%20Pass%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-05-10T13:00:00.000Z</published>
    <updated>2022-09-21T06:32:32.497Z</updated>
    
    <content type="html"><![CDATA[<p>本文按照LLVM官网编写Pass（旧版）的入门教程进行实验，对LLVM Pass进行初步的学习了解，并解决实验中遇到的问题，官网教程链接如下：<br><a href="https://llvm.org/docs/WritingAnLLVMPass.html">https://llvm.org/docs/WritingAnLLVMPass.html</a></p><span id="more"></span><p>本文只是学习并记录笔记，如有错误或不足请谅解指正，谢谢！</p><h2 id="什么是pass"><a href="#什么是pass" class="headerlink" title="什么是pass"></a>什么是pass</h2><p>LLVM Pass就是“遍历一遍IR，可以同时对它做一些操作”的意思</p><p>LLVM Pass框架是LLVM系统中很重要的一部分。LLVM的优化和转换就是由多个pass一起完成的，类似流水线操作一样，每个pass都有着自己特定的优化工作。</p><p>Pass总体上分为两类：</p><ul><li>分析类：通过pass提供信息</li><li>转换类：修改中间代码</li></ul><p>注：该教程涉及的是传统Pass管理器（旧版），LLVM默认使用新的Pass管理器进行优化（只有codegen 管道还在使用旧版Pass）。后面的时间也会对新版Pass进行学习</p><hr><h2 id="配置Pass构建环境"><a href="#配置Pass构建环境" class="headerlink" title="配置Pass构建环境"></a>配置Pass构建环境</h2><p>在LLVM源代码库某处创建新目录，例如源码中提供了：<code>llvm/lib/Transforms/Hello</code></p><p>设置构建脚本，将以下内容复制到<code>llvm/lib/Transforms/Hello/CMakeLists.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_llvm_library( LLVMHello MODULE</span><br><span class="line">  Hello.cpp</span><br><span class="line"></span><br><span class="line">  PLUGIN_TOOL</span><br><span class="line">  opt</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>代码的含义是：此构建脚本指定当前目录中的<code>Hello.cpp</code>文件将被编译并链接到一个共享项<code>$(LEVEL)/lib/LLVMHello.so</code>中，共享项可以由<strong>opt</strong>工具通过 -load 选项动态加载。</p><p>之后将以下内容放置在<code>lib/Transforms/CMakeLists.txt</code>中，这样才可以选择在之后的编译中对’Hello’pass编译</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_subdirectory(Hello)</span><br></pre></td></tr></table></figure><p>注：源码中已经有了一个“Hello”pass 的目录及示例，因此对于“Hello”不需要修改上面的内容。</p><hr><h2 id="编写Pass代码"><a href="#编写Pass代码" class="headerlink" title="编写Pass代码"></a>编写Pass代码</h2><p>头文件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>llvm命名空间</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br></pre></td></tr></table></figure><p>匿名命名空间：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br></pre></td></tr></table></figure><p>声明pass本身：这里声明了一个“ <code>Hello</code>”类，它是<a href="https://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-functionpass">FunctionPass</a>的子类，以及LLVM 用来识别 pass 的 pass 标识符</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">Hello() : FunctionPass(ID) &#123;&#125;</span><br></pre></td></tr></table></figure><p>声明一个 runOnFunction 方法，它覆盖了从 FunctionPass 继承的抽象虚函数，打印出每个函数名称：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    errs() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">    errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; <span class="comment">// end of struct Hello</span></span><br><span class="line">&#125;  <span class="comment">// end of anonymous namespace</span></span><br></pre></td></tr></table></figure><p>初始化 pass ID。LLVM 使用 ID 的地址来识别 pass，所以初始化值并不重要；最后<a href="https://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-registration">注册</a>Hello类：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="literal">false</span> <span class="comment">/* Only looks at CFG */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="literal">false</span> <span class="comment">/* Analysis Pass */</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>总的来说，整个Hello.cpp应该为这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/ADT/Statistic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_TYPE <span class="meta-string">&quot;hello&quot;</span></span></span><br><span class="line"></span><br><span class="line">STATISTIC(HelloCounter, <span class="string">&quot;Counts number of functions greeted&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="comment">// Hello - The first implementation, without getAnalysisUsage.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ID; <span class="comment">// Pass identification, replacement for typeid</span></span><br><span class="line">    Hello() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      ++HelloCounter;</span><br><span class="line">      errs() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>当然，因为源码中已经提供了初始样本，可以不对代码进行改动，这与官方教程中的内容有些许不同：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//===- Hello.cpp - Example code from &quot;Writing an LLVM Pass&quot; ---------------===//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span></span><br><span class="line"><span class="comment">// See https://llvm.org/LICENSE.txt for license information.</span></span><br><span class="line"><span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file implements two versions of the LLVM &quot;Hello World&quot; pass described</span></span><br><span class="line"><span class="comment">// in docs/WritingAnLLVMPass.html</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/ADT/Statistic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_TYPE <span class="meta-string">&quot;hello&quot;</span></span></span><br><span class="line"></span><br><span class="line">STATISTIC(HelloCounter, <span class="string">&quot;Counts number of functions greeted&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="comment">// Hello - The first implementation, without getAnalysisUsage.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ID; <span class="comment">// Pass identification, replacement for typeid</span></span><br><span class="line">    Hello() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      ++HelloCounter;</span><br><span class="line">      errs() &lt;&lt; <span class="string">&quot;Hello : &quot;</span>;</span><br><span class="line">      errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="comment">// Hello2 - The second implementation with getAnalysisUsage implemented.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Hello2</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ID; <span class="comment">// Pass identification, replacement for typeid</span></span><br><span class="line">    Hello2() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      ++HelloCounter;</span><br><span class="line">      errs() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t modify the program, so we preserve all analyses.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getAnalysisUsage</span><span class="params">(AnalysisUsage &amp;AU)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      AU.setPreservesAll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Hello2::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello2&gt;</span></span><br><span class="line"><span class="function"><span class="title">Y</span><span class="params">(<span class="string">&quot;hello2&quot;</span>, <span class="string">&quot;Hello World Pass (with getAnalysisUsage implemented)&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="编译及运行Pass"><a href="#编译及运行Pass" class="headerlink" title="编译及运行Pass"></a>编译及运行Pass</h2><p>在对<code>llvm/lib/Transforms/Hello</code>下的Hello.cpp完成编写或修改后，重新编译如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root @ zzz in ~/Desktop/llvm-project/build on git:main x </span></span><br><span class="line">$ ninja -j8</span><br><span class="line">[2/2] Linking CXX shared module lib/LLVMHello.so</span><br></pre></td></tr></table></figure><p>在lib文件夹下会生成对应的<code>LLVMHello.so</code>，之后可以使用<code>opt</code>命令通过 pass 运行 LLVM 程序</p><p>这里随便使用一个C程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hello_llvm.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello LLVM\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为bitcode：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -emit-llvm -c hello_llvm.c -o hello_llvm.bc</span><br></pre></td></tr></table></figure><p>运行pass，识别函数名：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root @ zzz in ~/Desktop </span></span><br><span class="line">$ opt -load ~/Desktop/llvm-project/build/lib/LLVMHello.so -hello &lt; hello_llvm.bc &gt; /dev/null -enable-new-pm=0</span><br><span class="line">Hello : add</span><br><span class="line">Hello : sub</span><br><span class="line">Hello : main</span><br></pre></td></tr></table></figure><p>注：若在最后运行时遇到<code>opt: unknown pass name &#39;hello&#39;</code>报错，则可根据<a href="https://llvm.org/docs/WritingAnLLVMPass.html#introduction-what-is-a-pass">提醒</a>，添加<code>-enable-new-pm=0</code> 参数，使用旧版的pass</p><p>至此完成第一个Pass编写、运行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文按照LLVM官网编写Pass（旧版）的入门教程进行实验，对LLVM Pass进行初步的学习了解，并解决实验中遇到的问题，官网教程链接如下：&lt;br&gt;&lt;a href=&quot;https://llvm.org/docs/WritingAnLLVMPass.html&quot;&gt;https://llvm.org/docs/WritingAnLLVMPass.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LLVM" scheme="http://example.com/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://example.com/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>02-LLVM IR 基础（持续更新）</title>
    <link href="http://example.com/2022/05/07/02-LLVM%20IR%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/05/07/02-LLVM%20IR%20%E5%9F%BA%E7%A1%80/</id>
    <published>2022-05-07T13:00:00.000Z</published>
    <updated>2022-09-21T06:15:10.659Z</updated>
    
    <content type="html"><![CDATA[<p>LLVM IR官方文档：<a href="https://llvm.org/docs/Reference.html#llvm-ir">https://llvm.org/docs/Reference.html#llvm-ir</a></p><p>本文只是学习并记录笔记，如有错误或不足请谅解指正，谢谢！</p><span id="more"></span><hr><h1 id="IR概述"><a href="#IR概述" class="headerlink" title="IR概述"></a>IR概述</h1><p>LLVM IR（Intermediate Representation）是LLVM的代码表示，是用于在编译器中表示代码的形式。旨在轻量级和低级，同时具有表现力、类型和可扩展性。旨在成为某种“通用 IR”，通过处于足够低的级别，可以将高级想法清晰地映射到它。</p><p>LLVM 是一种基于静态单一分配 (SSA) 的表示。</p><p>LLVM IR有三种形式：</p><p>①内存中的编译中间表示 </p><p>②磁盘上的二进制码 bitcode（例如.bc文件） </p><p>③可读汇编文本（例如.ll文件）</p><p>这三种形式之间是等价的。</p><h3 id="IR结构："><a href="#IR结构：" class="headerlink" title="IR结构："></a>IR结构：</h3><p><img src="/2022/05/07/02-LLVM%20IR%20%E5%9F%BA%E7%A1%80/Untitled.png" alt="IR结构"></p><ul><li>Module，可以被视为一个.c文件的 IR 表示，每个 Module都是相对独立的东西，主要包含了声明或者定义的函数、声明或定义的全局变量、当前 Module的基本信息</li><li>Function，是 Module中以List的方式存放的。函数内的第一个基本块叫做入口基本块。无法单独存在，必须是在某个 Module里，包含了大量 BasicBlock 、参数和返回值类型、可变参数列表、函数的attribute和其他函数的基本信息</li><li>BasicBlock，是 Function 中以List方式存放。包含了大量的 Instruction ，前驱、后继的 BasicBlock，以及一些基本信息，每个 BasicBlock都可以视为一段顺序执行的代码</li><li>Instruction，是 BasicBlock 中以List方式存放的，LLVM IR中的最小可执行单位，每一条指令都单占一行</li></ul><h3 id="IR头部："><a href="#IR头部：" class="headerlink" title="IR头部："></a>IR头部：</h3><p>LLVM IR头部是一些Target Information</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">; ModuleID = <span class="string">&#x27;hello_llvm.c&#x27;</span></span><br><span class="line">source_filename = <span class="string">&quot;hello_llvm.c&quot;</span></span><br><span class="line">target datalayout = <span class="string">&quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line">target triple = <span class="string">&quot;x86_64-unknown-linux-gnu&quot;</span></span><br></pre></td></tr></table></figure><p>信息为：</p><ul><li><code>ModuleID</code>：编译器用于区分不同模块的ID</li><li><code>source_filename</code>：源文件名</li><li><code>target datalayout</code>：目标机器架构数据布局<ul><li><code>e</code>：内存存储模式为小端模式</li><li><code>m:o</code>：目标文件的格式是Mach格式</li><li><code>i64:64</code>：64位整数的对齐方式是64位，即8字节对齐</li><li><code>f80:128</code>：80位扩展精度浮点数的对齐方式是128位，即16字节对齐</li><li><code>n8:16:32:64</code>：整型数据有8位的、16位的、32位的和64位的</li><li><code>S128</code>：128位栈自然对齐</li></ul></li><li><code>target triple</code>：用于描述目标机器信息的一个元组，一般形式是<code>&lt;architecture&gt;-&lt;vendor&gt;-&lt;system&gt;[-extra-info]</code></li></ul><hr><h1 id="IR语法"><a href="#IR语法" class="headerlink" title="IR语法"></a>IR语法</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>LLVM 标识符有两种基本类型：全局和本地</p><ul><li>全局标识符（函数、全局变量）以<code>&#39;@&#39;</code>字符作为开头前缀</li><li>本地标识符（寄存器名称、类型）以<code>&#39;%&#39;</code>字符作为开头前缀</li></ul><p>此外标识符还有三种不同形式，用于不同的目的：</p><ol><li>已命名的值：表示带有前缀的字符串。例如<code>%foo</code>，<code>@DivisionByZero</code></li><li>未命名的值：表示带有前缀的无符号数值。例如：<code>%12</code>，<code>@2</code>，<code>%44</code></li><li>常量</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LLVM 要求值以前缀开头有两个原因：编译器不需要担心名称与保留字的冲突，并且保留字集将来可能会扩展而不会受到惩罚。此外，未命名的标识符允许编译器快速提出临时变量，而不必避免符号表冲突</span><br></pre></td></tr></table></figure><p>LLVM代码示例：#将整数变量”%X”乘以 8</p><p>1、使用mul乘</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%result = mul i32 %X, 8</span><br></pre></td></tr></table></figure><p>2、使用shl移位</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%result = shl i32 %X, 3</span><br></pre></td></tr></table></figure><p>3、使用add加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%0 = add i32 %X, %X           ; yields i32:%0</span><br><span class="line">%1 = add i32 %0, %0           ; yields i32:%1</span><br><span class="line">%result = add i32 %1, %1</span><br></pre></td></tr></table></figure><p>最后一种方法说明了LLVM的几个词汇特征：</p><ul><li>注释用 ‘ ;’ 分隔</li><li>当计算结果未分配给命名值时，需要创建未命名的临时对象</li><li>未命名的临时对象按顺序编号（递增计数器，从 ’0’ 开始）</li></ul><h2 id="高层结构"><a href="#高层结构" class="headerlink" title="高层结构"></a>高层结构</h2><ul><li>模块结构：  LLVM 程序由<code>Module&#39;s</code> 组成，每个 <code>Module&#39;s</code>  都是输入程序的转换单元。每个模块由函数、全局变量和符号表组成。多个模块可以被LLVM 链接器（linker）组合在一起。  通常，一个模块由一个全局值列表组成（其中函数和全局变量都是全局值），全局值由指向内存位置的指针</li><li>链接类型：<ul><li><code>private</code>：该类型的全局变量只能被当前模块内的对象直接访问。private的值不会出现在目标代码的符号表中。</li><li><code>internal</code>：与private类似，不过它的值会作为局部变量出现在目标文件中。类似C语言中static的概念。</li><li><code>available_externally</code>：该类型的变量不会被输出到与 LLVM 模块对应的目标文件中。对于链接者来说，该类型相当于一个外部声明。这种类型只允许在定义时使用，而不能在声明时使用。</li><li><code>linkonce</code>：链接时，这种类型的变量会和其他同名变量merge。可用于实现某些形式的内联函数、模板或其他代码。</li><li><a href="https://llvm.org/docs/LangRef.html#linkage-types">官网</a>还有其他许多类型，这里不一一翻译介绍</li></ul></li><li>调用约定：<ul><li><code>ccc</code>：C调用约定。如果没有指定其他类型，那么就默认是这种类型</li><li><code>fastcc</code>：快速调用约定。使生成的目标代码尽可能快</li><li>其他调用约定参见<a href="https://llvm.org/docs/LangRef.html#calling-conventions">官网</a></li></ul></li></ul><h2 id="部分常见参数"><a href="#部分常见参数" class="headerlink" title="部分常见参数"></a>部分常见参数</h2><ul><li><code>align &lt;n&gt;</code>：这表明指针值或指针向量具有指定的对齐方式</li></ul><h2 id="部分常见指令"><a href="#部分常见指令" class="headerlink" title="部分常见指令"></a>部分常见指令</h2><ul><li><p><code>alloca</code></p><ul><li>语法：  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&lt;result&gt; = alloca [inalloca] &lt;type&gt; [, &lt;ty&gt; &lt;NumElements&gt;] [, align &lt;alignment&gt;] [, addrspace(&lt;num&gt;)]     ; yields type addrspace(num)*:result</span><br></pre></td></tr></table></figure></li><li>功能：指令在当前执行函数的栈帧上分配内存，当这个函数返回给它的调用者时自动释放</li></ul>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">%ptr = alloca i32                             ; yields i32*:ptr</span><br><span class="line">%ptr = alloca i32, i32 <span class="number">4</span>                      ; yields i32*:ptr</span><br><span class="line">%ptr = alloca i32, i32 <span class="number">4</span>, align <span class="number">1024</span>          ; yields i32*:ptr</span><br><span class="line">%ptr = alloca i32, align <span class="number">1024</span>                 ; yields i32*:ptr</span><br></pre></td></tr></table></figure></li><li><p><code>store</code></p><ul><li>功能：写入内存</li></ul>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">%ptr = alloca i32                               ; yields i32*:ptr</span><br><span class="line">**store i32 <span class="number">3</span>, i32* %ptr**                          ; yields <span class="keyword">void</span></span><br><span class="line">%val = load i32, i32* %ptr                      ; yields i32:val = i32 <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p><code>load</code></p><ul><li>功能：从内存中读取</li></ul>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">%ptr = alloca i32                               ; yields i32*:ptr</span><br><span class="line">store i32 <span class="number">3</span>, i32* %ptr                          ; yields <span class="keyword">void</span></span><br><span class="line">**%val = load i32, i32* %ptr**                      ; yields i32:val = i32 <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p><code>getelementptr</code></p><ul><li>功能：获取<a href="https://llvm.org/docs/LangRef.html#t-aggregate">聚合</a>数据结构的子元素的地址。它只执行地址计算，不访问内存</li></ul><p>  使用方法看文档感觉较多，主要知道是获取元素地址</p>  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">%<span class="number">1</span> = getelementptr i64* %<span class="number">0</span>, i32 <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p><code>ptrtoint…to</code></p><ul><li>语法：  <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&lt;result&gt; = ptrtoint &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;             ; yields ty2</span><br></pre></td></tr></table></figure></li><li>功能：“ptrtoint”指令将指针或指针向量值转换为整数（或整数向量）类型 ty2。</li><li>参数：“ptrtoint”指令需要一个值进行强制转换，该值必须是指针类型的值或指针向量，以及将其强制转换为 ty2 的类型，该类型必须是整数或整数类型的向量。</li></ul>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%2 = ptrtoint i64* %1 to i64</span><br></pre></td></tr></table></figure></li><li><p><code>inttoptr...to</code></p><ul><li>语法：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;result&gt; = inttoptr &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;[, !dereferenceable !&lt;deref_bytes_node&gt;][, !dereferenceable_or_null !&lt;deref_bytes_node&gt;]             ; yields ty2</span><br></pre></td></tr></table></figure></li><li>功能：“inttoptr”指令将整数值转换为指针类型 ty2。</li><li>参数：’ inttoptr’ 指令需要一个整数值来转换，以及一个类型来转换它，它必须是一个指针 类型</li></ul>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%4 = inttoptr i64 %3 to i64*</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;LLVM IR官方文档：&lt;a href=&quot;https://llvm.org/docs/Reference.html#llvm-ir&quot;&gt;https://llvm.org/docs/Reference.html#llvm-ir&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文只是学习并记录笔记，如有错误或不足请谅解指正，谢谢！&lt;/p&gt;</summary>
    
    
    
    <category term="LLVM" scheme="http://example.com/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://example.com/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>01-LLVM概述及简单使用</title>
    <link href="http://example.com/2022/05/05/01-LLVM%E6%A6%82%E8%BF%B0%E5%8F%8AIR%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/05/05/01-LLVM%E6%A6%82%E8%BF%B0%E5%8F%8AIR%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2022-05-05T13:00:00.000Z</published>
    <updated>2022-09-21T06:32:22.504Z</updated>
    
    <content type="html"><![CDATA[<p>LLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。是模块化和可重用的编译器和工具链技术的集合.</p><span id="more"></span><p>本来只是想写一个底层的虚拟机（low level virtual machine），但做出来后实际上跟虚拟机几乎没有关系。LLVM就是这个项目的全名<br>本文只是学习并记录笔记，如有错误或不足请谅解指正，谢谢！</p><hr><h2 id="LLVM简介"><a href="#LLVM简介" class="headerlink" title="LLVM简介"></a>LLVM简介</h2><h3 id="传统GCC编译器架构"><a href="#传统GCC编译器架构" class="headerlink" title="传统GCC编译器架构"></a>传统GCC编译器架构</h3><p>传统静态编译器主要流行分为三个阶段：前端（词法分析、语法分析、语义分析、生成中间代码）、优化器（中间代码优化）和后端（生成机器码）</p><p><img src="/2022/05/05/01-LLVM%E6%A6%82%E8%BF%B0%E5%8F%8AIR%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/Untitled.png"></p><ul><li>前端解析源代码，检查错误，并构建特定语言的抽象语法树 (AST)</li><li>优化器负责进行各种转换以尝试提高代码的运行时间，例如消除冗余计算</li><li>后端将代码映射到目标指令集，编译器后端的常见部分包括指令选择、寄存器分配和指令调度</li></ul><p>这种GCC“一条龙”服务的好处是：不会暴露中间接口来给你操作它的IR，是强耦合的；但缺点是，对于不同的、新的语言，需要完成全部的从前端、优化器到后端的流程设计。</p><h3 id="LLVM架构"><a href="#LLVM架构" class="headerlink" title="LLVM架构"></a>LLVM架构</h3><p>目的：支持多种源语言或目标架构（三阶段设计）</p><p><img src="/2022/05/05/01-LLVM%E6%A6%82%E8%BF%B0%E5%8F%8AIR%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/Untitled%201.png"></p><p>LLVM与传统GCC编译器的主要不同就是：对于不同的语言它都提供了同一种中间表示。优化器只对中间表示IR操作，通过一系列的pass对IR做优化。使用这种设计，移植编译器以支持新的源语言需要实现新的前端，但可以重用现有的优化器和后端。</p><p>优点：LLVM由于共享优化器的中转，不同的前端语言最终都转换成同一种的IR，不仅仅支持一种源语言和一个目标</p><h2 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h2><hr><p>官方文档：<a href="https://llvm.org/docs/Reference.html#llvm-ir">https://llvm.org/docs/Reference.html#llvm-ir</a></p><p>LLVM IR（Intermediate Representation）是LLVM的代码表示，是用于在编译器中表示代码的形式。旨在轻量级和低级，同时具有表现力、类型和可扩展性。旨在成为某种“通用 IR”，通过处于足够低的级别，可以将高级想法清晰地映射到它。</p><p>LLVM IR有三种形式：①内存中的编译中间表示 ②磁盘上的二进制码 bitcode ③可读汇编文本</p><p>这三种形式之间是等价的。</p><p>结构：</p><p><img src="/2022/05/05/01-LLVM%E6%A6%82%E8%BF%B0%E5%8F%8AIR%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/Untitled%202.png"></p><ul><li>Module，可以被视为一个.c文件的 IR 表示，每个 Module都是相对独立的东西，主要包含了声明或者定义的函数、声明或定义的全局变量、当前 Module的基本信息</li><li>Function，是 Module中以List的方式存放的。函数内的第一个基本块叫做入口基本块。无法单独存在，必须是在某个 Module里，包含了大量 BasicBlock 、参数和返回值类型、可变参数列表、函数的attribute和其他函数的基本信息</li><li>BasicBlock，是 Function 中以List方式存放。包含了大量的 Instruction ，前驱、后继的 BasicBlock，以及一些基本信息，每个 BasicBlock都可以视为一段顺序执行的代码</li><li>Instruction，是 BasicBlock 中以List方式存放的，LLVM IR中的最小可执行单位，每一条指令都单占一行</li></ul><h2 id="LLVM简单使用"><a href="#LLVM简单使用" class="headerlink" title="LLVM简单使用"></a>LLVM简单使用</h2><hr><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello LLVM\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将C文件编译为LLVM  IR文件</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -emit-llvm -S hello_llvm.c -o hello_llvm.ll</span><br></pre></td></tr></table></figure><p>查看hello_llvm.ll</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">; ModuleID = <span class="string">&#x27;hello_llvm.c&#x27;</span></span><br><span class="line">source_filename = <span class="string">&quot;hello_llvm.c&quot;</span></span><br><span class="line">target datalayout = <span class="string">&quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line">target triple = <span class="string">&quot;x86_64-unknown-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line">@.str = private unnamed_addr constant [12 x i8] c<span class="string">&quot;hello LLVM\0A\00&quot;</span>, align 1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local i32 @main() <span class="comment">#0 &#123;</span></span><br><span class="line">  %1 = alloca i32, align 4</span><br><span class="line">  store i32 0, ptr %1, align 4</span><br><span class="line">  %2 = call i32 (ptr, ...) @<span class="built_in">printf</span>(ptr noundef @.str)</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> i32 @<span class="built_in">printf</span>(ptr noundef, ...) <span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">attributes <span class="comment">#0 = &#123; noinline nounwind optnone uwtable &quot;frame-pointer&quot;=&quot;all&quot; &quot;min-legal-vector-width&quot;=&quot;0&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;</span></span><br><span class="line">attributes <span class="comment">#1 = &#123; &quot;frame-pointer&quot;=&quot;all&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;</span></span><br><span class="line"></span><br><span class="line">!llvm.module.flags = !&#123;!0, !1, !2, !3, !4&#125;</span><br><span class="line">!llvm.ident = !&#123;!5&#125;</span><br><span class="line"></span><br><span class="line">!0 = !&#123;i32 1, !<span class="string">&quot;wchar_size&quot;</span>, i32 4&#125;</span><br><span class="line">!1 = !&#123;i32 7, !<span class="string">&quot;PIC Level&quot;</span>, i32 2&#125;</span><br><span class="line">!2 = !&#123;i32 7, !<span class="string">&quot;PIE Level&quot;</span>, i32 2&#125;</span><br><span class="line">!3 = !&#123;i32 7, !<span class="string">&quot;uwtable&quot;</span>, i32 2&#125;</span><br><span class="line">!4 = !&#123;i32 7, !<span class="string">&quot;frame-pointer&quot;</span>, i32 2&#125;</span><br><span class="line">!5 = !&#123;!<span class="string">&quot;clang version 15.0.0 (https://github.com/llvm/llvm-project.git e300682597470ffc88b59a6187cdd763f1595d3a)&quot;</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>将C文件编译为LLVM  bitcode文件</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -emit-llvm -c hello_llvm.c -o hello_llvm.bc</span><br></pre></td></tr></table></figure><ul><li>查看bitcode文件对应的LLVM  程序集</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">llvm-dis &lt; hello_llvm.bc</span><br></pre></td></tr></table></figure><p>与上面生成的IR文件内容一致</p><ul><li>可以通过<code>lli</code>指令运行上面生成的<code>.ll</code>及<code>.bc</code>文件</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lli hello_llvm.bc       </span><br><span class="line">hello LLVM</span><br><span class="line"></span><br><span class="line">$ lli hello_llvm.ll</span><br><span class="line">hello LLVM</span><br></pre></td></tr></table></figure><p>附LLVM常用命令，详细信息可以查看<a href="https://llvm.org/docs/CommandGuide/index.html">官方命令指南</a>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">llvm-ar：存档器生成一个包含给定 LLVM 位码文件的存档，可选地带有一个索引以便更快地查找</span><br><span class="line">llvm-as：汇编器将可读的 LLVM  程序集转换为 LLVM bitcode</span><br><span class="line">llvm-dis：反汇编器将 LLVM bitcode转换为可读的 LLVM 程序集</span><br><span class="line">llvm-link：将多个 LLVM 模块链接到一个程序中</span><br><span class="line">lli：LLVM解释器（LLVM interpreter），可以直接执行LLVM bitcode</span><br><span class="line">llc：LLVM 后端编译器，它将 LLVM bitcode转换为本机代码汇编文件</span><br><span class="line">opt：读取 LLVM 位码，将一系列 LLVM 应用于 LLVM 转换，并输出结果位码；opt -help获取LLVM 中可用的程序转换列表。opt还可以对输入的 LLVM 位码文件运行特定分析并打印结果。主要用于调试分析或熟悉分析的作用。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。是模块化和可重用的编译器和工具链技术的集合.&lt;/p&gt;</summary>
    
    
    
    <category term="LLVM" scheme="http://example.com/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://example.com/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>00-LLVM源码安装</title>
    <link href="http://example.com/2022/05/01/00-LLVM%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2022/05/01/00-LLVM%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/</id>
    <published>2022-05-01T13:00:00.000Z</published>
    <updated>2022-09-21T06:14:01.119Z</updated>
    
    <content type="html"><![CDATA[<ul><li>环境：Ubuntu20.04</li><li>版本：LLVM 14.0.3</li></ul><p>LLVM安装方法有许多，其实主要区别就在于，源码安装可以后续对LLVM进行进一步加工；若只是单纯使用LLVM，则可以直接安装。</p><span id="more"></span><h2 id="本文只是学习并记录笔记，如有错误或不足请谅解指正，谢谢！"><a href="#本文只是学习并记录笔记，如有错误或不足请谅解指正，谢谢！" class="headerlink" title="本文只是学习并记录笔记，如有错误或不足请谅解指正，谢谢！"></a>本文只是学习并记录笔记，如有错误或不足请谅解指正，谢谢！</h2><h2 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://apt.llvm.org/llvm.sh</span><br><span class="line">chmod +x llvm.sh</span><br><span class="line">sudo ./llvm.sh </span><br></pre></td></tr></table></figure><p><a href="http://llvm.sh/">llvm.sh</a> 内包含安装llvm所需要的其他配件工具，主要通过apt-get安装的</p><hr><h2 id="源码编译安装（推荐）"><a href="#源码编译安装（推荐）" class="headerlink" title="源码编译安装（推荐）"></a>源码编译安装（推荐）</h2><p>这里使用的LLVM 版本是<a href="https://github.com/llvm/llvm-project">Github</a>上显示的14.0.3</p><h3 id="环境条件"><a href="#环境条件" class="headerlink" title="环境条件"></a>环境条件</h3><ul><li>CMake &gt;= 3.13.4</li><li>GCC &gt;= 7.1.0</li><li>python &gt;= 3.6</li><li><a href="http://zlib.net/">zlib</a> &gt;= 1.2.3.4</li><li><a href="http://savannah.gnu.org/projects/make">GNU Make</a> ≥ 3.79</li></ul><p>这些工具的安装网上教程很多，这里不再记录，这里我的环境是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake version 3.16.3</span><br><span class="line">gcc version 9.4.0</span><br><span class="line">Python 3.8.10</span><br><span class="line">zlib version 1.2.12</span><br><span class="line">GNU Make 4.2.1</span><br></pre></td></tr></table></figure><h3 id="下载LLVM源码"><a href="#下载LLVM源码" class="headerlink" title="下载LLVM源码"></a>下载LLVM源码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/llvm/llvm-project.git</span><br></pre></td></tr></table></figure><p>我下载的时候是LLVM 14.0.3版本，由于上面的命令较慢，也可以以浅层克隆的形式节约空间及时间（使用这个只能构建最新版本的llvm，对于只想编译的普通用户，此命令可以正常工作。但是如果后来有人成为贡献者，由于他们无法从浅克隆推送代码，因此需要将其转换为完整克隆）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/llvm/llvm-project.git </span><br></pre></td></tr></table></figure><h3 id="构建LLVM及Clang"><a href="#构建LLVM及Clang" class="headerlink" title="构建LLVM及Clang"></a>构建LLVM及Clang</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> llvm-project</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -G Ninja -DCMAKE_BUILD_TYPE=Release  -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang&quot;</span> ../llvm  <span class="comment">#编译配置</span></span><br><span class="line">ninja -j8  <span class="comment">#开始编译</span></span><br><span class="line">ninja install</span><br></pre></td></tr></table></figure><p>其中，第四行cmake指令的官方原型是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -G &lt;generator&gt; -DCMAKE_BUILD_TYPE=&lt;<span class="built_in">type</span>&gt; [options] ../llvm</span><br></pre></td></tr></table></figure><p>这里的参数含义分别是：</p><ul><li>**-G <generator>**：一些常见的构建系统生成器<generator>包括<ul><li><strong>Ninja</strong> — 用于生成<a href="https://ninja-build.org/">Ninja</a> 构建文件（官方文档言：大多数 llvm 开发人员使用这个）</li><li><strong>Unix Makefiles</strong> — 用于生成与 make 兼容的并行 makefile</li><li><strong>Visual Studio</strong> — 用于生成 Visual Studio 项目和解决方案</li><li><strong>Xcode</strong> — 用于生成 Xcode 项目</li></ul>  在没有-G参数时，默认是使用的make命令</generator></generator></li><li><strong>-DCMAKE_BUILD_TYPE</strong>：默认情况下llvm编译的是debug版本，在编译release版本的时候需要明确指定编译的类型</li><li>其他一些选项[options]包括：<ul><li>**DLLVM_ENABLE_PROJECTS=’…’**：在编译的时候，会默认只编译llvm的基础库，使用此命令，指定要另外构建的 LLVM 子项目。可以包括以下任何一种：clang、clang-tools-extra、lldb、compiler-rt、lld、polly、cross-project-tests</li><li><strong>DCMAKE_INSTALL_PREFIX=directory</strong>：指定要安装 LLVM 工具和库的位置的完整路径名（默认值是<code>/usr/local</code>）</li><li><strong>DLLVM_ENABLE_ASSERTIONS=On</strong>：在启用断言检查的情况下编译（Debug 构建默认为 Yes，所有其他构建类型默认为 No）</li></ul></li></ul><p>执行完最后的ninja install指令，编译安装完后，将build下的bin文件夹添加到环境变量path下</p><p>查看版本：（这里不明白为什么显示15.0.0版本，github上却是14.0.3）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ llvm-as --version</span><br><span class="line">LLVM (http://llvm.org/):</span><br><span class="line">  LLVM version 15.0.0git</span><br><span class="line">  Optimized build.</span><br><span class="line">  Default target: x86_64-unknown-linux-gnu</span><br><span class="line">  Host CPU: tigerlake</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(argc)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 1 : argc is  %d\r\n&quot;</span>,argc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 2 : argc is  %d\r\n&quot;</span>,argc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;default ：argc is  %d\r\n&quot;</span>,argc);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将llvm_test.c转换为LLVM IR</span></span><br><span class="line">clang -emit-llvm -S llvm_test.c -o llvm_test_1.ll</span><br></pre></td></tr></table></figure><p>查看生成的IR：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">; ModuleID = <span class="string">&#x27;llvm_test.c&#x27;</span></span><br><span class="line">source_filename = <span class="string">&quot;llvm_test.c&quot;</span></span><br><span class="line">target datalayout = <span class="string">&quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line">target triple = <span class="string">&quot;x86_64-unknown-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line">@.str = <span class="keyword">private</span> unnamed_addr constant [<span class="number">23</span> x i8] c<span class="string">&quot;case 1 : argc is  %d\0D\0A\00&quot;</span>, align <span class="number">1</span></span><br><span class="line">@.str<span class="number">.1</span> = <span class="keyword">private</span> unnamed_addr constant [<span class="number">23</span> x i8] c<span class="string">&quot;case 2 : argc is  %d\0D\0A\00&quot;</span>, align <span class="number">1</span></span><br><span class="line">@.str<span class="number">.2</span> = <span class="keyword">private</span> unnamed_addr constant [<span class="number">25</span> x i8] c<span class="string">&quot;default \EF\BC\9Aargc is  %d\0D\0A\00&quot;</span>, align <span class="number">1</span></span><br><span class="line">@.str<span class="number">.3</span> = <span class="keyword">private</span> unnamed_addr constant [<span class="number">3</span> x i8] c<span class="string">&quot;OK\00&quot;</span>, align <span class="number">1</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local i32 @main(i32 noundef %<span class="number">0</span>, ptr noundef %<span class="number">1</span>) #<span class="number">0</span> &#123;</span><br><span class="line">  %<span class="number">3</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">4</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">5</span> = alloca ptr, align <span class="number">8</span></span><br><span class="line">  store i32 <span class="number">0</span>, ptr %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  store i32 %<span class="number">0</span>, ptr %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  store ptr %<span class="number">1</span>, ptr %<span class="number">5</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">6</span> = load i32, ptr %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  <span class="keyword">switch</span> i32 %<span class="number">6</span>, label %<span class="number">13</span> [</span><br><span class="line">    i32 <span class="number">1</span>, label %<span class="number">7</span></span><br><span class="line">    i32 <span class="number">2</span>, label %<span class="number">10</span></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>:                                                ; preds = %<span class="number">2</span></span><br><span class="line">  %<span class="number">8</span> = load i32, ptr %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">9</span> = call i32 (ptr, ...) @<span class="built_in">printf</span>(ptr noundef @.str, i32 noundef %<span class="number">8</span>)</span><br><span class="line">  br label %<span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>:                                               ; preds = %<span class="number">2</span></span><br><span class="line">  %<span class="number">11</span> = load i32, ptr %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">12</span> = call i32 (ptr, ...) @<span class="built_in">printf</span>(ptr noundef @.str<span class="number">.1</span>, i32 noundef %<span class="number">11</span>)</span><br><span class="line">  br label %<span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>:                                               ; preds = %<span class="number">2</span></span><br><span class="line">  %<span class="number">14</span> = load i32, ptr %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">15</span> = call i32 (ptr, ...) @<span class="built_in">printf</span>(ptr noundef @.str<span class="number">.2</span>, i32 noundef %<span class="number">14</span>)</span><br><span class="line">  br label %<span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="number">16</span>:                                               ; preds = %<span class="number">13</span>, %<span class="number">10</span>, %<span class="number">7</span></span><br><span class="line">  %<span class="number">17</span> = call i32 (ptr, ...) @<span class="built_in">printf</span>(ptr noundef @.str<span class="number">.3</span>)</span><br><span class="line">  %<span class="number">18</span> = load i32, ptr %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  ret i32 %<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i32 @<span class="built_in">printf</span>(ptr noundef, ...) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">attributes #<span class="number">0</span> = &#123; noinline nounwind optnone uwtable <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span>=<span class="string">&quot;0&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;tune-cpu&quot;</span>=<span class="string">&quot;generic&quot;</span> &#125;</span><br><span class="line">attributes #<span class="number">1</span> = &#123; <span class="string">&quot;frame-pointer&quot;</span>=<span class="string">&quot;all&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;tune-cpu&quot;</span>=<span class="string">&quot;generic&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">!llvm.<span class="keyword">module</span>.flags = !&#123;!<span class="number">0</span>, !<span class="number">1</span>, !<span class="number">2</span>, !<span class="number">3</span>, !<span class="number">4</span>&#125;</span><br><span class="line">!llvm.ident = !&#123;!<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">&quot;wchar_size&quot;</span>, i32 <span class="number">4</span>&#125;</span><br><span class="line">!<span class="number">1</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">&quot;PIC Level&quot;</span>, i32 <span class="number">2</span>&#125;</span><br><span class="line">!<span class="number">2</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">&quot;PIE Level&quot;</span>, i32 <span class="number">2</span>&#125;</span><br><span class="line">!<span class="number">3</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">&quot;uwtable&quot;</span>, i32 <span class="number">2</span>&#125;</span><br><span class="line">!<span class="number">4</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">&quot;frame-pointer&quot;</span>, i32 <span class="number">2</span>&#125;</span><br><span class="line">!<span class="number">5</span> = !&#123;!<span class="string">&quot;clang version 15.0.0 (https://github.com/llvm/llvm-project.git e300682597470ffc88b59a6187cdd763f1595d3a)&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>运行测试：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lli llvm_test_1.ll                               </span><br><span class="line"><span class="keyword">case</span> 1 : argc is  1</span><br><span class="line">OK<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">$ lli llvm_test_1.ll 1</span><br><span class="line"><span class="keyword">case</span> 2 : argc is  2</span><br><span class="line">OK<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>至此LLVM的源码编译安装及测试使用完成。</p><p>参考：</p><p><a href="https://clang.llvm.org/get_started.html">https://clang.llvm.org/get_started.html</a></p><p><a href="https://llvm.org/docs/GettingStarted.html#checkout-llvm-from-subversion">https://llvm.org/docs/GettingStarted.html#checkout-llvm-from-subversion</a></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;环境：Ubuntu20.04&lt;/li&gt;
&lt;li&gt;版本：LLVM 14.0.3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LLVM安装方法有许多，其实主要区别就在于，源码安装可以后续对LLVM进行进一步加工；若只是单纯使用LLVM，则可以直接安装。&lt;/p&gt;</summary>
    
    
    
    <category term="LLVM" scheme="http://example.com/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://example.com/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读 -- &quot;Kernel k-means, Spectral Clustering and Normalized Cuts&quot;</title>
    <link href="http://example.com/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/"/>
    <id>http://example.com/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/</id>
    <published>2022-04-20T02:00:00.000Z</published>
    <updated>2022-09-21T12:12:39.252Z</updated>
    
    <content type="html"><![CDATA[<p>Introducetion: 数据挖掘：k-means聚类介绍<br>Topic: Data Mining<br>URL: <a href="https://dl.acm.org/doi/abs/10.1145/1014052.1014118">https://dl.acm.org/doi/abs/10.1145/1014052.1014118</a><br>Where: KDD<br>Year: 2004</p><span id="more"></span><p>本文只是学习并记录笔记，如有错误或不足请谅解指正，谢谢！</p><h1 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h1><hr><h2 id="k-means（K均值）"><a href="#k-means（K均值）" class="headerlink" title="k-means（K均值）"></a>k-means（K均值）</h2><p>是基于数据划分的无监督聚类算法</p><p>聚类算法：可以理解为无监督的分类方法</p><ul><li>基本原理<ul><li>对于基于划分的这一类聚类算法而言，其方法是将样本的矢量空间划分为多个区域 $<code>&#123;&#123;S_i|^k_&#123;i=1&#125;&#125;&#125;</code>$，每个区域都存在一个区域中心$<code>C_i|^k_&#123;i=1&#125;</code>$，这样对于每一个样本，都可以建立一种样本到区域中心的映射：  $<code>q(x)=\sum^k_&#123;i=1&#125;1(x&#123;\in&#125;S_i)C_i</code>$其中1()为指示函数，即代表样本x是否属于区域S</li><li>不同的基于划分的聚类算法的主要区别就在于如何建立相应的映射方式<code>q(x)</code>，在k-means中，映射是通过样本与各中心之间的误差平方和最小这一准则来建立的</li></ul></li><li>主要实现步骤：<ol><li>初始化聚类中心$<code>C_1^&#123;(0)&#125;， C_2^&#123;(0)&#125; ，C_3^&#123;(0)&#125;</code>$ …… $<code>C_k^&#123;(0)&#125;</code>$可选取前K个样本或者随机选取K个样本</li><li>分配各个样本$<code>x_j</code>$到距离最相近的聚类集合，样本分配依据为：$<code>S_i^&#123;(t)&#125;=\&#123;x_j\mid\|&#123;x_j-c_j^&#123;(t)&#125;\|_2^2&#125;\leq\|x_j-c_p^&#123;(t)&#125;\|_2^2\&#125;</code>$其中<code>i=1,2,…,k,p≠j</code></li><li>根据上一步的分配结果，更新聚类中心：$c_i^{(t+1)}=\dfrac{1}{|S_i^{(t)}|}\sum_{x_j\in{S_i^{(t)}}}x_j$</li><li>若迭代次数达到最大迭代步数或者前后两次迭代的差小于设定阈值ε<br>，即$<code>\|c_i^&#123;(t+1)&#125;-c_i^&#123;(t)&#125;\|_2^2&lt;\varepsilon</code>$，则算法结束，否则重复步骤2</li></ol></li></ul><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled.png" alt="Untitled"></p><p>计算每个样本点簇中心的距离，然后判断出到哪个簇中心距离最短，然后分给那个簇。然后下次迭代时，簇中心就按照新分配的点重新进行计算了，然后所有的点再同样计算样本点到簇中心的距离，重新分配到不同的簇中。所以这样不断迭代下去，就能够收敛了，得到最后的聚类效果。</p><p>问题：对于非标准正态分布和非均匀分布的样本，k-means聚类效果不好，其主要原因是k-means是假设相似度可以用二次欧式距离等价的衡量，但是在实际的样本集合中这个假设不一定实用。</p><p>为了克服这个局限性，k-means需要推广到更广义的度量空间，其两种经典的改进框架如下：</p><h2 id="Kernel-k-means（核k-means方法）"><a href="#Kernel-k-means（核k-means方法）" class="headerlink" title="Kernel k-means（核k-means方法）"></a>Kernel k-means（核k-means方法）</h2><p>将样本点$<code>x_i</code>$通过某种映射方式$<code>x_i\rightarrow \phi(x_i)</code>$，映射到新的高维空间Φ<br>，在该空间中样本点之间的内积可以通过对应的核函数进行计算，即：</p><p>$<code>k(x_i,x_j)=\phi(x_i)^T\phi(x_j)</code>$</p><p>借助核函数，可以在新的空间进行k-means聚类，而此时样本之间的相似度取决于核函数的选择。</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%201.png" alt="Untitled"></p><p>ai表示样本点，mc表示每个簇的质心。</p><p>$\phi()$表示将样本点映射至高维空间。但这个函数是很难算出来的，因为这种非线性的函数映射，很难去得到准确的函数算法。且，簇的中心mc也很难去描述出来。</p><p>因此需要对这个函数进行改造：</p><p>将</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%202.png" alt="Untitled"></p><p>改为</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%203.png" alt="Untitled"></p><p>即：将该公式展开。</p><p>我们可以发现：每一项中，需要使用到高维特征空间的值，都是在进行内积运算。因此符合我们之前所提到的，使用一个矩阵K函数，来代表高维特征空间中这两个值的内积结果。</p><p>即：$<code>k(a_i,b_j)=\phi(a_i).\phi(b_j)</code>$</p><p>所以，我们只需要得到一个K矩阵，矩阵中每个元素都表示高维空间，这两个样本点映射成特征后，进行内积计算所得到的结果。所以这个矩阵，实际上就是一个<strong>核函数矩阵。</strong></p><h3 id="weighted-kernel-k-means"><a href="#weighted-kernel-k-means" class="headerlink" title="weighted kernel k-means"></a><strong>weighted kernel k-means</strong></h3><p>在<strong>kernel k-means</strong>基础上，为每一个样本点给出一个权重，以区分不同样本点的重要性。</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%204.png" alt="Untitled"></p><p>公式中计算样本高维空间特征到簇中心距离 的平方后，还乘以了一个权重$w_j$</p><h2 id="Spectral-Clustering（谱聚类方法）"><a href="#Spectral-Clustering（谱聚类方法）" class="headerlink" title="Spectral Clustering（谱聚类方法）"></a><strong><strong>Spectral Clustering（谱聚类方法）</strong></strong></h2><p>它的主要思想是把所有的数据看做空间中的点，这些点之间可以用边连接起来。距离较远的两个点之间的边权重值较低，而距离较近的两个点之间的边权重值较高，通过对所有数据点组成的图进行切图，让切图后不同的子图间边权重和尽可能的低，而子图内的边权重和尽可能的高，从而达到聚类的目的。</p><h1 id="摘要与背景"><a href="#摘要与背景" class="headerlink" title="摘要与背景"></a>摘要与背景</h1><hr><p>Kernel k-means和谱聚类都被用于识别在输入空间中非线性可分离的聚类。尽管进行了大量的研究，但这些方法仍然只是松散地联系在一起。</p><p>本文中，作者给出了它们之间明确的理论联系。证明了Weighted  kernel k-means目标函数的通用性，并推导出归一化切割的谱聚类目标作为一种特殊情况。</p><p>提出了一种新的Weighted kernel k-means算法（前提给出正定相似矩阵），其单调地减少了归一化割。</p><p>意义：</p><ul><li>基于特征向量的算法（可能在计算上是禁止的）对于最小化规范化切割不是必需的</li><li>各种技术，例如局部搜索和加速方案，可以用来提高核k-均值的质量和速度</li></ul><p>背景：</p><ul><li>聚类是数据挖掘的重要问题，k-means是最流行的聚类算法之一，受到了相关研究者的广泛关注。</li><li>k-means的一个主要缺点是，它不能分离在输入空间中非线性可分离的簇。当时的两种解决方法是：①Kernel k-means，在聚类之前，使用非线性函数将点映射到高维特征空间，然后Kernel k-means在新空间中用线性分隔符对点进行分割。②spectral clustering algorithms（谱聚类算法），使用亲和矩阵的特征向量来获得数据的聚类。谱聚类中常用的目标函数是最小化归一化切割的</li></ul><p>从表面上看，Kernel k-means和谱聚类似乎是完全不同的方法。</p><p>本文的目的：证明Kernel k-means和谱聚类之间的相关性（可以将加权核k-means目标函数重写为迹最大化问题）。这样当遇到需要计算大量特征向量的情景时，可以使用类似k-means的迭代算法来完成最小化图的归一划分。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul><li>常见的非线性核函数</li></ul><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%205.png" alt="Untitled"></p><h3 id="Weighted-Kernel-k-means"><a href="#Weighted-Kernel-k-means" class="headerlink" title="Weighted Kernel k-means"></a>Weighted Kernel k-means</h3><p>k-means聚类算法可以通过使用核函数来增强；通过使用从原始（输入）空间到高维特征空间的适当非线性映射，可以提取在输入空间中非线性可分离的聚类。</p><p>此外，我们可以通过为每个点a引入一个权值来推广核k-means算法，用w(a)表示。</p><p>算法：</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%206.png" alt="Untitled"></p><p>第二项每个数据点计算一次，每次计算的成本是O(n)，导致每次迭代的成本是O(n2)。</p><p>因此，每次迭代的复杂度为O(n2)标量操作。首先，我们必须计算核矩阵K，这通常需要时间O(n2m)，其中m是原始点的维数。若总迭代次数为τ，则算法1的时间复杂度为O(n2(τ + m))。</p><h3 id="Spectral-clustering-谱聚类"><a href="#Spectral-clustering-谱聚类" class="headerlink" title="Spectral clustering(谱聚类)"></a>Spectral clustering(谱聚类)</h3><p>基本思想是利用样本数据的相似矩阵(拉普拉斯矩阵)进行特征划分后得到的特征向量进行聚类。<br>作者在本文重点研究归一化划分谱算法（normalized cut spectral algorithm）。<br>这里作者主要对另一篇论文(Multiclass spectral clustering)进行简单描述，将归一化划分准则等价于下列</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%207.png" alt="Untitled"></p><p>其中</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%208.png" alt="Untitled"></p><p>X是一个用于划分的n×k指示器矩阵</p><h1 id="THE-SPECTRAL-CONNECTION"><a href="#THE-SPECTRAL-CONNECTION" class="headerlink" title="THE SPECTRAL CONNECTION"></a>THE SPECTRAL CONNECTION</h1><p>乍一看，Weighted Kernel k-means和使用谱聚类的归一化切割似乎有很大的不同。毕竟，谱聚类使用特征向量来帮助确定分区，而特征向量没有出现在核k-means中。</p><p>然而，我们看到归一化切割问题可以表示为一个轨迹最大化(trace maximization)问题，在这一节中，我们展示了如何将Weighted Kernelk-means也表示为一个轨迹最大化问题。这将展示如何连接这两种聚类方法。</p><p>首先对πj 进行一个变形：</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%209.png" alt="Untitled"></p><p>$π_j$表示集群（簇）</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%2010.png" alt="Untitled"></p><p>之后定义：</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%2011.png" alt="Untitled"></p><p>其中$s_j$表示$π_j$的权重之和</p><p>$W$是所有点$w_i$权重的对角矩阵，$W_j$是$π_j$中权重的对角矩阵。</p><p>将均值向量$m_j$改为：</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%2012.png" alt="Untitled"></p><p>其中，W是所有点wi权重的对角矩阵，Wj是πj中权重的对角矩阵，Φj是与簇$π_j$相关的点矩阵，e是所有大小合适的向量</p><p>通过上述公式，可以将$π_j$的变形改为：</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%2013.png" alt="Untitled"></p><p>由于：</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%2014.png" alt="Untitled"></p><p>且：</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%2015.png" alt="Untitled"></p><p>是一个正交的投影，P$^2$=P，因为</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%2016.png" alt="Untitled"></p><p>因此又可以得到：</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%2017.png" alt="Untitled"></p><p>如果将点的完整矩阵表示为Φ=[Φ1，Φ2，…，Φk]，那么就得到：</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%2018.png" alt="Untitled"></p><p>Y是一个n×k的正交矩阵，即Y $^T$Y = I</p><p>由于trace($ΦWΦ^T$)是一个常数，所以我们加权核k-means的目标函数(（1）中目标函数的最小化）等价于trace($Y^T W ^1/2Φ^TΦW^1/2Y$)的最大化，其中$Φ^TΦ$就是数据的核矩阵K，因此可以化为trace($Y^T W ^1/2KW^1/2Y$)</p><h1 id="IMPLICATIONS"><a href="#IMPLICATIONS" class="headerlink" title="IMPLICATIONS"></a>IMPLICATIONS</h1><h3 id="Normalized-Cuts-using-Weighted-Kernel-k-means"><a href="#Normalized-Cuts-using-Weighted-Kernel-k-means" class="headerlink" title="Normalized Cuts using Weighted Kernel k-means"></a>Normalized Cuts using Weighted Kernel k-means</h3><p>使用加权核k均值的归一化切割</p><h3 id="Kernel-k-means-using-Eigenvectors"><a href="#Kernel-k-means-using-Eigenvectors" class="headerlink" title="Kernel k-means using Eigenvectors"></a>Kernel k-means using Eigenvectors</h3><p>使用特征向量的核k均值</p><h3 id="Interpreting-NJW-As-Kernel-k-means"><a href="#Interpreting-NJW-As-Kernel-k-means" class="headerlink" title="Interpreting NJW As Kernel k-means"></a>Interpreting NJW As Kernel k-means</h3><p>将NJW解释为核k-means</p><h1 id="EXPERIMENTAL-RESULTS"><a href="#EXPERIMENTAL-RESULTS" class="headerlink" title="EXPERIMENTAL RESULTS"></a>EXPERIMENTAL RESULTS</h1><p>首先用2度多项式核k均值说明基因的“直径聚类”</p><p>证明了用特征向量初始化核k-means可以得到更好的初始和最终目标函数值和更好的聚类结果。因此，谱聚类与核kmeans之间的理论联系有助于获得更高质量的结果。</p><p>最后，我们展示了我们的距离估计技术节省了大量的计算时间，验证了我们的方法的可扩展性。</p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><ul><li>Rosetta Inpharmatics的酵母数据集在300种条件下有5246个基因。</li><li>UCI机器学习库(<a href="ftp://ftp.ics.uci.edu/">ftp://ftp.ics.uci.edu/</a> pub/machine-learningdatabases/ Pendigits)下载，该库包含手写数字的(x, y)坐标。该数据集包含7494个训练数字和3498个测试数字。每个数字都表示为16维空间中的一个向量。</li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><ul><li>We first illustrate “diametric clustering” of genes with degree2 polynomial kernel k-means.<br>首先用2度多项式kernel k-means证明了基因的“相反聚类”</li><li>with the handwriting recognition data set, we show that using eigenvectors to initialize kernel k-means gives better initial and final objective function values and better clustering results.<br>利用手写识别数据集，证明了用特征向量初始化kernel k-means可以得到更好的初始和最终目标函数值以及更好的聚类结果。</li><li>谱聚类与kernel kmeans之间的理论联系有助于获得更高质量的结果。</li><li>最后，作者展示了距离估计技术节省了大量的计算时间，验证了方法的可扩展性</li></ul><h3 id="Diametrical-Clustering-of-Gene-Expression-Data（基因表达数据的聚类）"><a href="#Diametrical-Clustering-of-Gene-Expression-Data（基因表达数据的聚类）" class="headerlink" title="Diametrical Clustering of Gene Expression Data（基因表达数据的聚类）:"></a>Diametrical Clustering of Gene Expression Data（基因表达数据的聚类）:</h3><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%2019.png" alt="Untitled"></p><ul><li>在基因表达聚类中，识别基因之间的反相关关系是很重要的，因为已经观察到，表达模式强烈反相关的基因也可能在功能上相似。</li><li>结果：2次多项式kernel k-means捕获了与相反聚类算法捕获的反相关。与论文“Diametrical clustering for identifying anti-correlated gene clusters”结果一致</li></ul><h3 id="Clustering-Handwriting-Recognition-Data-Set（聚类笔迹识别数据集）"><a href="#Clustering-Handwriting-Recognition-Data-Set（聚类笔迹识别数据集）" class="headerlink" title="Clustering Handwriting Recognition Data Set（聚类笔迹识别数据集）"></a>Clustering Handwriting Recognition Data Set（聚类笔迹识别数据集）</h3><p>使用谱聚类的初始化kernel k-means输出通常可以产生比纯随机初始化更好的聚类结果。</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%2020.png" alt="Untitled"></p><p>NMI值越高，表示聚类和真实类标签匹配越好</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%2021.png" alt="Untitled"></p><p>同时，作者还提出了“三角不等式估计”（triangle inequality estimation mentioned）的方法，以此计算距离</p><p><img src="/2022/04/20/Kernel%20k-means,%20Spectral%20Clustering%20and%20Normalized/Untitled%2022.png" alt="Untitled"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>论文总结了传统的核k-means方法和谱聚类的方法，这两种方法看似是不相关的，但其实通过一定的公式推导和理论的证明，可以得到核k-means的方法也可以表达成为谱聚类那样的最大化迹的形式。</p><p>证明了weighted kernel k-means公式是非常通用的，并且归一化切割目标可以重铸为weighted kernel k-means 目标函数的一个特例。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Introducetion: 数据挖掘：k-means聚类介绍&lt;br&gt;Topic: Data Mining&lt;br&gt;URL: &lt;a href=&quot;https://dl.acm.org/doi/abs/10.1145/1014052.1014118&quot;&gt;https://dl.acm.org/doi/abs/10.1145/1014052.1014118&lt;/a&gt;&lt;br&gt;Where: KDD&lt;br&gt;Year: 2004&lt;/p&gt;</summary>
    
    
    
    <category term="Data mining" scheme="http://example.com/categories/Data-mining/"/>
    
    
    <category term="Paper Reading" scheme="http://example.com/tags/Paper-Reading/"/>
    
    <category term="Data mining" scheme="http://example.com/tags/Data-mining/"/>
    
  </entry>
  
  <entry>
    <title>Pande使用：record与replay</title>
    <link href="http://example.com/2022/04/04/Pande%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/04/04/Pande%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</id>
    <published>2022-04-04T02:00:00.000Z</published>
    <updated>2022-09-21T12:16:19.258Z</updated>
    
    <content type="html"><![CDATA[<p>record（记录）与replay（回放）是Panda的两个重要功能，本文在完成这两个功能的自动化处理的同时，还简单使用到了Panda的插件功能。<br>主要基于以下教程，但在复现过程中会遇到一些原文中没有提到的问题</p><p><a href="https://adalogics.com/blog/Building-a-custom-malware-sandbox-with-PANDA-Part-1">Building a custom malware sandbox with PANDA - Part 1</a></p><span id="more"></span><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><hr><ul><li>首先需要一个windows镜像，并生成对应的qcow2文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a working directory</span></span><br><span class="line">mkdir sandbox_base</span><br><span class="line"><span class="built_in">cd</span> sandbox_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download the disk image from Microsofts&#x27; website</span></span><br><span class="line"><span class="comment"># (URL from https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/)</span></span><br><span class="line">wget https://az792536.vo.msecnd.net/vms/VMBuild_20150916/VirtualBox/IE8/IE8.Win7.VirtualBox.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Unzip the virtualbox zip</span></span><br><span class="line">unzip IE8.Win7.VirtualBox.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Untar the .ova</span></span><br><span class="line">tar -xvf IE8\ -\ Win7.ova</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a qcow image from the .vmdk file.</span></span><br><span class="line"><span class="comment">## First install qemu utils</span></span><br><span class="line">sudo apt-get install qemu-utils</span><br><span class="line"></span><br><span class="line"><span class="comment">## Then create our image</span></span><br><span class="line">qemu-img convert -O qcow2 IE8\ -\ Win7-disk1.vmdk IE8_win7_disk1.qcow2</span><br><span class="line">chmod +x ./IE8_win7_disk1.qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment">## Clean up some of the unnecessary files</span></span><br><span class="line">rm IE8\ -\ Win7-disk1.vmdk</span><br><span class="line">rm IE8\ -\ Win7.ova</span><br></pre></td></tr></table></figure></li></ul><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><hr><h2 id="record记录"><a href="#record记录" class="headerlink" title="record记录"></a>record记录</h2><p>运行这个脚本，我们得到一个 qcow2 图像，可以在这个qcow2上运行panda</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panda/build/i386-softmmu/qemu-system-i386 IE8-win7-disk1.qcow2</span><br><span class="line"><span class="comment">#运行此命令可以启动windows镜像</span></span><br></pre></td></tr></table></figure><p>下一步就是确保可以<strong>记录和回放</strong>刚才的执行，如上一篇提到的，可以使用 PANDA 命令<code>begin_record</code><strong>，</strong><code>end_record</code>完成这一功能</p><p>运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./panda/build/i386-softmmu/panda-system-i386 -monitor stdio -show-cursor -m 8192 ./IE8_win7_disk1.qcow2</span><br></pre></td></tr></table></figure><p><img src="/2022/04/04/Pande%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Untitled.png"></p><p>产生两个文件：</p><p><img src="/2022/04/04/Pande%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Untitled%201.png"></p><p><code>sample-rr-nondet.log</code> 和 <code>sample-rr-snp</code> 是 PANDA 创建的用于重播执行的文件。 </p><ul><li><code>sample-rr-snp</code> 文件包含记录开始时的内存快照</li><li><code>sample-rr-nondet.log</code> 文件包含重放执行所需的 CPU 输入。</li></ul><h2 id="replay回放"><a href="#replay回放" class="headerlink" title="replay回放"></a>replay回放</h2><p>最后，为了回放执行，我们使用 PANDA 的 qemu 命令行参数 <code>-replay NAME</code>。 回放我们刚刚记录的执行的过程如下面的输出所示。</p><p>输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./panda/build/i386-softmmu/panda-system-i386 -monitor stdio -show-cursor -m 8192 -replay sample                                                          </span><br><span class="line">QEMU 2.9.1 monitor - <span class="built_in">type</span> <span class="string">&#x27;help&#x27;</span> <span class="keyword">for</span> more information</span><br><span class="line">(qemu) loading snapshot</span><br><span class="line">... <span class="keyword">done</span>.</span><br><span class="line">opening nondet <span class="built_in">log</span> <span class="keyword">for</span> <span class="built_in">read</span> :./sample-rr-nondet.log</span><br><span class="line">./sample-rr-nondet.log:  12257883474 instrs total.</span><br><span class="line">sample:   122578839 (  1.00%) instrs.    3.03 sec.  2.09 GB ram.</span><br><span class="line">sample:   245157670 (  2.00%) instrs.    5.30 sec.  2.16 GB ram.</span><br><span class="line">sample:   367736508 (  3.00%) instrs.    7.08 sec.  2.21 GB ram.</span><br><span class="line">sample:   490315339 (  4.00%) instrs.    8.93 sec.  2.26 GB ram.</span><br><span class="line">sample:   612894177 (  5.00%) instrs.   10.51 sec.  2.28 GB ram.</span><br><span class="line">sample:   735473011 (  6.00%) instrs.   12.59 sec.  2.30 GB ram.</span><br><span class="line">sample:   858051847 (  7.00%) instrs.   14.14 sec.  2.31 GB ram.</span><br><span class="line">sample:   980630679 (  8.00%) instrs.   15.67 sec.  2.32 GB ram.</span><br><span class="line">sample:  1103209513 (  9.00%) instrs.   17.13 sec.  2.35 GB ram.</span><br><span class="line">sample:  1225788351 ( 10.00%) instrs.   19.25 sec.  2.36 GB ram.</span><br><span class="line">sample:  1348367183 ( 11.00%) instrs.   21.67 sec.  2.39 GB ram.</span><br><span class="line">sample:  1470946025 ( 12.00%) instrs.   23.74 sec.  2.42 GB ram.</span><br><span class="line">sample:  1593524854 ( 13.00%) instrs.   25.30 sec.  2.43 GB ram.</span><br><span class="line">sample:  1716103692 ( 14.00%) instrs.   26.59 sec.  2.44 GB ram.</span><br><span class="line">sample:  1838682533 ( 15.00%) instrs.   28.35 sec.  2.48 GB ram.</span><br><span class="line">sample:  1961261358 ( 16.00%) instrs.   30.05 sec.  2.49 GB ram.</span><br><span class="line">sample:  2083840197 ( 17.00%) instrs.   31.73 sec.  2.50 GB ram.</span><br><span class="line">sample:  2206419030 ( 18.00%) instrs.   33.05 sec.  2.50 GB ram.</span><br><span class="line">sample:  2328997867 ( 19.00%) instrs.   34.10 sec.  2.51 GB ram.</span><br><span class="line">sample:  2451576695 ( 20.00%) instrs.   34.86 sec.  2.51 GB ram.</span><br><span class="line">sample:  2574155533 ( 21.00%) instrs.   35.62 sec.  2.51 GB ram.</span><br><span class="line">sample:  2696734368 ( 22.00%) instrs.   36.34 sec.  2.51 GB ram.</span><br><span class="line">sample:  2819313201 ( 23.00%) instrs.   37.15 sec.  2.51 GB ram.</span><br><span class="line">sample:  2941892037 ( 24.00%) instrs.   37.90 sec.  2.51 GB ram.</span><br><span class="line">sample:  3064470870 ( 25.00%) instrs.   38.64 sec.  2.51 GB ram.</span><br><span class="line">sample:  3187049706 ( 26.00%) instrs.   39.37 sec.  2.51 GB ram.</span><br><span class="line">sample:  3309628543 ( 27.00%) instrs.   40.14 sec.  2.53 GB ram.</span><br><span class="line">sample:  3432207378 ( 28.00%) instrs.   40.90 sec.  2.53 GB ram.</span><br><span class="line">sample:  3554786210 ( 29.00%) instrs.   41.67 sec.  2.53 GB ram.</span><br><span class="line">sample:  3677365047 ( 30.00%) instrs.   42.44 sec.  2.53 GB ram.</span><br><span class="line">sample:  3799943884 ( 31.00%) instrs.   43.20 sec.  2.53 GB ram.</span><br><span class="line">sample:  3922522712 ( 32.00%) instrs.   44.01 sec.  2.53 GB ram.</span><br><span class="line">sample:  4045101555 ( 33.00%) instrs.   44.80 sec.  2.53 GB ram.</span><br><span class="line">sample:  4167680384 ( 34.00%) instrs.   46.56 sec.  2.54 GB ram.</span><br><span class="line">sample:  4290259220 ( 35.00%) instrs.   47.72 sec.  2.54 GB ram.</span><br><span class="line">sample:  4412838054 ( 36.00%) instrs.   48.71 sec.  2.54 GB ram.</span><br><span class="line">sample:  4535416896 ( 37.00%) instrs.   50.03 sec.  2.55 GB ram.</span><br><span class="line">sample:  4657995732 ( 38.00%) instrs.   51.02 sec.  2.55 GB ram.</span><br><span class="line">sample:  4780574563 ( 39.00%) instrs.   52.02 sec.  2.55 GB ram.</span><br><span class="line">sample:  4903153392 ( 40.00%) instrs.   53.05 sec.  2.56 GB ram.</span><br><span class="line">sample:  5025732229 ( 41.00%) instrs.   54.11 sec.  2.56 GB ram.</span><br><span class="line">sample:  5148311061 ( 42.00%) instrs.   55.59 sec.  2.57 GB ram.</span><br><span class="line">sample:  5270889895 ( 43.00%) instrs.   57.61 sec.  2.58 GB ram.</span><br><span class="line">sample:  5393468732 ( 44.00%) instrs.   59.63 sec.  2.58 GB ram.</span><br><span class="line">sample:  5516047564 ( 45.00%) instrs.   61.49 sec.  2.60 GB ram.</span><br><span class="line">sample:  5638626404 ( 46.00%) instrs.   62.96 sec.  2.62 GB ram.</span><br><span class="line">sample:  5761205244 ( 47.00%) instrs.   63.83 sec.  2.66 GB ram.</span><br><span class="line">sample:  5883784083 ( 48.00%) instrs.   64.33 sec.  2.66 GB ram.</span><br><span class="line">sample:  6006362907 ( 49.00%) instrs.   65.52 sec.  2.66 GB ram.</span><br><span class="line">sample:  6128941737 ( 50.00%) instrs.   67.38 sec.  2.67 GB ram.</span><br><span class="line">sample:  6251520574 ( 51.00%) instrs.   68.85 sec.  2.67 GB ram.</span><br><span class="line">sample:  6374099413 ( 52.00%) instrs.   71.54 sec.  2.68 GB ram.</span><br><span class="line">sample:  6496678244 ( 53.00%) instrs.   73.11 sec.  2.70 GB ram.</span><br><span class="line">sample:  6619257095 ( 54.00%) instrs.   75.17 sec.  2.72 GB ram.</span><br><span class="line">sample:  6741835915 ( 55.00%) instrs.   76.67 sec.  2.75 GB ram.</span><br><span class="line">sample:  6864414747 ( 56.00%) instrs.   78.02 sec.  2.77 GB ram.</span><br><span class="line">sample:  6986993585 ( 57.00%) instrs.   79.43 sec.  2.78 GB ram.</span><br><span class="line">sample:  7109572416 ( 58.00%) instrs.   81.03 sec.  2.79 GB ram.</span><br><span class="line">sample:  7232151255 ( 59.00%) instrs.   81.99 sec.  2.79 GB ram.</span><br><span class="line">sample:  7354730096 ( 60.00%) instrs.   83.04 sec.  2.79 GB ram.</span><br><span class="line">sample:  7477308922 ( 61.00%) instrs.   84.02 sec.  2.79 GB ram.</span><br><span class="line">sample:  7599887756 ( 62.00%) instrs.   85.07 sec.  2.82 GB ram.</span><br><span class="line">sample:  7722466590 ( 63.00%) instrs.   85.93 sec.  2.91 GB ram.</span><br><span class="line">sample:  7845045425 ( 64.00%) instrs.   86.94 sec.  2.92 GB ram.</span><br><span class="line">sample:  7967624263 ( 65.00%) instrs.   89.36 sec.  2.92 GB ram.</span><br><span class="line">sample:  8090203100 ( 66.00%) instrs.   91.36 sec.  2.92 GB ram.</span><br><span class="line">sample:  8212781928 ( 67.00%) instrs.   92.56 sec.  2.93 GB ram.</span><br><span class="line">sample:  8335360763 ( 68.00%) instrs.   93.53 sec.  2.93 GB ram.</span><br><span class="line">sample:  8457939599 ( 69.00%) instrs.   94.50 sec.  2.93 GB ram.</span><br><span class="line">sample:  8580518433 ( 70.00%) instrs.   95.51 sec.  2.93 GB ram.</span><br><span class="line">sample:  8703097273 ( 71.00%) instrs.   97.64 sec.  2.96 GB ram.</span><br><span class="line">sample:  8825676104 ( 72.00%) instrs.   99.93 sec.  2.98 GB ram.</span><br><span class="line">sample:  8948254945 ( 73.00%) instrs.  102.09 sec.  2.98 GB ram.</span><br><span class="line">sample:  9070833775 ( 74.00%) instrs.  103.77 sec.  3.00 GB ram.</span><br><span class="line">sample:  9193412614 ( 75.00%) instrs.  105.20 sec.  3.00 GB ram.</span><br><span class="line">sample:  9315991448 ( 76.00%) instrs.  106.58 sec.  3.00 GB ram.</span><br><span class="line">sample:  9438570277 ( 77.00%) instrs.  108.09 sec.  3.01 GB ram.</span><br><span class="line">sample:  9561149110 ( 78.00%) instrs.  109.48 sec.  3.02 GB ram.</span><br><span class="line">sample:  9683727949 ( 79.00%) instrs.  111.43 sec.  3.03 GB ram.</span><br><span class="line">sample:  9806306784 ( 80.00%) instrs.  113.25 sec.  3.03 GB ram.</span><br><span class="line">sample:  9928885615 ( 81.00%) instrs.  115.41 sec.  3.04 GB ram.</span><br><span class="line">sample:  10051464450 ( 82.00%) instrs.  117.09 sec.  3.06 GB ram.</span><br><span class="line">sample:  10174043284 ( 83.00%) instrs.  119.48 sec.  3.08 GB ram.</span><br><span class="line">sample:  10296622121 ( 84.00%) instrs.  121.13 sec.  3.09 GB ram.</span><br><span class="line">sample:  10419200982 ( 85.00%) instrs.  121.95 sec.  3.09 GB ram.</span><br><span class="line">sample:  10541779795 ( 86.00%) instrs.  122.45 sec.  3.10 GB ram.</span><br><span class="line">sample:  10664358635 ( 87.00%) instrs.  123.53 sec.  3.13 GB ram.</span><br><span class="line">sample:  10786937459 ( 88.00%) instrs.  124.43 sec.  3.14 GB ram.</span><br><span class="line">sample:  10909516309 ( 89.00%) instrs.  125.78 sec.  3.15 GB ram.</span><br><span class="line">sample:  11032095129 ( 90.00%) instrs.  126.66 sec.  3.15 GB ram.</span><br><span class="line">sample:  11154673962 ( 91.00%) instrs.  127.90 sec.  3.16 GB ram.</span><br><span class="line">sample:  11277252798 ( 92.00%) instrs.  128.95 sec.  3.16 GB ram.</span><br><span class="line">sample:  11399831631 ( 93.00%) instrs.  130.46 sec.  3.16 GB ram.</span><br><span class="line">sample:  11522410472 ( 94.00%) instrs.  131.79 sec.  3.17 GB ram.</span><br><span class="line">sample:  11644989304 ( 95.00%) instrs.  133.26 sec.  3.19 GB ram.</span><br><span class="line">sample:  11767568137 ( 96.00%) instrs.  134.75 sec.  3.19 GB ram.</span><br><span class="line">sample:  11890146970 ( 97.00%) instrs.  136.06 sec.  3.20 GB ram.</span><br><span class="line">sample:  12012725817 ( 98.00%) instrs.  137.22 sec.  3.20 GB ram.</span><br><span class="line">sample:  12135304642 ( 99.00%) instrs.  138.58 sec.  3.20 GB ram.</span><br><span class="line">./sample-rr-nondet.log:  <span class="built_in">log</span> is empty.</span><br><span class="line">./sample-rr-nondet.log:  <span class="built_in">log</span> is empty.</span><br><span class="line">Time taken was: 143 seconds.</span><br><span class="line">Stats:</span><br><span class="line">RR_INPUT_1 number = 0, size = 0 bytes</span><br><span class="line">RR_INPUT_2 number = 0, size = 0 bytes</span><br><span class="line">RR_INPUT_4 number = 52356, size = 732984 bytes</span><br><span class="line">RR_INPUT_8 number = 263807, size = 4748526 bytes</span><br><span class="line">RR_INTERRUPT_REQUEST number = 41100, size = 575400 bytes</span><br><span class="line">RR_EXIT_REQUEST number = 0, size = 0 bytes</span><br><span class="line">RR_SKIPPED_CALL number = 34033, size = 76861370 bytes</span><br><span class="line">RR_END_OF_LOG number = 1, size = 10 bytes</span><br><span class="line">RR_PENDING_INTERRUPTS number = 0, size = 0 bytes</span><br><span class="line">RR_EXCEPTION number = 0, size = 0 bytes</span><br><span class="line">max_queue_len = 821</span><br><span class="line">Replay completed successfully</span><br><span class="line">Exiting cpu_handle_execption loop</span><br></pre></td></tr></table></figure><h3 id="减少分析时间"><a href="#减少分析时间" class="headerlink" title="减少分析时间"></a>减少分析时间</h3><p>回放仿真是会消耗许多时间，可以在客户系统内将性能提至最优，以达到提高分析速度的效果。以本实验使用的客户系统win7系统为例，在计算机属性内找到如下选项，选择“Adjust for best performance”并保存，即可提高分析速度。</p><p><img src="/2022/04/04/Pande%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Untitled%202.png"></p><h1 id="分析特定样本"><a href="#分析特定样本" class="headerlink" title="分析特定样本"></a>分析特定样本</h1><p>此时，我们可以使用 PANDA 记录执行并重放它，但是，我们仍然需要一种机制来允许我们记录目标应用程序的执行。目标是拥有一种灵活的方法，允许我们将应用程序从主机环境转移到客户（guest）环境，然后在客户（guest）环境中启动应用程序的执行。此外，我们希望在客户系统内不部署任何脚本或类似内容的情况下执行此操作。</p><h2 id="设置适当的快照"><a href="#设置适当的快照" class="headerlink" title="设置适当的快照"></a>设置适当的快照</h2><p>首先必须将虚拟机设置为可以轻松地从盒子外面执行我们的应用程序的状态。</p><p>方法：在客户系统中打开一个命令提示符，然后保存虚拟机状态。之后通过发送适当的击键从框外与命令提示符交互来利用此快照。</p><p>为了创建快照，在Panda中启动虚拟机并在客户环境中启动Windows命令行界面（要保证光标在界面上），如图所示：</p><p><img src="/2022/04/04/Pande%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Untitled%203.png"></p><p>此时，在QEMU命令行界面中使用<code>savevm</code>命令，保存虚拟机的状态，并创建一个快照。</p><p><img src="/2022/04/04/Pande%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Untitled%204.png"></p><p>我们可以启动这个快照，并且由于命令提示符在客户环境内，可以通过向机器发送按键keystrokes从外部控制客户机。</p><p>启动快照命令：<code>-loadvm</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./panda/build/i386-softmmu/panda-system-i386 -monitor stdio -show-cursor -m 8192 ./IE8_win7_disk1.qcow2 -loadvm 1</span><br></pre></td></tr></table></figure><p>可以很快地启动快照客户环境</p><h2 id="构建其他基础设置"><a href="#构建其他基础设置" class="headerlink" title="构建其他基础设置"></a>构建其他基础设置</h2><h3 id="记录样本程序的执行"><a href="#记录样本程序的执行" class="headerlink" title="记录样本程序的执行"></a>记录样本程序的执行</h3><p>上一步已设置了一个合适的快照，接下来要创建将应用程序发送到 VM 并在 VM 内启动应用程序的结构。</p><ul><li>方法：将样本转换为 .iso 文件，将这个 .iso 文件挂载到我们的虚拟机中，然后指示虚拟机从盒子外部抓取其 cd-rom 中的文件并将其作为应用程序启动。</li></ul><p>我们将向客户机发送按键，这将触发命令提示符中的以下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">copy D:\\sample C:\\Users\\IEUser\\Desktop\\sample.exe</span><br><span class="line">start C:\\Users\\IEUser\\Desktop\\sample.exe</span><br></pre></td></tr></table></figure><p>使用以下python脚本执行这个过程：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></span><br><span class="line"><span class="comment">#vm_record.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">PANDA_BASE = os.path.join(os.getcwd(), <span class="string">&quot;panda&quot;</span>)</span><br><span class="line">PANDA_x86 = os.path.join(PANDA_BASE, <span class="string">&quot;build&quot;</span>, <span class="string">&quot;i386-softmmu&quot;</span>, <span class="string">&quot;panda-system-i386&quot;</span>)</span><br><span class="line">IMG_PATH = os.path.join(os.getcwd(), <span class="string">&quot;IE8_win7_disk1.qcow2&quot;</span>)</span><br><span class="line"></span><br><span class="line">PANDA_flags = [</span><br><span class="line">        <span class="string">&quot;-monitor&quot;</span>, <span class="string">&quot;stdio&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-show-cursor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-m&quot;</span>, <span class="string">&quot;8192&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-loadvm&quot;</span>, <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        IMG_PATH</span><br><span class="line">    ]</span><br><span class="line">TIME_TO_EXECUTE = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_info</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] %s&quot;</span>%(msg))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_exit</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] %s&quot;</span>%(msg))</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">guest_type</span>(<span class="params">s, p</span>):</span></span><br><span class="line"><span class="comment">#cmd</span></span><br><span class="line">    <span class="comment">#cmd命令转换</span></span><br><span class="line">    keymap = &#123;</span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: <span class="string">&#x27;minus&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;=&#x27;</span>: <span class="string">&#x27;equal&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;bracket_left&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;bracket_right&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;;&#x27;</span>: <span class="string">&#x27;semicolon&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;\&#x27;&#x27;</span>: <span class="string">&#x27;apostrophe&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;\\&#x27;</span>: <span class="string">&#x27;backslash&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;,&#x27;</span>: <span class="string">&#x27;comma&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span>: <span class="string">&#x27;dot&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: <span class="string">&#x27;slash&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span>: <span class="string">&#x27;asterisk&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>: <span class="string">&#x27;spc&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;_&#x27;</span>: <span class="string">&#x27;shift-minus&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: <span class="string">&#x27;shift-equal&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;shift-bracket_left&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;shift-bracket_right&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;:&#x27;</span>: <span class="string">&#x27;shift-semicolon&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&quot;&#x27;</span>: <span class="string">&#x27;shift-apostrophe&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;|&#x27;</span>: <span class="string">&#x27;shift-backslash&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&lt;&#x27;</span>: <span class="string">&#x27;shift-comma&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&gt;&#x27;</span>: <span class="string">&#x27;shift-dot&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;?&#x27;</span>: <span class="string">&#x27;shift-slash&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;\n&#x27;</span>: <span class="string">&#x27;ret&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> string.ascii_uppercase:</span><br><span class="line">            key = <span class="string">&#x27;shift-&#x27;</span> + c.lower()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            key = keymap.get(c, c)</span><br><span class="line">        str_sendkey = <span class="string">&quot;sendkey &quot;</span>+<span class="string">&quot;%s&quot;</span>%(key)+<span class="string">&quot;\n&quot;</span></span><br><span class="line">        p.stdin.write(str_sendkey.encode())</span><br><span class="line">        p.stdin.flush()</span><br><span class="line">        time.sleep(<span class="number">.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_execution</span>(<span class="params">sample, recording_time</span>):</span></span><br><span class="line">    <span class="comment">#执行记录程序</span></span><br><span class="line">    log_info(<span class="string">&quot;Recording execution %s&quot;</span>%(sample))</span><br><span class="line">    log_info(<span class="string">&quot;Recording for %d seconds&quot;</span>%(recording_time))</span><br><span class="line"></span><br><span class="line">    new_sample = <span class="string">&quot;sample&quot;</span></span><br><span class="line">    shutil.copy(sample, new_sample)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建目标程序对应的ISO文件</span></span><br><span class="line">    cmd = []</span><br><span class="line">    cmd.append(<span class="string">&quot;/usr/bin/genisoimage&quot;</span>)</span><br><span class="line">    cmd.append(<span class="string">&quot;-iso-level&quot;</span>)</span><br><span class="line">    cmd.append(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    cmd.append(<span class="string">&quot;-l&quot;</span>)</span><br><span class="line">    cmd.append(<span class="string">&quot;-R&quot;</span>)</span><br><span class="line">    cmd.append(<span class="string">&quot;-J&quot;</span>)</span><br><span class="line">    cmd.append(<span class="string">&quot;-o&quot;</span>)</span><br><span class="line">    cmd.append(<span class="string">&quot;sample.iso&quot;</span>)</span><br><span class="line">    cmd.append(new_sample)    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        subprocess.check_call(cmd)</span><br><span class="line">        log_info(<span class="string">&quot;Made an iso file for the sample&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(traceback.format_exc())</span><br><span class="line">        <span class="built_in">print</span>(sys.exc_info()[<span class="number">0</span>])</span><br><span class="line">        log_exit(<span class="string">&quot;Could not make any iso file for the sample&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#运行Panda</span></span><br><span class="line">    cmd = []</span><br><span class="line">    cmd.append(PANDA_x86)</span><br><span class="line">    <span class="keyword">for</span> flag <span class="keyword">in</span> PANDA_flags:</span><br><span class="line">        cmd.append(flag)</span><br><span class="line">    panda_stdout_path = <span class="string">&quot;panda.stdout&quot;</span></span><br><span class="line">    panda_stderr_path = <span class="string">&quot;panda.stderr&quot;</span></span><br><span class="line">    panda_stdout = <span class="built_in">open</span>(panda_stdout_path, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line">    panda_stderr = <span class="built_in">open</span>(panda_stderr_path, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Executing command: %s&quot;</span>%(<span class="string">&quot; &quot;</span>.join(cmd)))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = subprocess.Popen(cmd,</span><br><span class="line">                stdin = subprocess.PIPE,</span><br><span class="line">                stdout = panda_stdout,</span><br><span class="line">                stderr = panda_stderr)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line">    str_mark = <span class="string">&quot;MARK\n&quot;</span></span><br><span class="line">    p.stdin.write(str_mark.encode())</span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    <span class="comment"># 检查虚拟机何时准备好让我们与之交互</span></span><br><span class="line">    f_out = <span class="built_in">open</span>(panda_stdout_path, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        content = f_out.read()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;M&quot;</span> <span class="keyword">in</span> content:</span><br><span class="line">            log_info(<span class="string">&quot;VM started&quot;</span>)  </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        f_out.seek(<span class="number">0</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置 QEMU，以便将 sample.iso 文件挂载到 cdrom 中。</span></span><br><span class="line">    p.stdin.write(<span class="string">b&quot;change ide1-cd0 sample.iso\n&quot;</span>)   </span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在win7中，cdrom会打开一个窗口，使用esc可以关闭</span></span><br><span class="line">    p.stdin.write(<span class="string">b&quot;sendkey esc\n&quot;</span>) </span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    <span class="comment"># 向客户系统中发送命令（通过qemu向刚刚打开的cmd窗口输送）</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    calc_cmd = <span class="string">&quot;calc\n&quot;</span></span><br><span class="line">    guest_type(calc_cmd, p)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    copy_cmd = <span class="string">&quot; copy D:\\sample C:\\Users\\IEUser\\Desktop\\sample.exe\n&quot;</span></span><br><span class="line">    guest_type(copy_cmd, p)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意这里并没有立即执行程序（没有添加\n），因为想在之后的begin_record后再执行它</span></span><br><span class="line">    start_cmd = <span class="string">&quot;start C:\\Users\\IEUser\\Desktop\\sample.exe&quot;</span></span><br><span class="line">    guest_type(start_cmd, p)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行程序前，开始记录</span></span><br><span class="line">    p.stdin.write(<span class="string">b&quot;begin_record sample\n&quot;</span>)</span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    <span class="comment"># 发送\n执行刚才输入的命令（执行sample.exe程序）</span></span><br><span class="line">    guest_type(<span class="string">&quot;\n&quot;</span>, p)     </span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Started recording and executed the sample in the guest machine&quot;</span>)</span><br><span class="line">    log_info(<span class="string">&quot;Recording for: %d seconds&quot;</span>%(TIME_TO_EXECUTE))</span><br><span class="line">    time.sleep(TIME_TO_EXECUTE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结束记录</span></span><br><span class="line">    p.stdin.write(<span class="string">b&quot;end_record\n&quot;</span>)</span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    <span class="comment"># 向qemu发送&#x27;q&#x27;退出环境</span></span><br><span class="line">    p.stdin.write(<span class="string">b&quot;q\n&quot;</span>)</span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    log_info(<span class="string">&quot;Recording is over, shutting the VM down&quot;</span>)</span><br><span class="line">    p.stdin.write(<span class="string">b&quot;q\n&quot;</span>)</span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        poll = p.poll()</span><br><span class="line">        <span class="keyword">if</span> poll == <span class="literal">None</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            log_info(<span class="string">&quot;VM is shut down&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Finished recording the sample execution&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(</span><br><span class="line">            <span class="string">&quot;-sample&quot;</span>, </span><br><span class="line">            <span class="built_in">help</span> = <span class="string">&quot;The sample to executed&quot;</span>,</span><br><span class="line">            required = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">            <span class="string">&quot;-time&quot;</span>,</span><br><span class="line">            <span class="built_in">help</span> = <span class="string">&quot;The number of seconds to record an execution&quot;</span>,</span><br><span class="line">            <span class="built_in">type</span> = <span class="built_in">int</span>,</span><br><span class="line">            default = <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args(args = sys.argv[<span class="number">1</span>:])</span><br><span class="line">    record_execution(args.sample, args.time)</span><br></pre></td></tr></table></figure><p>这里遇到一个问题，在<code>p.stdin.write</code>后，如果不使用<code>flush()</code>，会导致qemu接收不到输入（原文中并没有使用）</p><p>脚本使用方式：其中<code>-sample</code>参数提供主机系统上将在录制期间执行的样本的路径。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 vm_record.py -sample ./sample.exe</span><br><span class="line">[+] Recording execution ./sample.exe</span><br><span class="line">[+] Recording <span class="keyword">for</span> 25 seconds</span><br><span class="line">Warning: Creating ISO-9660:1999 (version 2) filesystem.</span><br><span class="line">Warning: ISO-9660 filenames longer than 31 may cause buffer overflows <span class="keyword">in</span> the OS.</span><br><span class="line">Total translation table size: 0</span><br><span class="line">Total rockridge attributes bytes: 247</span><br><span class="line">Total directory bytes: 0</span><br><span class="line">Path table size(bytes): 10</span><br><span class="line">Max brk space used 0</span><br><span class="line">241 extents written (0 MB)</span><br><span class="line">[+] Made an iso file <span class="keyword">for</span> the sample</span><br><span class="line">[+] Executing <span class="built_in">command</span>: /root/Desktop/panda/build/i386-softmmu/panda-system-i386 -monitor stdio -show-cursor -m 8192 -loadvm 1 /root/Desktop/IE8_win7_disk1.qcow2</span><br><span class="line">[+] VM started</span><br><span class="line">[+] Started recording and executed the sample <span class="keyword">in</span> the guest machine</span><br><span class="line">[+] Recording <span class="keyword">for</span>: 20 seconds</span><br><span class="line">[+] Recording is over, shutting the VM down</span><br><span class="line">[+] VM is shut down</span><br><span class="line">[+] Finished recording the sample execution</span><br></pre></td></tr></table></figure><h3 id="重放回放（Replaying-a-recording）"><a href="#重放回放（Replaying-a-recording）" class="headerlink" title="重放回放（Replaying a recording）"></a>重放回放（<strong>Replaying a recording</strong>）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></span><br><span class="line"><span class="comment">#vm_replay.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configs</span></span><br><span class="line">PANDA_BASE = os.path.join(os.getcwd(), <span class="string">&quot;panda&quot;</span>)</span><br><span class="line">PANDA_x86 = os.path.join(PANDA_BASE, <span class="string">&quot;build&quot;</span>, <span class="string">&quot;i386-softmmu&quot;</span>, <span class="string">&quot;panda-system-i386&quot;</span>)</span><br><span class="line">IMG_PATH = os.path.join(os.getcwd(), <span class="string">&quot;IE8_win7_disk1.qcow2&quot;</span>)</span><br><span class="line"></span><br><span class="line">PANDA_flags = [</span><br><span class="line">        <span class="string">&quot;-monitor&quot;</span>, <span class="string">&quot;stdio&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-show-cursor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-m&quot;</span>, <span class="string">&quot;8192&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The PADNA plugins we would like to use</span></span><br><span class="line">PANDA_plugins = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_info</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] %s&quot;</span>%(msg))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_exit</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] %s&quot;</span>%(msg))</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replay_recording</span>(<span class="params">snapshot_name</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Replays a recording</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    log_info(<span class="string">&quot;Replaying %s&quot;</span>%(snapshot_name))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Launch PANDA</span></span><br><span class="line">    cmd = []</span><br><span class="line">    cmd.append(PANDA_x86)</span><br><span class="line">    cmd.append(<span class="string">&quot;-replay&quot;</span>)</span><br><span class="line">    cmd.append(snapshot_name)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> flag <span class="keyword">in</span> PANDA_flags:</span><br><span class="line">        cmd.append(flag)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> plugin_cmdline <span class="keyword">in</span> PANDA_plugins:</span><br><span class="line">        cmd.append(plugin_cmdline)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Output files</span></span><br><span class="line">    panda_stdout_path = <span class="string">&quot;replay_panda.stdout&quot;</span></span><br><span class="line">    panda_stderr_path = <span class="string">&quot;replay_panda.stderr&quot;</span></span><br><span class="line">    panda_stdout = <span class="built_in">open</span>(panda_stdout_path, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line">    panda_stderr = <span class="built_in">open</span>(panda_stderr_path, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Launching replay %s&quot;</span>%(<span class="string">&quot; &quot;</span>.join(cmd)))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = subprocess.Popen(</span><br><span class="line">                <span class="string">&quot; &quot;</span>.join(cmd),</span><br><span class="line">                shell=<span class="literal">True</span>,</span><br><span class="line">                stdout = panda_stdout,</span><br><span class="line">                stderr = panda_stderr,</span><br><span class="line">                preexec_fn = os.setsid)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        log_exit(<span class="string">&quot;Could not complete replay&quot;</span>)</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Replay launched&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        poll = p.poll()</span><br><span class="line">        <span class="keyword">if</span> poll == <span class="literal">None</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            log_info(<span class="string">&quot;Replaying finished&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Analysis process finished, exiting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(</span><br><span class="line">            <span class="string">&quot;-recording&quot;</span>, </span><br><span class="line">            <span class="built_in">help</span> = <span class="string">&quot;The name of the recording to replay&quot;</span>,</span><br><span class="line">            required = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args(args = sys.argv[<span class="number">1</span>:])</span><br><span class="line">    replay_recording(args.recording)</span><br></pre></td></tr></table></figure><p>通过以下方式使用此脚本，其中<code>-recording</code>指定我们要重播的录音的名称</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 vm_replay.py -recording sample </span><br><span class="line">[+] Replaying sample</span><br><span class="line">[+] Launching replay /root/Desktop/panda/build/i386-softmmu/panda-system-i386 -replay sample -monitor stdio -show-cursor -m 8192</span><br><span class="line">[+] Replay launched</span><br><span class="line">[+] Replaying finished</span><br><span class="line">[+] Analysis process finished, exiting</span><br></pre></td></tr></table></figure><h1 id="使用Panda插件"><a href="#使用Panda插件" class="headerlink" title="使用Panda插件"></a>使用Panda插件</h1><p>上面创建了一个简单地框架，可以在Panda中使用记录（record）和回放（replay）程序。但绝大多数时候，我们希望能研究自己给定的程序。</p><h2 id="监控系统的进程"><a href="#监控系统的进程" class="headerlink" title="监控系统的进程"></a>监控系统的进程</h2><p>第一步我们选择使用Panda的两个虚拟机自省（virtual machine introspection (VMI)）插件<code>osi</code>和<code>wintrospection</code> ，来监控在系统上执行的进程。</p><ul><li>虚拟机自省（VMI）：主要的功能是从虚拟机外面 VMM层观察虚拟机，检查虚拟机的状态。</li></ul><p>这样做，与在客户系统中放置特定于分析的工件（例如分析驱动程序）相比，客户系统保持相对透明。缺点是必须纯粹通过<strong>观察内存</strong>来推断操作系统级别的抽象，并且不能使用正常的 Windows 提供的 API 来执行此操作。</p><p>扩展<code>vm_replay.py</code>脚本，在回放（replay）的时候启动插件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></span><br><span class="line"><span class="comment">#vm_replay.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">PANDA_BASE = os.path.join(os.getcwd(), <span class="string">&quot;panda&quot;</span>)</span><br><span class="line">PANDA_x86 = os.path.join(PANDA_BASE, <span class="string">&quot;build&quot;</span>, <span class="string">&quot;i386-softmmu&quot;</span>, <span class="string">&quot;panda-system-i386&quot;</span>)</span><br><span class="line">IMG_PATH = os.path.join(os.getcwd(), <span class="string">&quot;IE8_win7_disk1.qcow2&quot;</span>)</span><br><span class="line">PANDA_flags = [</span><br><span class="line">        <span class="string">&quot;-monitor&quot;</span>, <span class="string">&quot;stdio&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-show-cursor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-m&quot;</span>, <span class="string">&quot;8192&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用的Panda插件</span></span><br><span class="line">PANDA_plugins = [</span><br><span class="line">        <span class="string">&quot;-panda osi -os windows-32-7sp1 -panda wintrospection -panda osi_test&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_info</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] %s&quot;</span>%(msg))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_exit</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] %s&quot;</span>%(msg))</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replay_recording</span>(<span class="params">snapshot_name</span>):</span></span><br><span class="line">    <span class="comment">#回放</span></span><br><span class="line">    </span><br><span class="line">    log_info(<span class="string">&quot;Replaying %s&quot;</span>%(snapshot_name))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 运行Panda</span></span><br><span class="line">    cmd = []</span><br><span class="line">    cmd.append(PANDA_x86)</span><br><span class="line">    cmd.append(<span class="string">&quot;-replay&quot;</span>)</span><br><span class="line">    cmd.append(snapshot_name)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> flag <span class="keyword">in</span> PANDA_flags:</span><br><span class="line">        cmd.append(flag)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> plugin_cmdline <span class="keyword">in</span> PANDA_plugins:</span><br><span class="line">        cmd.append(plugin_cmdline)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出qemu运行信息</span></span><br><span class="line">    panda_stdout_path = <span class="string">&quot;replay_panda.stdout&quot;</span></span><br><span class="line">    panda_stderr_path = <span class="string">&quot;replay_panda.stderr&quot;</span></span><br><span class="line">    panda_stdout = <span class="built_in">open</span>(panda_stdout_path, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line">    panda_stderr = <span class="built_in">open</span>(panda_stderr_path, <span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Launching replay %s&quot;</span>%(<span class="string">&quot; &quot;</span>.join(cmd)))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = subprocess.Popen(</span><br><span class="line">                <span class="string">&quot; &quot;</span>.join(cmd),</span><br><span class="line">                shell=<span class="literal">True</span>,</span><br><span class="line">                stdout = panda_stdout,</span><br><span class="line">                stderr = panda_stderr,</span><br><span class="line">                preexec_fn = os.setsid)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        log_exit(<span class="string">&quot;Could not complete replay&quot;</span>)</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Replay launched&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        poll = p.poll()</span><br><span class="line">        <span class="keyword">if</span> poll == <span class="literal">None</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            log_info(<span class="string">&quot;Replaying finished&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;Analysis process finished, exiting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(</span><br><span class="line">            <span class="string">&quot;-recording&quot;</span>, </span><br><span class="line">            <span class="built_in">help</span> = <span class="string">&quot;The name of the recording to replay&quot;</span>,</span><br><span class="line">            required = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args(args = sys.argv[<span class="number">1</span>:])</span><br><span class="line">    replay_recording(args.recording)</span><br></pre></td></tr></table></figure><p>这里遇到两个坑。</p><ul><li>一是对于osi插件的指定操作系统参数-os，现版本其<a href="https://github.com/panda-re/panda/tree/dev/panda/plugins/osi#command-line-arguments">README</a>和<a href="https://github.com/panda-re/panda/blob/dev/panda/src/common.c">代码</a>里的描述有差异，开始的时候只看了README，结果一直报错不通过os检查。后来看了代码才发现问题：按照README一开始使用的<code>windows-32-7</code>，但看了代码发现应该使用<code>windows-32-7sp1</code></li><li>二是在网上的教程中，作者使用的是<code>win7x86intro</code> ，但这个插件在现版本已不能使用（没了），因此我这里选择使用<code>wintrospection</code> 这一插件替代。</li></ul><p>运行回放：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 vm_replay.py -recording sample   </span><br><span class="line">[+] Replaying sample</span><br><span class="line">[+] Launching replay /root/Desktop/panda/build/i386-softmmu/panda-system-i386 -replay sample -monitor stdio -show-cursor -m 8192 -panda osi -os windows-32-7sp1 -panda wintrospection -panda osi_test</span><br><span class="line">[+] Replay launched</span><br><span class="line">[+] Replaying finished</span><br><span class="line">[+] Analysis process finished, exiting</span><br></pre></td></tr></table></figure><p>之后在输出生产的<code>replay_panda.stdout</code>中可以看到系统状态，包括系统上执行的所有进程、当前执行进程加载的 DLL 以及内核模块。但这个文件会非常的大，这里我生成的就有341M，因为在每次发生上下文切换时都会打印系统状态。部分内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">......</span><br><span class="line">Current process: csrss.exe PID:344 PPID:324</span><br><span class="line"></span><br><span class="line">Process list (48 procs):</span><br><span class="line">  smss.exe              220     4</span><br><span class="line">  csrss.exe             296     288</span><br><span class="line">  wininit.exe           332     288</span><br><span class="line">  csrss.exe             344     324</span><br><span class="line">  winlogon.exe          372     324</span><br><span class="line">  services.exe          428     332</span><br><span class="line">  lsass.exe             444     332</span><br><span class="line">  lsm.exe               452     332</span><br><span class="line">  svchost.exe           560     428</span><br><span class="line">  svchost.exe           632     428</span><br><span class="line">  svchost.exe           680     428</span><br><span class="line">  svchost.exe           808     428</span><br><span class="line">  svchost.exe           840     428</span><br><span class="line">  svchost.exe           948     428</span><br><span class="line">  explorer.exe          1100    1092</span><br><span class="line">  dwm.exe               1152    808</span><br><span class="line">  svchost.exe           1208    428</span><br><span class="line">  spoolsv.exe           1404    428</span><br><span class="line">  taskhost.exe          1448    428</span><br><span class="line">  svchost.exe           1476    428</span><br><span class="line">  vmicsvc.exe           1624    428</span><br><span class="line">  vmicsvc.exe           1644    428</span><br><span class="line">  vmicsvc.exe           1688    428</span><br><span class="line">  vmicsvc.exe           1720    428</span><br><span class="line">vmicsvc.exe           1748    428</span><br><span class="line">  svchost.exe           1784    428</span><br><span class="line">  cygrunsrv.exe         1920    428</span><br><span class="line">  wlms.exe              1976    428</span><br><span class="line">  cygrunsrv.exe         624     1920</span><br><span class="line">  conhost.exe           736     296</span><br><span class="line">  sshd.exe              892     624</span><br><span class="line">  sppsvc.exe            1064    428</span><br><span class="line">  SearchIndexer.        1244    428</span><br><span class="line">  svchost.exe           1824    428</span><br><span class="line">  SearchProtocol        2104    1244</span><br><span class="line">  SearchFilterHo        2164    1244</span><br><span class="line">  cmd.exe               2368    1100</span><br><span class="line">  conhost.exe           2376    344</span><br><span class="line">  svchost.exe           2560    428</span><br><span class="line">  svchost.exe           2660    428</span><br><span class="line">  calc.exe              2792    2368</span><br><span class="line">  taskhost.exe          2988    428</span><br><span class="line">  CompatTelRunne        3080    428</span><br><span class="line">  conhost.exe           3088    296</span><br><span class="line">  sample.exe            3180    2368</span><br><span class="line">  WmiPrvSE.exe          3236    560</span><br><span class="line">  DeviceDisplayO        3292    560</span><br><span class="line">  System                4       0</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line"></span><br><span class="line">Dynamic libraries list (18 libs):</span><br><span class="line">        0x49e30000      20480   csrss.exe                C:\Windows\system32\csrss.exe</span><br><span class="line">        0x76e60000      1314816 ntdll.dll                C:\Windows\SYSTEM32\ntdll.dll</span><br><span class="line">        0x74fc0000      53248   CSRSRV.dll               C:\Windows\system32\CSRSRV.dll</span><br><span class="line">        0x74fb0000      57344   basesrv.DLL              C:\Windows\system32\basesrv.DLL</span><br><span class="line">0x74f80000      180224  winsrv.DLL               C:\Windows\system32\winsrv.DLL</span><br><span class="line">        0x752b0000      823296  USER32.dll               C:\Windows\system32\USER32.dll</span><br><span class="line">        0x75490000      319488  GDI32.dll                C:\Windows\system32\GDI32.dll</span><br><span class="line">        0x75960000      868352  kernel32.dll             C:\Windows\SYSTEM32\kernel32.dll</span><br><span class="line">        0x75190000      307200  KERNELBASE.dll           C:\Windows\system32\KERNELBASE.dll</span><br><span class="line">        0x75480000      40960   LPK.dll                  C:\Windows\system32\LPK.dll</span><br><span class="line">        0x76ff0000      643072  USP10.dll                C:\Windows\system32\USP10.dll</span><br><span class="line">        0x75830000      704512  msvcrt.dll               C:\Windows\system32\msvcrt.dll</span><br><span class="line">        0x74f70000      36864   sxssrv.DLL               C:\Windows\system32\sxssrv.DLL</span><br><span class="line">        0x74ec0000      389120  sxs.dll                  C:\Windows\system32\sxs.dll</span><br><span class="line">        0x75780000      663552  RPCRT4.dll               C:\Windows\system32\RPCRT4.dll</span><br><span class="line">        0x74eb0000      49152   CRYPTBASE.dll            C:\Windows\system32\CRYPTBASE.dll</span><br><span class="line">        0x75ad0000      659456  ADVAPI32.dll             C:\Windows\system32\ADVAPI32.dll</span><br><span class="line">        0x77090000      102400  sechost.dll              C:\Windows\SYSTEM32\sechost.dll</span><br><span class="line"></span><br><span class="line">Kernel module list (135 modules):</span><br><span class="line">        0x82816000      4235264 ntoskrnl.exe             \SystemRoot\system32\ntoskrnl.exe</span><br><span class="line">        0x82c20000      225280  hal.dll                  \SystemRoot\system32\halmacpi.dll</span><br><span class="line">        0x80bd3000      32768   kdcom.dll                \SystemRoot\system32\kdcom.dll</span><br><span class="line">        0x8b40d000      544768  mcupdate.dll             \SystemRoot\system32\mcupdate_GenuineIntel.dll</span><br><span class="line">        0x8b492000      69632   PSHED.dll                \SystemRoot\system32\PSHED.dll</span><br><span class="line">        0x8b4a3000      32768   BOOTVID.dll              \SystemRoot\system32\BOOTVID.dll</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到，客户环境的<code>calc.exe</code>以及从本地传过去的<code>sample.exe</code>都得到了运行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本次实验，了解了Panda的记录、回放过程，完成了记录、回放对应的自动化脚本的编写，并简单使用了Panda插件。在未向客户系统预存代码的情况下，将目标程序在系统中运行，使我们能够对我们选择的给定应用程序的系统进行舒适的分析。</p>]]></content>
    
    
    <summary type="html">Panda（Platform for Architecture-Neutral Dynamic Analysis）是一个用于架构中性动态分析的开源平台。优势在于软件的快速逆向工程。</summary>
    
    
    
    <category term="Dynamic Analysis" scheme="http://example.com/categories/Dynamic-Analysis/"/>
    
    
    <category term="Panda-re" scheme="http://example.com/tags/Panda-re/"/>
    
    <category term="Dynamic Analysis" scheme="http://example.com/tags/Dynamic-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Panda安装及基础操作</title>
    <link href="http://example.com/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-26T02:00:00.000Z</published>
    <updated>2022-09-21T13:08:27.775Z</updated>
    
    <content type="html"><![CDATA[<p>动态分析是计算机安全中的一项基本技术，在处理真实程序时，动态分析通常必须在整个系统上运行，而不是仅仅在一个二进制文件上运行，在受控环境中执行样本，然后监视该环境以了解软件的行为。</p><p>Panda（Platform for Architecture-Neutral Dynamic Analysis）是目前基于QEMU 2.9.1的全系统动态分析引擎，是一个用于架构中性动态分析的开源平台。优势在于软件的快速逆向工程。</p><p>包括一个用于记录和回放执行的系统、一个用于在执行代码上运行 LLVM 分析的框架，以及一个易于扩展的插件架构。</p><span id="more"></span><p><strong>优势：可以收集一段感兴趣的执行记录，然后一遍又一遍地分析该记录。</strong>记录/重放能够一遍又一遍地重复执行跟踪，所有数据完全相同。然后，可以分析执行情况并慢慢了解事物的存储位置、正在运行的进程、关键执行事件何时发生等。</p><p><img src="/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/Untitled.png"></p><p>PANDA 还具有将 QEMU 的中间表示 TCG 转换为 LLVM 代码的功能，这使得通过 LLVM 通道编写全系统动态分析工具成为可能。这是一个强大的功能，它将两个程序分析框架 QEMU 和 LLVM 连接在一起，以利用两者之间的协同作用。</p><ul><li>项目地址</li></ul><p><a href="https://github.com/panda-re/panda">https://github.com/panda-re/panda</a></p><ul><li>用户使用文档：</li></ul><p><a href="https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#recordreplay-details">panda/manual.md at dev · panda-re/panda</a></p><h1 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h1><p>Panda插件通过两种主要方式（插件接口）与 QEMU 交互：</p><ul><li>通过检测回调</li><li>通过公开客户系统状态的检查 API，例如内存状态</li></ul><p><img src="/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/Untitled%201.png"></p><p>常见的一些回调在：<a href="https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#callback-and-plugin-management">https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#callback-and-plugin-management</a></p><p>使用回调来hook程序的执行并执行分析代码</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><hr><p>环境：Ubuntu20.04</p><h3 id="编译安装-采用"><a href="#编译安装-采用" class="headerlink" title="编译安装(采用)"></a>编译安装(采用)</h3><p><code>./install_ubuntu.sh</code></p><p><a href="https://github.com/panda-re/panda/blob/dev/panda/scripts/install_ubuntu.sh">panda/install_ubuntu.sh at dev · panda-re/panda</a></p><p><img src="/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/Untitled%202.png"></p><p>编译完成后，QEMU二进制文件位于build文件夹下；</p><p>还需要创建一个用于PANDA的Qcow（磁盘映像）</p><h3 id="PIP安装Python接口：PyPanda"><a href="#PIP安装Python接口：PyPanda" class="headerlink" title="PIP安装Python接口：PyPanda"></a>PIP安装Python接口：PyPanda</h3><p>安装一些依赖：</p><p><code>apt install libvdeplug-dev libpng16-16 libsdl2-2.0-0</code></p><p><code>pip3 install pandare</code></p><p>这将安装基于 python 的 PANDA 分析所需的一切，但不会安装独立的 PANDA 二进制文件。 这个包不会自动更新，所以它可能落后于 PANDA 的 master 分支。</p><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p><code>panda</code>容器：安装了 Panda 和 PyPANDA 以及它们的运行时依赖项的容器，但没有构建工件或源代码以减小容器的大小。</p><p><code>pandadev</code>容器：安装了 Panda和 PyPANDA 以及它们的运行时依赖项的容器，所有构建工件和源代码以及目录中此存储库的内容。（适合开发者）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull pandare/pandadev</span><br><span class="line">$ docker run --rm pandare/pandadev /panda/build/panda-system-i386 --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h1 id="记录Record和重放Replay"><a href="#记录Record和重放Replay" class="headerlink" title="记录Record和重放Replay"></a>记录Record和重放Replay</h1><hr><p>确定性记录和重放是一种用于捕获系统的 非确定性输入的技术（如果系统使用相同的输入从同一点重新启动，会导致系统行为不同的事物。）</p><ul><li>Panda记录的非确定性输入是对 CPU 状态和内存所做的更改——DMA、中断、in指令等等</li><li>Panda不记录设备的输入</li><li>想象在CPU与RAM外画个圈，记录从外部世界跨过这条线的东西</li></ul><h3 id="记录Record"><a href="#记录Record" class="headerlink" title="记录Record"></a>记录Record</h3><p>可以使用 QEMU 监视器中的 <code>begin_record</code> 和 <code>end_record</code> 命令来记录执行情况。</p><ul><li>begin_record <name><ul><li>开始录制会话，另存为<name>，会覆盖之前的记录</name></li><li>会生成两个文件：<ul><li>VM 快照<code>&lt;name&gt;-rr-snp</code></li><li>所有非确定性输入的日志<code>&lt;name&gt;-rr-nondet.log</code></li></ul></li></ul></name></li><li>end_record<ul><li>结束活动的录制会话，guest将被暂停，但可以恢复，并且一旦恢复guest，就可以进行另一次录制。</li></ul></li></ul><p>监视器，使用 <code>-monitor stdio</code> 运行 QEMU（也有更复杂的设置）。 输入 <code>begin_record &quot;replay_name&quot;</code> 开始录制过程，并使用 <code>end_record</code> 结束它。</p><h3 id="重放Replay"><a href="#重放Replay" class="headerlink" title="重放Replay"></a>重放Replay</h3><p>重放记录（replay recording）：可以使用 （这两个文件）<code>panda-system-$arch -replay replay_name</code>。确保将相同的内存大小传递给 VM，就像记录所做的那样。否则 QEMU 将失败并出现无法理解的错误。</p><p>仅仅运行重放本身并不是很有用，可以启用一些插件，对重放的执行进行分析。</p><h3 id="分享记录"><a href="#分享记录" class="headerlink" title="分享记录"></a>分享记录</h3><p>Pande支持打包和解压记录</p><ul><li>打包记录（这将捆绑<code>&lt;name&gt;-rr-snp</code>与<code>&lt;name&gt;-rr-nondet.log</code>放入 <code>&lt;name&gt;.rr</code>）：  <code>scripts/rrpack.py &lt;name&gt;</code></li><li>解压记录  <code>scripts/rrunpack.py &lt;name&gt;.rr</code></li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>捕获重放（Replay）后，可以多次播放它。通常首先使用标准分析来尝试了解正在发生的事情的基本情况，然后使用自定义插件（<code>panda_plugins</code>目录）来进行更具体的分析。</p><p>常用于开始分析的插件：<code>asidstory</code>、 <code>stringsearch</code>和 <code>file_taint</code></p>]]></content>
    
    
    <summary type="html">Panda（Platform for Architecture-Neutral Dynamic Analysis）是一个用于架构中性动态分析的开源平台。优势在于软件的快速逆向工程。</summary>
    
    
    
    <category term="Dynamic Analysis" scheme="http://example.com/categories/Dynamic-Analysis/"/>
    
    
    <category term="Panda-re" scheme="http://example.com/tags/Panda-re/"/>
    
    <category term="Dynamic Analysis" scheme="http://example.com/tags/Dynamic-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读 -- &quot;Precise and Accurate Patch Presence Test for Binaries&quot;</title>
    <link href="http://example.com/2022/03/09/Precise%20and%20Accurate%20Patch%20Presence%20Test%20for%20Binar/"/>
    <id>http://example.com/2022/03/09/Precise%20and%20Accurate%20Patch%20Presence%20Test%20for%20Binar/</id>
    <published>2022-03-09T02:00:00.000Z</published>
    <updated>2022-09-21T12:12:37.105Z</updated>
    
    <content type="html"><![CDATA[<p>Author: Hang Zhang and Zhiyun Qian, University of California, Riverside<br>Code: <a href="https://github.com/fiberx/fiber">https://github.com/fiberx/fiber</a><br>Topic: Angr<br>URL: <a href="https://www.usenix.org/conference/usenixsecurity18/presentation/zhang-hang">https://www.usenix.org/conference/usenixsecurity18/presentation/zhang-hang</a><br>Where: 27th USENIX Security Symposium<br>Year: 2018<br>Introducetion: 实现了FIBER工具：针对安卓系统，通过生成签名的方式，判断是否打上了已发布的补丁</p><span id="more"></span><p>本文只是学习并记录笔记，如有错误或不足请谅解指正，谢谢！</p><h1 id="一、摘要与背景"><a href="#一、摘要与背景" class="headerlink" title="一、摘要与背景"></a>一、摘要与背景</h1><hr><h3 id="主要背景："><a href="#主要背景：" class="headerlink" title="主要背景："></a>主要背景：</h3><p>软件世界种总是存在着各种漏洞，对抗漏洞的主要方法是打补丁（patch）来修复，对软件进行更新。随着程序开发的发展，代码复用成为了一种常见的开发方式，开源项目能够被很多的开发者重复使用在不同软件程序上。然而，当开源项目出现了（或被发现存在）漏洞，会同时影响到所有复用这个项目的使用者，而当开源项目的维护者打入了补丁、修复了漏洞后，这些复用该项目的程序是否及时地更新了相应的补丁？这会严重影响这些软件的安全性。</p><p>因此，能否及时、有效地检测目标程序是否更新了相应的补丁，对于开源软件世界是一个严峻的挑战。</p><p><strong>补丁—&gt;对抗漏洞 —&gt;如何确保软件存在安全补丁？</strong></p><ul><li><p>什么是补丁存在度测试：在假设已知受影响的函数和补丁本身的情况下，检查一个特定的补丁是否被应用到一个未知的目标上。</p></li><li><p>以往的两方面工作：</p><p>  Source to source：源代码级别：目标是源代码信息，通常需要提供补丁的相应信息</p><p>  Binary to Binary：二进制特征：单纯地比较二进制文件</p></li></ul><h1 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h1><hr><ul><li>背景：<ul><li>代码开源的情况越来越常见了（Github）</li><li>许多开源代码或组件在封闭源代码软件中被广泛重用（OpenSSL、Linux-Base Kernel等），因此Source to Source这种源代码级别的检测方法未可用</li><li>对于Binary-only层面，由于搜索范围非常大，不得不使用基于相似度的模糊匹配（similarity-based fuzzy matching）来加快搜索过程，但精度不够准确；且安全补丁大多是微小的变化，基于相似性的方法无法有效判断是否打过补丁。</li></ul></li><li>解决：  为了解决这个问题，作者提出了Fiber这一工具：首先仔细分析开源安全补丁，生成细粒度的二进制签名（fine-grained binary signatures）反映补丁引入的最具代表性的语法和语义变化，用于搜索目标二进制文件。</li></ul><p>技术问题：如何生成能很好地表示源代码级补丁的二进制签名？（generate binary signatures that well represent the source-level patch）</p><p>步骤：</p><ul><li>挑选并选择补丁中最合适的部分作为生成二进制签名的候选者</li><li>生成尽可能保留源代码级信息的二进制签名，包括补丁和相应的函数作为一个整体</li></ul><p>贡献：</p><ul><li>在“源到二进制（Source to Binary）”下制定了补丁存在测试问题，弥合了从一般错误搜索到精确和准确的补丁存在测试的差距</li><li>在patch中选取最合适的部分，生成代表源代码级patch的二进制签名</li><li>系统地评估了基于不同时间戳、版本和厂商的Android内核镜像2上的107个真实世界的漏洞和安全补丁，表明FIBER在安全补丁存在度测试中具有较高的准确性</li></ul><h1 id="三、相关工作"><a href="#三、相关工作" class="headerlink" title="三、相关工作"></a>三、相关工作</h1><hr><p>漏洞搜索如何应用与补丁存在测试问题上</p><ul><li>Source-level bug search<ul><li>一般的目标：寻找与给定的bug代码相似的代码片段</li><li>漏洞搜索方案<strong>通常使用从源代码中提取的特征</strong>（包括纯字符串、标记 和解析树 ）构建为某种形式的相似性匹配，<strong>但这种方法</strong>使得确定<strong>识别出的类似代码片段是否被修补变得困难</strong>（因为打过补丁和未打过补丁的版本可能类似(特别是对于通常很小的安全补丁)）</li></ul></li><li>Binary-level bug search<ul><li>与源码级漏洞搜索类似，为了克服缺乏源级信息(如变量类型和名称)的挑战，需要<strong>寻找替代特征</strong>，如<strong>二进制程序的结构</strong></li><li>不假设符号表的可用性，因此被迫检查每个函数，即使它只打算对特定函数进行准确的补丁存在性测试</li><li>现有的解决方案的设计是主要为了速度而不是精度</li></ul></li></ul><p><strong>FIBER</strong>处于一个独特的位置<strong>，</strong>利用源代码级别的信息来回答一个更具体的问题——是否在目标二进制文件中修补了特定的受影响的函数。</p><h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><hr><p>系统架构</p><p><img src="/2022/03/09/Precise%20and%20Accurate%20Patch%20Presence%20Test%20for%20Binar/Untitled.png"></p><p>主要输入：</p><ul><li>Source Patches 源代码级补丁信息</li><li>Ref .function(src) 完整的源代码参考</li><li>Ref .function(bin) 编译后的引用二进制中受影响的函数</li><li>Tgt. function(bin) 目标二进制中受影响的函数</li></ul><p>三个组件：</p><ul><li>Change site analyzer：分析补丁中每个代码变更点和相应的参考函数来挑选那些最具代表性、独特且易于匹配的源变更，模仿真正的分析师会做的事情</li><li>Signature generator：签名生成器，负责将源级更改点转换为二进制级签名（利用二进制符号执行）</li><li>Matching engine：任务是在目标二进制文件中搜索给定的签名。首先需要在符号表的帮助下在目标二进制文件中找到受影响的函数。然后通过匹配与补丁相关的本地化CFG的拓扑结构所表示的语法来完成搜索，然后是语义公式(由于符号执行而变慢)。</li></ul><p>范围：</p><p>1、FIBER支持分析不同架构的二进制文件，并使用不同的编译器选项进行编译。</p><p>2、FIBER本质上不绑定任何源语言，尽管目前它可以在C代码上工作。需要编译器生成调试信息。</p><h2 id="1、Signature"><a href="#1、Signature" class="headerlink" title="1、Signature"></a>1、Signature</h2><p>通常，“理想”的签名两个标准：</p><p>1、Unique：独一无二，该签名不能在补丁以外的地方找到（这要求签名不能过于简单）</p><p>2、Stable：稳定，签名应该对代码库的演化具有适应性（这也要求签名不能过于复杂）</p><p>签名是一组二进制指令，它们不仅在结构上与源码级签名相对应，而且还用足够的信息进行注释，以便它们可以明确地映射到原来的源码级更改点。</p><h2 id="2、Change-Site-Analyzer"><a href="#2、Change-Site-Analyzer" class="headerlink" title="2、Change Site Analyzer"></a>2、Change Site Analyzer</h2><p>输入：<code>Source Patches</code> 源码补丁及<code>Ref .function(src)</code> 参考代码库</p><p>目的：</p><ul><li>由于一个补丁可能会在不同的功能内引入多个变化点，分析器的目标是根据“Signature”中提到的标准选择一个合适的签名</li><li>了解补丁变更的地点</li></ul><h3 id="2-1-发现独特的源代码变更（Unique-Source-Change-Discovery）"><a href="#2-1-发现独特的源代码变更（Unique-Source-Change-Discovery）" class="headerlink" title="2-1 发现独特的源代码变更（Unique Source Change Discovery）"></a>2-1 发现独特的源代码变更（Unique Source Change Discovery）</h3><p>打补丁的方式有多种，删除、添加、修改，作者主要关注后两种情况。</p><p>对于补丁中添加的每行代码，执行以下步骤：</p><p>1、独特性测试（Uniqueness test），不仅捕获基于令牌（token-based）的信息，而且捕获与语义相关的信息</p><p>2、上下文相关（可选）（Context addition），可以有多个上下文语句</p><p>3、细粒度的变化检测（Fine-grained change detection）：一般，补丁以源码行变化的形式存在，通过与相邻的已删除或已添加的行比较，可以在单个语句/行中检测这细粒度的变化。确保我们不包括会扩大签名的不必要部分。</p><p>4、类型的洞察力（Type insight）：源码语句中涉及的变量类型也很重要，因为它将指导后面的二进制签名生成和匹配</p><h3 id="2-2选择源代码变更点（Source-Change-Selection）"><a href="#2-2选择源代码变更点（Source-Change-Selection）" class="headerlink" title="2-2选择源代码变更点（Source Change Selection）"></a>2-2选择源代码变更点（Source Change Selection）</h3><p>上一步可能会为单个补丁生成多个候选的独特代码变更。一个补丁会有多处代码变化，且在实践中，这些变化中的一个的存在可能已经表明补丁的存在。</p><p>因此，一些源代码更改比其他的更适合生成二进制签名。</p><p>FIBER对上一步产生的代码候选变更点进行排序，并对前N个进行进一步处理（基于三个因素）</p><p>1、到功能入口的距离：越近越好</p><p>2、函数大小：越小越好</p><p>3、代码变化类型（最重要）</p><p>将补丁中的代码变化分为几种通用类型：</p><ul><li>函数调用：新的函数调用或参数的改变，优先级最高（可以根据是否有对该函数的调用判断是否打了补丁）</li><li>条件相关（if等）：同时引入了结构变化和语义变化</li><li>赋值</li></ul><p>等</p><h2 id="3、Signature-Generator"><a href="#3、Signature-Generator" class="headerlink" title="3、Signature Generator"></a>3、Signature Generator</h2><p>将参考源代码编译成参考二进制文件，根据所选的独特源代码的变化，将从中生成二进制签名</p><p>（保留编译器生成的所有调试信息，以备将来使用）</p><h3 id="3-1二进制签名生成（Binary-Signature-Generation）"><a href="#3-1二进制签名生成（Binary-Signature-Generation）" class="headerlink" title="3-1二进制签名生成（Binary Signature Generation）"></a>3-1二进制签名生成（Binary Signature Generation）</h3><p>识别并组织与源码变更相关的指令</p><p>给定参考二进制文件，首先要定位与源代码更改相关的相应二进制指令。（通过调试信息）</p><p>本地CFG的拓扑结构反映了原始源码变化的结构</p><p>理论上，上述本地CFG中识别的所有指令都将成为二进制签名的一部分。然而，这在实践中并不好，因为只有一个指令子集实际上总结了关键行为(数据流语义);我们把这样的指令称为“<strong>根指令</strong>”。</p><p>（注意：编译器仍然可能为相同的语句生成稍微不同的根指令(由于编译器优化等)。）</p><p><img src="/2022/03/09/Precise%20and%20Accurate%20Patch%20Presence%20Test%20for%20Binar/Untitled%201.png"></p><p>只要根指令的类型相同，我们就认为它们是等价的(根指令的规范化)。</p><p>需要确保根指令有足够的标签(这是我们的二进制签名)，以便它们可以唯一地映射到源代码更改。</p><p>从函数的角度，指令中任何操作数只能从四个来源派生：</p><p>（1）函数参数（外部输入）</p><p>（2）局部变量（在函数中定义）</p><p>（3）函数调用返回值</p><p>（4）立即数（常量）</p><p>并对这四种类型进行不同的处理</p><p>根据作者经验，发现即使对签名中的这些基本元素没有精确的了解，描述它们的语义公式通常已经足够独特，可以注释操作数;最终允许我们唯一地将根指令映射到源级语句。</p><p>二进制签名匹配：</p><p><img src="/2022/03/09/Precise%20and%20Accurate%20Patch%20Presence%20Test%20for%20Binar/Untitled%202.png"></p><p>目标源有相同的补丁语句(应该被认为是补丁)，即使它也插入了一些带有新的本地变量的额外代码。</p><p>尝试匹配二进制签名时，有三点值得注意：</p><p>1、不能在引用和目标之间盲目地使用固定偏移量来表示同一个局部变量。策略：(1)推断目标二进制文件中局部变量的类型，并得出结论:sp+0x10是唯一的整数变量，因此必须对应于sp+0x8。(2)分析目标二进制文件中所有局部变量的行为，并尝试匹配引用中最类似sp+0x8的那个。</p><p>2、孤立的基本块级分析是不够的</p><p>3、在目标二进制文件的最后一个基本块中有一个额外的存储指令，它将X0 (do sth()的返回值保存到sp+0x8(即s)。注意，从数据流的角度来看，这可能看起来像根指令。但是，由于它试图在原始签名中存储返回值而不是公式，因此不会导致错误匹配。</p><h3 id="3-2二进制签名验证（Binary-Signature-Validation）"><a href="#3-2二进制签名验证（Binary-Signature-Validation）" class="headerlink" title="3-2二进制签名验证（Binary Signature Validation）"></a>3-2二进制签名验证（Binary Signature Validation）</h3><p>原因：转化过程中的信息丢失</p><p>（1）独特性：对于每个补丁，准备补丁及未打补丁的二进制文件作为对象，再匹配它们的二进制签名，若打了补丁的签名在未打补丁的签名中无法匹配，则说明其独特性。还可能存在一个独特的二进制签名可能有多个匹配的情况。</p><p>（2）稳定：源码变化的大小和二进制签名是相关的。还可以准备多个补丁和未补丁的函数二进制版本，并针对它们测试生成的二进制签名。这有助于挑选出那些最稳定的二进制签名，这些签名存在于所有打过补丁的二进制文件中，而不存在于未打过补丁的二进制文件中。</p><h2 id="4、签名匹配引擎（Signature-Matching-Engine）"><a href="#4、签名匹配引擎（Signature-Matching-Engine）" class="headerlink" title="4、签名匹配引擎（Signature Matching Engine）"></a>4、签名匹配引擎（Signature Matching Engine）</h2><p>负责在目标二进制(即测试对象)中搜索给定的二进制签名。</p><p>首先需要通过目标二进制中的符号表来定位目标函数，然后开始搜索其中的二进制签名。</p><h3 id="粗略匹配"><a href="#粗略匹配" class="headerlink" title="粗略匹配"></a>粗略匹配</h3><p>通过一些易于收集的特性来匹配二进制签名，包括：</p><p>（1）CFG拓扑。二进制签名本身基本上就是CFG函数的一个子图。</p><p>（2）基本块的退出类型（exit）。一般来说，每个基本块都有两种退出类型:无条件跳转（call、return等）和条件跳转。因此可以通过退出类型快速比较基本块。</p><p>（3）根指令类型。分析签名中的每个基本块，并确定其根指令集。指令类型可以用来快速比较两个基本块。需要为目标函数二进制中的每个基本块生成数据流图。</p><p>通过以上特性，我们可以快速缩小目标函数中的搜索空间。如果在这一步中没有找到匹配，我们已经可以断定签名不存在，否则，我们仍然需要进一步精确地比较每个候选匹配。</p><h3 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h3><p>利用语义公式对两组根指令执行精确匹配。</p><p>首先需要为所有匹配的候选根指令生成语义公式，若语义公式匹配（它们映射到相同的源码级签名/语句），则视为等价</p><p>如何比较两个语义公式？（之前有计算相似分数）</p><p>但FIBER—明确的答案：定理证明器被用于证明两个公式[14]的语义等价性，这无疑提供了最好的准确性，但不幸的是，在实践中可能非常昂贵。选择了一个中间立场。根据观察，语义公式捕获了依赖关系，因此指令的顺序不能交换，我们知道公式的结构不太可能改变。</p><p>基本上，匹配过程只是递归地匹配AST中的运算和操作数，并进行一些必要的松弛（例如，如果运算符是可交换的，则操作数的顺序无关紧要）。</p><p>例如：(a+b)<strong>2不会变成a</strong>2+b*2</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>使用Angr符号执行引擎生成语义公式。（改变了Angr的内部结构）</p><p>架构依赖：</p><p>原则上FIBER支持任何体系结构，因为我们可以将源代码编译成任何体系结构的二进制文件。</p><p>Angr将二进制文件提升到一种中间语言VEX(它抽象出指令集架构的差异)</p><p>根指令注释（Root instruction annotation）：</p><p>为了生成根指令操作数的语义公式，需要分析从函数入口到根指令的所有二进制代码。我们选择<strong>符号执行</strong>作为我们的分析方法，因为它可以覆盖所有可能的执行路径，并获得沿着路径上任意一点的任何寄存器和内存位置的值表达式。</p><p>作者采用的符号执行路径爆炸优化方法：</p><p>（1）路径修剪（Path pruning）。在开始符号执行之前，我们将首先在函数CFG中执行深度优先搜索(DFS)，找到从函数入口到根指令的所有路径。然后，我们将只把这些路径中包含的基本块放在执行白名单中，所有其他的基本块将被符号执行引擎删除。此外，我们还将循环展开次数限制为2次，以进一步减少路径的数量。</p><p>（2）非约束符号执行（under-constrained symbolic execution）：不受约束的符号执行可以处理单个函数，而不用担心其调用上下文，从而有效地将路径空间限制在单个函数中。虽然函数的输入(如参数)在一开始是不受约束的，但它不会影响语义公式的提取，因为它们不需要这样的初始约束。</p><p>无约束的输入也可能导致执行引擎在现实世界的执行中包含不可行的路径，然而，我们的语义公式的目标是使它们在引用和目标二进制之间具有可比性，只要我们对双方使用相同的过程，提取的公式仍然可以用于补丁存在测试（patch presence test）的比较。最后，我们使用函数内的符号执行，也就是说，不跟随被调用者(它们的返回值也将不受约。束)，这在实践中已经可以生成公式，使根指令唯一且稳定。</p><p>（3）验证模式下的符号执行（Symbolic execution in veritesting mode）：</p><p>验证（veritesting ）是一种将静态符号执行集成到动态符号执行的技术，可以提高执行效率。</p><p>动态符号执行—基于路径—开销大</p><p>静态符号执行—基于基本块—公式更复杂（需要携带所有可以到达当前节点的路径的不同约束）</p><p>但FIBER不需要求解这些公式，只需比较这些从参考和目标二进制文件中提取的公式，</p><p>当我们认为一个二进制签名在目标中匹配时，我们要求目标中的计算公式包含签名中的所有公式(可以是一个超集)。</p><h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><p>评估数据集：Android内核。原因：安卓受欢迎；很多开发分支由不同供应商（华为三星等）维护。其他Android供应商可能不会及时将安全补丁移植到他们自己的内核。</p><p>（1）参考内核源代码和安全补丁</p><p>（2）目标Android内核映像和源代码</p><p>注：供应商发布的二进制映像(有时每月一次)比源代码包要多得多。我们只对能找到相应源代码的二进制映像进行评估，而源代码只能作为patch presence test的ground truth。</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="准备参考二进制-Reference-binary-preparation"><a href="#准备参考二进制-Reference-binary-preparation" class="headerlink" title="准备参考二进制 Reference binary preparation."></a>准备参考二进制 Reference binary preparation.</h3><p>首先需要将参考源代码编译成二进制文件，并在此基础上生成二进制签名。(自由地选择编译器、它们的选项和目标体系结构，当然应该最接近目标二进制的编译配置)</p><p>首先编译多个参考二进制文件与所有的组合常见的编译器(使用gcc和clang)和优化水平(我们使用水平O1 - O3和Os)，然后使用BinDiff来测试每个参考二进制和目标二进制的相似性，最相似的参考二进制文件最终将用于二进制签名的生成。</p><h3 id="离线签名生成和验证-Offline-signature-generation-and-validation"><a href="#离线签名生成和验证-Offline-signature-generation-and-validation" class="headerlink" title="离线签名生成和验证 Offline signature generation and validation."></a>离线签名生成和验证 Offline signature generation and validation.</h3><p>对于每个安全补丁，我们最多保留三个二进制签名，通过将它们与已修补和未修补的参考内核图像进行匹配来测试它们的唯一性。</p><h3 id="在线匹配-Online-matching"><a href="#在线匹配-Online-matching" class="headerlink" title="在线匹配 Online matching"></a>在线匹配 Online matching</h3><p>给定一个特定的安全补丁，我们将尝试在目标内核中匹配它的所有二进制签名。（所有Android内核映像都是用符号表编译的。因此，我们可以很容易地找到受影响的函数。）</p><p>只要一个签名能够与引用补丁内核中的匹配，那么我们就会说该补丁存在于目标内核中。</p><h2 id="准确性"><a href="#准确性" class="headerlink" title="准确性"></a>准确性</h2><p><img src="/2022/03/09/Precise%20and%20Accurate%20Patch%20Presence%20Test%20for%20Binar/Untitled%203.png"></p><p>准确性非常好，没有假阳性（FP），非常少的假阴性（FN）。</p><p>FP可能会导致开发人员错误地认为已经应用了补丁，而实际上并没有(这是一个严重的安全风险)。</p><p>相比之下，FN只会花费一些额外的时间，分析师意识到代码实际上是打了补丁</p><p>出现FN的原因：</p><p>（1）内联函数：目标内核有不同的内联行为，我们的签名将无法匹配</p><p>（2）函数原型变化：有时函数原型会在不同的内核映像之间发生变化（函数参数的数量和顺序可能会有所不同。）</p><p>（3）定制代码：由于代码定制，上下文可能会在不同的内核映像之间有所不同</p><p>（4）补丁的适应：补丁可能需要针对不同供应商维护的内核进行调整，因为不同内核分支之间的脆弱功能并不总是完全相同。</p><p>（5）其他工程问题：例如，某些二进制指令无法被angr识别和解码，这将影响后续CFG的生成和符号执行。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p><img src="/2022/03/09/Precise%20and%20Accurate%20Patch%20Presence%20Test%20for%20Binar/Untitled%204.png"></p><p>一小部分补丁需要比平均匹配更长的时间，补丁的改变网站定位在非常大的和复杂的功能(例如,cve - 2017 - 0521),因此,匹配引擎可能遇到根深处的指令功能。</p><h2 id="未导入的漏洞"><a href="#未导入的漏洞" class="headerlink" title="未导入的漏洞"></a>未导入的漏洞</h2><p>FIBER会产生一些TN情况，表面存在未修补的漏洞，如果相关的安全补丁在测试对象的发布日期之前已经可用，那么这意味着测试对象未能及时应用补丁。</p><p><img src="/2022/03/09/Precise%20and%20Accurate%20Patch%20Presence%20Test%20for%20Binar/Untitled%205.png"></p><p>可以看到，即使是一些关键漏洞也没有及时修补，这表明它们很有可能被用来完全破坏内核以执行任意代码。</p><p>注意：FIBER旨在测试目标内核中是否存在补丁，但是，缺少安全补丁并不一定意味着目标内核可以被利用。因此，仍需进一步验证。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>在本文中，我们提出了“源码到二进制”场景下的补丁存在性测试问题。然后，我们设计并实现了FIBER，这是一个全自动的解决方案，可以充分利用源代码级别的信息，在二进制文件中进行精确的补丁存在测试。FIBER已经通过真实世界的安全补丁和一组不同的Android内核图像进行了系统评估，结果表明，它可以实现良好的准确性和可接受的性能，因此对于安全分析人员来说非常实用。</p>]]></content>
    
    
    <summary type="html">实现了FIBER工具：针对安卓系统，通过Angr符号执行、生成签名，判断是否打上了已发布的补丁</summary>
    
    
    
    <category term="Symbol Execution" scheme="http://example.com/categories/Symbol-Execution/"/>
    
    
    <category term="Paper Reading" scheme="http://example.com/tags/Paper-Reading/"/>
    
    <category term="Symbol Execution" scheme="http://example.com/tags/Symbol-Execution/"/>
    
    <category term="Angr" scheme="http://example.com/tags/Angr/"/>
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读--&quot;Symbolic Execution for Software Testing&quot;</title>
    <link href="http://example.com/2022/02/10/Symbolic%20Execution%20for%20Software%20Testing%20Three%20Deca/"/>
    <id>http://example.com/2022/02/10/Symbolic%20Execution%20for%20Software%20Testing%20Three%20Deca/</id>
    <published>2022-02-10T13:00:00.000Z</published>
    <updated>2022-09-21T06:30:04.587Z</updated>
    
    <content type="html"><![CDATA[<p>该论文以较为通俗的语言和简单的例子阐述了符号执行的基本原理，并介绍了符号执行技术的发展历程和面临挑战。通过本文，可以基本的了解符号执行<br>论文地址：<a href="https://dl.acm.org/doi/fullHtml/10.1145/2408776.2408795">https://dl.acm.org/doi/fullHtml/10.1145/2408776.2408795</a></p><span id="more"></span><p>软件测试环境中，符号执行的一个关键目标是在一定的时间内探索尽可能多的不同程序路径，并为每一条路径：</p><p>（1）生成一组具体的输入值来执行该路径</p><p>（2）检查是否存在各种错误，包括断言违规、未捕获的异常、安全漏洞、内存损坏等</p><h2 id="符号执行关键思想"><a href="#符号执行关键思想" class="headerlink" title="符号执行关键思想"></a>符号执行关键思想</h2><hr><h3 id="关键思想"><a href="#关键思想" class="headerlink" title="关键思想"></a>关键思想</h3><p>符号执行关键思想：使用符号值，而不是具体的数据值作为输入，并将程序变量的值表示为符号表达式，而不是符号输入值。那么，程序的输出值为符号输入值的一种函数 function(symbolic_input_values)。</p><h3 id="程序表达方式"><a href="#程序表达方式" class="headerlink" title="程序表达方式"></a>程序表达方式</h3><p>具体而言，符号执行为程序每个执行路径生产测试用例。而程序的执行路径可以分为true和false的序列，在序列的第i个位置为true则表示第i个条件判断语句执行then分支，若为false则执行else分支。</p><p>每个程序的执行路径都可以用执行树来表达，后面会通过例子理解。</p><p>符号执行的目标就是生成一组输入，在一定的时间内遍历尽可能多的路径。</p><h2 id="符号执行思路与过程"><a href="#符号执行思路与过程" class="headerlink" title="符号执行思路与过程"></a>符号执行思路与过程</h2><hr><p>符号执行拥有两个变量：</p><ul><li><strong>符号状态 σ</strong> ：表示变量到符号表达式的<strong>映射集合</strong></li><li><strong>符号路径约束 PC</strong> ：是符号表达式的无量词的一阶式</li></ul><p>在符号开始之前，符号状态 σ 为空集，PC 初始化为 <code>True</code></p><p>当一条路径执行结束时，使用约束求解器求解PC，可以生成具体的输入值。（对于该输入值，如果程序以其作为输入，程序将执行与符号执行完全相同的路径并以相同的方式终止）</p><p>那么符号状态 σ和符号路径约束 PC是怎么变化的呢？</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testme</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    z = twice(y);</span><br><span class="line">    <span class="keyword">if</span> (z == x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y + <span class="number">10</span>)</span><br><span class="line">            ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = sym_input();</span><br><span class="line">    y = sym_input();</span><br><span class="line">    testme(x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/02/10/Symbolic%20Execution%20for%20Software%20Testing%20Three%20Deca/Untitled.png"></p><p>可以看到<code>void testme(int x, int y)</code>函数存在三条执行路径；上图表示这对应的执行树。</p><p>当符号执行开始执行时：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">符号状态 σ = 空集</span><br><span class="line">符号路径约束 PC = True</span><br></pre></td></tr></table></figure><ul><li>当符号执行遇到一个输入语句时，形式为<code>var = sym_input()</code>，符号执行将为符号状态<strong>σ</strong>添加映射：<img src="http://latex.codecogs.com/svg.latex?var \rightarrow s"></li></ul><p> 其中<img src="http://latex.codecogs.com/svg.latex?s"> 是一个新的未约束的符号值。</p><p>例如，对于上面的例子，在执行第16、17行：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> x = sym_input();</span><br><span class="line"> y = sym_input();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>后，符号状态<img src="http://latex.codecogs.com/svg.latex?\sigma=\{x \rightarrow x_0,y \rightarrow y_0\}">，其中$x_0，y_0$是新的未约束的符号值。</p><ul><li>当符号执行遇到一个赋值语句时，形式为<code>v = e</code>，符号执行将为符号状态<strong>σ</strong>添加映射：<img src="http://latex.codecogs.com/svg.latex?v \rightarrow \sigma(e)">，其中$σ(e)$就是在当前符号化状态计算e得到的符号表达式。</li></ul><p>例如，对于上面的例子，在执行第6行：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * v;</span><br><span class="line">&#125;</span><br><span class="line">    z = twice(y);</span><br></pre></td></tr></table></figure><p>后，符号状态<img src="http://latex.codecogs.com/svg.latex?\sigma=\{x \rightarrow x_0,y \rightarrow y_0\, z \rightarrow 2y_0\}"></p><ul><li>当符号执行遇到一个条件语句<code>if(e)  S1  else  S2</code>，PC会有两种更新：<ol><li>首先更新PC（表示then分支）为：<img src="http://latex.codecogs.com/svg.latex?PC = PC  \Lambda  \sigma(e)"></li><li>之后建立一个路径约束(else语句)PC‘：<img src="http://latex.codecogs.com/svg.latex?PC^{'} = PC \Lambda \lnot\sigma(e)"></li></ol><ul><li>如果PC可以满足对符号值的某些分配，给一些实际值，那么符号执行继续沿着then这条分支执行下去，且符号状态为σ和符号路径约束为PC；</li><li>同样，如果PC’可满足，PC‘则使用符号状态σ和符号路径约束PC’创建另一个符号执行的实例，并沿着“else”分支继续执行；</li><li>与直接执行程序所不同的是，符号执行的两个分支都可以执行，从而产生两条路径；如果没有满足的分支PC，符号执行将终止</li></ul></li></ul><p>例如，对于上面的例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">z = twice(y);</span><br><span class="line"><span class="keyword">if</span> (z == x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y + <span class="number">10</span>)</span><br><span class="line">        ERROR;</span><br></pre></td></tr></table></figure><p>在第7行，会创建两个路径约束实例，路径约束分别为：</p><p><img src="http://latex.codecogs.com/svg.latex?x_0 = 2y_0">      和   <img src="http://latex.codecogs.com/svg.latex?x_0\neq2y_0"></p><p>在第7行，会创建两个路径约束实例，路径约束分别为：</p><p><img src="http://latex.codecogs.com/svg.latex?(x_0 = 2y_0)\Lambda(x_0>y_0+10)">      和    <img src="http://latex.codecogs.com/svg.latex?(x_0 = 2y_0)\Lambda(x_0 \leq y_0+10)"></p><ul><li>当符号执行遇到exit语句或错误（程序崩溃、违反断言等），将终止符号执行的当前实例，利用约束求解器对当前符号路径约束<strong>PC</strong>得到一个可满足的值，该值就构成了测试用例输入。  即：如果程序执行这些可满足的实际值，就会采用与符号执行完全相同的路径，并以相同的方式结束。</li><li>当符号执行遇到循环和递归时，符号执行可能会导致无限多条路径，如下图：</li></ul><p><img src="/2022/02/10/Symbolic%20Execution%20for%20Software%20Testing%20Three%20Deca/Untitled%201.png"></p><p>这段代码就有无数条执行路径，每条路径的可能性有两种：①任意数量的True加上一个False结尾；②无穷多数量的True。</p><p>对于这种情况：</p><p>符号路径约束<img src="http://latex.codecogs.com/svg.latex?PC =(\wedge_ {i\in [1,n]}N_{i} >0) \wedge (N_{n+1}\leq 10)">  其中每个$N_{i}$都是一个新的符号值</p><p>执行结尾符号状态 <img src="http://latex.codecogs.com/svg.latex?\sigma =\{N \rightarrow N_{n+1} , sum \rightarrow \sum Ni\}"></p><p>在实践中，需要对搜索进行限制（时间超时、路径数、循环迭代次数、搜索深度等）</p><h3 id="静态符号执行的缺点"><a href="#静态符号执行的缺点" class="headerlink" title="静态符号执行的缺点"></a>静态符号执行的缺点</h3><ul><li>关键缺点：当符号执行得到的约束不能被约束求解器求解时，就无法生产输入</li></ul><p>假如上面的代码例子产生变化：</p><p>① twice函数发生了改变：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span> <span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (v∗v) % <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则符号执行到twice函数时，会产生两个路径约束：</p><img src="http://latex.codecogs.com/svg.latex?x_0 \neq (y_0y_0)mod50"><img src="http://latex.codecogs.com/svg.latex?x_0 = (y_0y_0)mod50"><p>② 假设twice函数不可用（例如没有函数源码），则会产生两个路径约束：</p><img src="http://latex.codecogs.com/svg.latex?x_0 \neq twice(y_0)"><img src="http://latex.codecogs.com/svg.latex?x_0=twice(y_0)"><p>其中，<img src="http://latex.codecogs.com/svg.latex?twice">是一个未解释的函数</p><p>在这两种情况下，约束求解器无法解决任何这些约束，符号执行将无法为修改后的程序生成任何输入。</p><p>为了缓解这个问题，研究者提出了混合符号执行 concolic execution（实际执行+符号执行）的方法，这是一种动态的符号执行，可以为修改后的程序生产一些输入。</p><h2 id="混合符号执行（Concolic-Execution）"><a href="#混合符号执行（Concolic-Execution）" class="headerlink" title="混合符号执行（Concolic Execution）"></a>混合符号执行（Concolic Execution）</h2><hr><p>混合符号执行Concolic Execution（实际执行+符号执行），是一种动态符号执行。在执行符号执行的同时，程序也在一些具体的输入值上执行。</p><p>Concolic Execution维护一个具体状态和一个符号状态。</p><ul><li>具体状态将所有变量映射到它们的具体值</li><li>符号状态仅映射具有非具体值的变量</li></ul><p>与经典的符号执行不同，混合符号执行在过程中需要获取程序的具体状态，因此它需要初始的具体值作为输入。</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>Concolic Executio的初试输入可以给定或随机生成，在执行过程中收集条件语句中对输入的符号约束，然后使用约束求解器推断先前输入的变体（取反等），以便将程序的下一次执行引导到另一条执行路径。</p><p>系统地或启发式地重复该过程，直到探索完所有执行路径，满足用户定义的覆盖标准，或时间预算到期。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testme</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    z = twice(y);</span><br><span class="line">    <span class="keyword">if</span> (z == x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y + <span class="number">10</span>)</span><br><span class="line">            ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = sym_input();</span><br><span class="line">    y = sym_input();</span><br><span class="line">    testme(x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是以上面的程序为例：</p><ol><li>首先，Concolic Execution先产生一些随机输入，例如{x = 22, y = 7}</li><li>之后，同时具体地和符号化地执行程序。 当实际执行到第7行的else分支时，符号执行会在该执行路径生成路径约<img src="http://latex.codecogs.com/svg.latex?x_0\neq2y_0"></li><li>之后，Concolic Execution会将路径约束的连接词取反，得到<img src="http://latex.codecogs.com/svg.latex?x_0= 2y_0">，并求解，可得到一种测试用例输入：{x = 2, y = 1}</li><li>通过这个新的测试用例输入，Concolic Execution会得到并进入新的路径，并同时开启新的实际执行与符号执行。 在本例中，就会进入到第7行的then分支和第8行的else分支，此时就会产生新的路径约束：<img src="http://latex.codecogs.com/svg.latex?(x_0=2y_0) \Lambda (x_0 \leq y_0+10)">，对于此约束进行约束求解，生成新的测试输入，可以让程序继续执行之前没有执行过的路径；而再对该约束取反，得到：<img src="http://latex.codecogs.com/svg.latex?(x_0=2y_0) \Lambda (x_0 > y_0+10)">，就可以探索到新的路径，例如：{x = 30, y = 15}，使用这个测试输入，程序会触发第9行的ERROR。</li><li>通过这三次执行程序，Concolic Execution已经覆盖了程序的所有路径，并停止生产测试用例输入</li></ol><p>注意，这里使用“深度优先”的搜索策略来探索所有的执行路径；我们也可以使用其他策略来探索不同顺序的路径。</p><h2 id="执行生成测试-EGT"><a href="#执行生成测试-EGT" class="headerlink" title="执行生成测试(EGT)"></a>执行生成测试(EGT)</h2><hr><p>本文作者通过<a href="https://dl.acm.org/doi/abs/10.1145/1455518.1455522">EXE</a>和<a href="https://www.usenix.org/legacy/event/osdi08/tech/full_papers/cadar/cadar.pdf">Klee</a> 这两篇工作，实现和扩展了<a href="https://link.springer.com/chapter/10.1007/11537328_2">EGT方法</a> （Execution-Generated Testing）</p><p>EGT方法区分了程序的具体状态和符号状态，通过在每次操作之前动态检查所涉及的值是否是实际的，将具体执行和符号执行混合在一起。</p><p>如果是实际值，那么就按照程序本身执行；相反，如果至少有一个值是符号化的，则通过更新当前路径的路径条件以符号方式执行。</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>还是以上面的程序为例，在第17行处，如果把<code>y**=**sym input()</code> 改为 <code>y = 10</code>，那么第6行<code>z **=**twice (y);</code> 函数将使用具体值 “20”来调用函数twice(20)，完成实际执行。</p><p>之后，第7行<code>if (z == x)</code>将变为<code>if (20 == x)</code>    </p><p>约束<img src="http://latex.codecogs.com/svg.latex?x=20">，程序走then分支</p><p>约束<img src="http://latex.codecogs.com/svg.latex?x \neq 20">，程序走else分支</p><p>注意，在then分支，程序走到第8行为<code>if (x &gt; 20)</code>， 由于x = 20，则无法往下继续走。</p><p>总之，混合符号执行Concolic Execution与执行生成测试EGT，主要的贡献都是结合了实际执行与符号执行，缓解了传统符号执行的缺点。它们都是动态符号执行的范畴。</p><h2 id="动态符号执行的缺点"><a href="#动态符号执行的缺点" class="headerlink" title="动态符号执行的缺点"></a>动态符号执行的缺点</h2><hr><p>动态符号执行的优点是：可以使用具体值，来降低与外部代码交互或约束求解超时所导致的不精确性，这缓解了传统符号执行遇到的问题。但是这个过程遇到的问题是，会丢失一些执行路径，从而牺牲了完整性。</p><ul><li>先回顾一下Concolic Execution是怎样解决静态符号执行的缺点的：  例如，在上面的代码例子中，将twice函数进行改变：返回值改为<code>(v*v)%50</code>  ，而且程序执行的初试随机值为{x = 22, y = 7}，则针对该随机输入，生成的路径约束为 <img src="http://latex.codecogs.com/svg.latex?x_{0}\ne (y_{0} y_{0}) mod 50">  假设约束求解器不能解决非线性约束，则Concolic Execution将无法为替代执行路径生成输入。当函数twice的源代码不可用时（是某个第三方库函数或系统调用），会出现类似情况，此时，路径约束为<img src="http://latex.codecogs.com/svg.latex?x_0 \neq twice(y_0)"> ，其中<img src="http://latex.codecogs.com/svg.latex?twice">是一个未解释的函数。  以上是前文静态符号执行的缺点，混合符号执行Concolic Execution会通过使用实际值替换符号值的方式解决这个问题。例如，将<img src="http://latex.codecogs.com/svg.latex?y0">使用实际值 “7” 替换。那么上面的路径约束就简化为：<img src="http://latex.codecogs.com/svg.latex?x_0 \neq 49"> ，求解该约束，可以得到一个探索新路径的输入：{x = 49, y = 7}。以此解决了传统符号执行（静态符号执行）的缺点。</li></ul><p>但是，这个例子中，无法生成路径true, false的输入，即在代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testme</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    z = twice(y);</span><br><span class="line">    <span class="keyword">if</span> (z == x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y + <span class="number">10</span>)</span><br><span class="line">            ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中，符合if (z == x)，但又不符合if (x &gt; y + 10)，进不去ERROR</p><p>即：无法生成对于约束<img src="http://latex.codecogs.com/svg.latex?x_{0}= (y_{0} y_{0}) mod 50\wedge (x_{0}\leq y_{0}+10)">的测试输入，因为<img src="http://latex.codecogs.com/svg.latex?y_0">的值已经被实际化为“7”了。因此会造成路径的丢失，失去了路径完整性。</p><p>但是相比与传统符号执行遇到不受支持的操作或外部调用问题时直接终止执行，混合符号执行Concolic Execution的方法还是更可取。</p><h2 id="符号执行的挑战"><a href="#符号执行的挑战" class="headerlink" title="符号执行的挑战"></a>符号执行的挑战</h2><hr><h3 id="一、路径爆炸"><a href="#一、路径爆炸" class="headerlink" title="一、路径爆炸"></a>一、路径爆炸</h3><p>符号执行的关键挑战之一就是路径爆炸问题。除了较小的程序外，所有程序中都有大量的程序路径，这通常是代码中静态分支数量的指数级。限制符号执行时间及循环迭代次数都可以缓解这一问题，主要的方法包括：</p><ul><li>启发式技术-优先探索最有希望的路径  启发式技术是用于确定路径探索优先顺序的关键机制。<ul><li>使用CFG来探索，尽量选择与未覆盖指令最接近的路径</li><li>基于随机探索，将符号探索与随机测试相结合</li></ul></li><li>使用合理的程序分析技术降低路径探索的复杂性<ul><li>使用 selelct 表达式进行静态融合，然后将其直接传递给约束求解器</li><li>通过缓存和重用底层函数的计算结果，减小分析的复杂性</li></ul></li></ul><p>以上这些方法都是当时其他文献的工作，这里没有深入研究。</p><h3 id="二、约束求解"><a href="#二、约束求解" class="headerlink" title="二、约束求解"></a>二、约束求解</h3><p>两种优化方法：</p><ul><li>不相关的约束消除：通常一个程序分支只依赖于一小部分的程序变量，因此一种有效的优化是从当前路径条件中移除与识别当前分支不相关的约束</li><li>增量求解：在符号执行期间生成的约束集的一个重要特征是，它们以来自程序源代码的一组固定的静态分支来表示。所以，多个路径可能会产生相似的约束集，所以可以使用相似的解决方案。通过重用以前相似请求得到的结果，可以提升约束求解的速度（CUTE、KLEE使用）</li></ul><h3 id="三、内存建模"><a href="#三、内存建模" class="headerlink" title="三、内存建模"></a>三、内存建模</h3><p>程序语句转换为符号约束的精确性对符号执行的覆盖率有很大的影响。内存建模可以引申为其他方面的挑战，主要是符号执行如何模拟具体的系统环境。</p><p>精确度和可伸缩性之间的权衡应该根据要分析的代码(例如，低级系统代码与高级应用程序代码)以及不同约束求解理论之间的确切性能差异来确定。而在动态符号执行中，可以通过自定义符号公式中具体值的使用来调整可伸缩性和精度。</p><h3 id="四、处理并发性"><a href="#四、处理并发性" class="headerlink" title="四、处理并发性"></a>四、处理并发性</h3><p>动态符号执行已经被有效地用于测试并发程序，包括具有复杂数据输入的应用程序、分布式系统等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;该论文以较为通俗的语言和简单的例子阐述了符号执行的基本原理，并介绍了符号执行技术的发展历程和面临挑战。通过本文，可以基本的了解符号执行&lt;br&gt;论文地址：&lt;a href=&quot;https://dl.acm.org/doi/fullHtml/10.1145/2408776.2408795&quot;&gt;https://dl.acm.org/doi/fullHtml/10.1145/2408776.2408795&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Symbol Execution" scheme="http://example.com/categories/Symbol-Execution/"/>
    
    
    <category term="Paper Reading" scheme="http://example.com/tags/Paper-Reading/"/>
    
    <category term="Symbol Execution" scheme="http://example.com/tags/Symbol-Execution/"/>
    
  </entry>
  
  <entry>
    <title>Fuzzing101 Exercise 2 - libexif - CVE-2009-3895&amp;CVE-2012-2836</title>
    <link href="http://example.com/2022/01/10/Exercise%202/"/>
    <id>http://example.com/2022/01/10/Exercise%202/</id>
    <published>2022-01-10T13:00:00.000Z</published>
    <updated>2022-04-05T08:08:46.450Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%202">Fuzzing101/Exercise 2 at main · antonio-morales/Fuzzing101</a></p><ul><li>任务：在libexif中，找到两个crash  <strong><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895">CVE-2009-3895</a>&amp;****<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836">CVE-2012-2836</a></strong></li><li>版本：libexif 0.6.14</li><li><strong><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895">CVE-2009-3895</a>：</strong>一种基于堆的缓冲区溢出，可以用无效的 EXIF 图像触发。<ul><li>漏洞描述：基于堆的缓冲区溢出是一种发生在堆数据区的缓冲区溢出，它通常与显式动态内存管理（使用 malloc() 和 free() 函数进行分配/释放）有关。因此，远程攻击者可以利用此问题在使用受影响库的应用程序上下文中执行任意代码。</li></ul></li><li><strong><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836">CVE-2012-2836</a>：</strong>一个越界读取漏洞，可以通过带有精心制作的 EXIF 标签的图像触发。<ul><li>漏洞描述：越界读取是当程序读取数据超过预期缓冲区的末尾或开头之前发生的漏洞。因此，它允许远程攻击者导致拒绝服务或可能从进程内存中获取潜在的敏感信息。</li></ul></li><li>本地实验环境：<strong>虚拟机Ubuntu 20.04.3 LTS</strong><span id="more"></span></li></ul><hr><p>AFL使用非确定性测试算法，因此两个模糊会话永远不会相同。因此作者强烈建议设置一个固定的种子(-s 123)。这样模糊结果将类似于这些显示，更容易跟随练习。</p><p>作者建议使用<strong>Ubuntu 20.04.2 LTS</strong>，因为作者已在该环境下测试过，而且建议使用主机而不是虚拟机，以发挥AFL更好的性能</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><hr><ul><li>下载安装libexif-0.6.14</li></ul><p>新建目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line">mkdir fuzzing_libexif &amp;&amp; <span class="built_in">cd</span> fuzzing_libexif/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/libexif/libexif/archive/refs/tags/libexif-0_6_14-release.tar.gz</span><br><span class="line">tar -xzvf libexif-0_6_14-release.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> libexif-libexif-0_6_14-release/</span><br><span class="line">sudo apt-get install autopoint libtool gettext libpopt-dev</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>选择libexif调用接口—exif</li></ul><p>由于 libexif 是一个库，因此我们需要另一个使用该库的应用程序，并将对其进行模糊测试。对于此任务，我们将使用<strong>exif</strong> 命令行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif</span><br><span class="line">wget https://github.com/libexif/exif/archive/refs/tags/exif-0_6_15-release.tar.gz</span><br><span class="line">tar -xzvf exif-0_6_15-release.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> exif-exif-0_6_15-release/</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/install/&quot;</span> PKG_CONFIG_PATH=<span class="variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>测试是否安装成功：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/fuzzing_libexif/install/bin/exif</span><br></pre></td></tr></table></figure><p><img src="/2022/01/10/Exercise%202/Untitled.png"></p><ul><li>建立种子语料库（<strong>Seed corpus</strong>）</li></ul><p>我们需要获取一些 exif 样本。我们将使用以下 repo 中的示例图像：<a href="https://github.com/ianare/exif-samples">https</a> : <a href="https://github.com/ianare/exif-samples">//github.com/ianare/exif-samples</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif</span><br><span class="line">wget https://github.com/ianare/exif-samples/archive/refs/heads/master.zip</span><br><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure><p>之后，我们可以这样使用（举例）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/fuzzing_libexif/install/bin/exif <span class="variable">$HOME</span>/fuzzing_libexif/exif-samples-master/jpg/Canon_40D_photoshop_import.jpg</span><br></pre></td></tr></table></figure><ul><li><strong>Afl-clang-lto</strong></li></ul><p>使用<strong>afl-clang-lto</strong>作为编译器来构建 libexif</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -r <span class="variable">$HOME</span>/fuzzing_libexif/install</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif/libexif-libexif-0_6_14-release/</span><br><span class="line">make clean</span><br><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif/exif-exif-0_6_15-release</span><br><span class="line">make clean</span><br><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/install/&quot;</span> PKG_CONFIG_PATH=<span class="variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>一般来说，<em>afl-clang-lto</em>是最好的选择，因为它是一种无碰撞的仪器（<strong>instrumentation</strong>），而且比<em>afl-clang-fast 更快</em>。</p><p>如果您不确定何时使用<em>afl-clang-lto</em>或<em>afl-clang-fast，</em>您可以查看从<a href="https://github.com/AFLplusplus/AFLplusplus#1-instrumenting-that-target">AFLplusplus</a>提取的下图来选择</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+--------------------------------+</span><br><span class="line">| clang/clang++ 11+ is available | --&gt; use LTO mode (afl-clang-lto/afl-clang-lto++)</span><br><span class="line">+--------------------------------+     see [instrumentation/README.lto.md](instrumentation/README.lto.md)</span><br><span class="line">    |</span><br><span class="line">    | <span class="keyword">if</span> not, or <span class="keyword">if</span> the target fails with LTO afl-clang-lto/++</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">+---------------------------------+</span><br><span class="line">| clang/clang++ 6.0+ is available | --&gt; use LLVM mode (afl-clang-fast/afl-clang-fast++)</span><br><span class="line">+---------------------------------+     see [instrumentation/README.llvm.md](instrumentation/README.llvm.md)</span><br><span class="line">    |</span><br><span class="line">    | <span class="keyword">if</span> not, or <span class="keyword">if</span> the target fails with LLVM afl-clang-fast/++</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"> +--------------------------------+</span><br><span class="line"> | gcc 5+ is available            | -&gt; use GCC_PLUGIN mode (afl-gcc-fast/afl-g++-fast)</span><br><span class="line"> +--------------------------------+    see [instrumentation/README.gcc_plugin.md](instrumentation/README.gcc_plugin.md) and</span><br><span class="line">                                       [instrumentation/README.instrument_list.md](instrumentation/README.instrument_list.md)</span><br><span class="line">    |</span><br><span class="line">    | <span class="keyword">if</span> not, or <span class="keyword">if</span> you <span class="keyword">do</span> not have a gcc with plugin support</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">   use GCC mode (afl-gcc/afl-g++) (or afl-clang/afl-clang++ <span class="keyword">for</span> clang)</span><br></pre></td></tr></table></figure><h1 id="开始模糊测试"><a href="#开始模糊测试" class="headerlink" title="开始模糊测试"></a>开始模糊测试</h1><hr><p>运行fuzz</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i <span class="variable">$HOME</span>/fuzzing_libexif/exif-samples-master/jpg/ -o <span class="variable">$HOME</span>/fuzzing_libexif/out/ -s 123 -- <span class="variable">$HOME</span>/fuzzing_libexif/install/bin/exif @@</span><br></pre></td></tr></table></figure><p>可以发现许多crash</p><p><img src="/2022/01/10/Exercise%202/Untitled%201.png"></p><h1 id="使用Eclipse-CDT调试"><a href="#使用Eclipse-CDT调试" class="headerlink" title="使用Eclipse-CDT调试"></a>使用Eclipse-CDT调试</h1><p>安装JAVA-SDK</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install default-jdk</span><br></pre></td></tr></table></figure><p>下载Eclipse：<a href="https://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/2021-12/R/eclipse-cpp-2021-12-R-linux-gtk-x86_64.tar.gz">https://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/2021-12/R/eclipse-cpp-2021-12-R-linux-gtk-x86_64.tar.gz</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzvf eclipse-cpp-2021-03-R-linux-gtk-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>完成这两步后，打开Eclipse — File — Import — C/C++ — “Existing code as makefile project”</p><p><img src="/2022/01/10/Exercise%202/Untitled%202.png"></p><p>之后选择Linux GCC 并选择exif源码文件夹</p><p><img src="/2022/01/10/Exercise%202/Untitled%203.png"></p><p>之后可以在项目资源管理器中看到exif文件夹。</p><p>现在要配置调试的参数。Run — Debug Configurations，选择我们的exif项目及exif二进制文件</p><p><img src="/2022/01/10/Exercise%202/Untitled%204.png"></p><p>之后要设置Arguments，我们找到刚才AFL产生的crash路径，选一条复制进去</p><p>【至于选择哪一条，这里确实不太明白】</p><p><img src="/2022/01/10/Exercise%202/Untitled%205.png"></p><p>点击Debug后，程序会停在main函数开头</p><p><img src="/2022/01/10/Exercise%202/Untitled%206.png"></p><p>Run — Resume 检测到分段错误时会自动停止运行</p><p><img src="/2022/01/10/Exercise%202/Untitled%207.png"></p><h1 id="实验总结与心得"><a href="#实验总结与心得" class="headerlink" title="实验总结与心得"></a>实验总结与心得</h1><hr><ol><li>每次fuzz，不管时间是多少，产生crash数量与类型都是不同的。</li><li>多个crash，可能指向的代码点是同一处。</li><li>作者指出的这两处CVE的溢出点，我在fuzz产生的crash调试时，都没有发现（即使第二次fuzz了3个小时，产生了30个crash，也没有发现）</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%202&quot;&gt;Fuzzing101/Exercise 2 at main · antonio-morales/Fuzzing101&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务：在libexif中，找到两个crash  &lt;strong&gt;&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895&quot;&gt;CVE-2009-3895&lt;/a&gt;&amp;amp;****&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836&quot;&gt;CVE-2012-2836&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;版本：libexif 0.6.14&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895&quot;&gt;CVE-2009-3895&lt;/a&gt;：&lt;/strong&gt;一种基于堆的缓冲区溢出，可以用无效的 EXIF 图像触发。&lt;ul&gt;
&lt;li&gt;漏洞描述：基于堆的缓冲区溢出是一种发生在堆数据区的缓冲区溢出，它通常与显式动态内存管理（使用 malloc() 和 free() 函数进行分配/释放）有关。因此，远程攻击者可以利用此问题在使用受影响库的应用程序上下文中执行任意代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836&quot;&gt;CVE-2012-2836&lt;/a&gt;：&lt;/strong&gt;一个越界读取漏洞，可以通过带有精心制作的 EXIF 标签的图像触发。&lt;ul&gt;
&lt;li&gt;漏洞描述：越界读取是当程序读取数据超过预期缓冲区的末尾或开头之前发生的漏洞。因此，它允许远程攻击者导致拒绝服务或可能从进程内存中获取潜在的敏感信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本地实验环境：&lt;strong&gt;虚拟机Ubuntu 20.04.3 LTS&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Fuzzing101 Exercise 1 - Xpdf - CVE-2019-13288</title>
    <link href="http://example.com/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/"/>
    <id>http://example.com/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/</id>
    <published>2021-11-29T13:00:00.000Z</published>
    <updated>2021-11-29T14:25:59.655Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201">Fuzzing101/Exercise 1 at main · antonio-morales/Fuzzing101</a></p><ul><li>任务：在Xpdf这一PDF阅读器中，找到一个crash  [<strong>CVE-2019-13288]</strong></li><li>版本：XPDF 3.02</li><li>CVE-2019-13288：是一个可能通过精心制作的文件导致无限递归的漏洞<ul><li>漏洞描述：由于程序中每个被调用的函数在堆栈上分配一个堆栈帧，如果一个函数被递归调用太多次，可能会导致堆栈内存耗尽和程序崩溃。因此，远程攻击者可以利用这一点进行DoS攻击。</li><li>详细信息：<a href="https://www.cvedetails.com/cve/CVE-2019-13288/">https://www.cvedetails.com/cve/CVE-2019-13288/</a></li></ul></li><li>本地实验环境：<strong>虚拟机Ubuntu 20.04.3 LTS</strong></li><li>关于非受控递归漏洞：<a href="https://cwe.mitre.org/data/definitions/674.html">https://cwe.mitre.org/data/definitions/674.html</a><span id="more"></span></li></ul><hr><p>AFL使用非确定性测试算法，因此两个模糊会话永远不会相同。因此作者强烈建议设置一个固定的种子(-s 123)。这样模糊结果将类似于这些显示，更容易跟随练习。</p><p>作者建议使用<strong>Ubuntu 20.04.2 LTS</strong>，因为作者已在该环境下测试过，而且建议使用主机而不是虚拟机，以发挥AFL更好的性能</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><hr><p>新建目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line">mkdir fuzzing_xpdf &amp;&amp; <span class="built_in">cd</span> fuzzing_xpdf/</span><br></pre></td></tr></table></figure><p>安装额外工具（即 make 和 gcc）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install build-essential</span><br></pre></td></tr></table></figure><p>下载XPDF 3.02</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gz</span><br><span class="line">tar -xvzf xpdf-3.02.tar.gz</span><br></pre></td></tr></table></figure><p>构建XPDF</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> xpdf-3.02</span><br><span class="line">sudo apt update &amp;&amp; sudo apt install -y build-essential gcc</span><br><span class="line">./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_xpdf/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>下载PDF示例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_xpdf</span><br><span class="line">mkdir pdf_examples &amp;&amp; <span class="built_in">cd</span> pdf_examples</span><br><span class="line">wget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdf</span><br><span class="line">wget http://www.africau.edu/images/default/sample.pdf</span><br><span class="line">wget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf</span><br></pre></td></tr></table></figure><p>使用以下命令测试pdfinfo二进制文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/fuzzing_xpdf/install/bin/pdfinfo -box -meta <span class="variable">$HOME</span>/fuzzing_xpdf/pdf_examples/helloworld.pdf</span><br></pre></td></tr></table></figure><p>得到：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled.png"></p><h1 id="安装AFL"><a href="#安装AFL" class="headerlink" title="安装AFL++"></a>安装AFL++</h1><hr><p>作者推荐本地安装（也可以使用Docker）</p><p>安装依赖：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools</span><br><span class="line">sudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang </span><br><span class="line">sudo apt-get install -y gcc-$(gcc --version|head -n1|sed <span class="string">&#x27;s/.* //&#x27;</span>|sed <span class="string">&#x27;s/\..*//&#x27;</span>)-plugin-dev libstdc++-$(gcc --version|head -n1|sed <span class="string">&#x27;s/.* //&#x27;</span>|sed <span class="string">&#x27;s/\..*//&#x27;</span>)-dev</span><br></pre></td></tr></table></figure><p>构建AFL++</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/AFLplusplus/AFLplusplus &amp;&amp; <span class="built_in">cd</span> AFLplusplus</span><br><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line">make distrib</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>安装成功：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%201.png"></p><p>为了我们的目标应用程序启用检测，我们需要使用 AFL 的编译器编译代码</p><p>首先，我们将清理所有以前编译的目标文件和可执行文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -r <span class="variable">$HOME</span>/fuzzing_xpdf/install</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_xpdf/xpdf-3.02/</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p>使用<strong>afl-clang-fast</strong>编译器构建 xpdf ：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line">CC=<span class="variable">$HOME</span>/AFLplusplus/afl-clang-fast CXX=<span class="variable">$HOME</span>/AFLplusplus/afl-clang-fast++ ./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_xpdf/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>之后可以使用以下命令来运行fuzz</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i <span class="variable">$HOME</span>/fuzzing_xpdf/pdf_examples/ -o <span class="variable">$HOME</span>/fuzzing_xpdf/out/ -s 123 -- <span class="variable">$HOME</span>/fuzzing_xpdf/install/bin/pdftotext @@ <span class="variable">$HOME</span>/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure><p>每个选项的简要说明：</p><ul><li>-<em>i</em>表示我们必须放置输入案例（文件示例）的目录</li><li>-<em>o</em>表示 AFL++ 将存储变异文件的目录</li><li>-<em>s</em>表示要使用的静态随机种子</li><li>*@@*是占位符目标的命令行，AFL 将用每个输入文件名替换它</li></ul><p>等待一段时间后，发现crash，之后可以直接<code>ctrl+c</code>结束fuzz。</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%202.png"></p><h1 id="分析crash"><a href="#分析crash" class="headerlink" title="分析crash"></a>分析crash</h1><hr><p>在<code>$HOME/fuzzing_xpdf/out/</code>目录中找到crash对应的文件：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%203.png"></p><p>将此文件作为输入传递给 pdftotext 二进制文件(如果系统报打不开文件，就改下文件名，例如test.pdf)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/fuzzing_xpdf/install/bin/pdftotext <span class="string">&#x27;$HOME/fuzzing_xpdf/out/default/crashes/&lt;your_filename&gt;&#x27;</span> <span class="variable">$HOME</span>/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure><p>这里注意两个坑，一是不能直接使用pdftotext XXX，结果是不一样的；二是要把命令中间的引号去掉才能运行，不知道这里作者用的引号是什么意思</p><p>最终输出：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%204.png"></p><p>开始使用GDB来查找产生crash的原因</p><p>首先，需要使用调试信息重建 Xpdf 以获得符号堆栈跟踪：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -r <span class="variable">$HOME</span>/fuzzing_xpdf/install</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_xpdf/xpdf-3.02/</span><br><span class="line">make clean</span><br><span class="line">CFLAGS=<span class="string">&quot;-g -O0&quot;</span> CXXFLAGS=<span class="string">&quot;-g -O0&quot;</span> ./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_xpdf/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>运行GDB：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb --args <span class="variable">$HOME</span>/fuzzing_xpdf/install/bin/pdftotext <span class="variable">$HOME</span>/fuzzing_xpdf/out/default/crashes/&lt;your_filename&gt; <span class="variable">$HOME</span>/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%205.png"></p><p>输入<code>run</code>得到：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%206.png"></p><p>之后输入<code>bt</code> 查看调用栈</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%207.png"></p><p>发现程序一直在调用<code>Parser::getObj</code>这一函数，这也正匹配了<a href="https://www.cvedetails.com/cve/CVE-2019-13288/">https://www.cvedetails.com/cve/CVE-2019-13288/</a>中描述的该CVE漏洞信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">In Xpdf 4.01.01, the Parser::getObj() <span class="keyword">function</span> <span class="keyword">in</span> Parser.cc may cause infinite recursion via a crafted file. A remote attacker can leverage this <span class="keyword">for</span> a DoS attack. This is similar to CVE-2018-16646.</span><br><span class="line">Publish Date : 2019-07-04 Last Update Date : 2020-08-24</span><br><span class="line"></span><br><span class="line">在 Xpdf 4.01.01 中，Parser.cc 中的 Parser::getObj() 函数可能会通过精心制作的文件导致无限递归。远程攻击者可以利用它进行 DoS 攻击。这类似于 CVE-2018-16646。</span><br><span class="line">发布日期：2019-07-04 最后更新日期：2020-08-24</span><br></pre></td></tr></table></figure><h1 id="修复bug"><a href="#修复bug" class="headerlink" title="修复bug"></a>修复bug</h1><hr><p>这里我们可以下载已修复错误的 Xpdf 4.02，对比下代码：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%208.png"></p><p>参考资料：</p><p><a href="https://chowdera.com/2021/09/20210912223059406n.html">https://chowdera.com/2021/09/20210912223059406n.html</a></p><p><a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201">https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise 1</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201&quot;&gt;Fuzzing101/Exercise 1 at main · antonio-morales/Fuzzing101&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务：在Xpdf这一PDF阅读器中，找到一个crash  [&lt;strong&gt;CVE-2019-13288]&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;版本：XPDF 3.02&lt;/li&gt;
&lt;li&gt;CVE-2019-13288：是一个可能通过精心制作的文件导致无限递归的漏洞&lt;ul&gt;
&lt;li&gt;漏洞描述：由于程序中每个被调用的函数在堆栈上分配一个堆栈帧，如果一个函数被递归调用太多次，可能会导致堆栈内存耗尽和程序崩溃。因此，远程攻击者可以利用这一点进行DoS攻击。&lt;/li&gt;
&lt;li&gt;详细信息：&lt;a href=&quot;https://www.cvedetails.com/cve/CVE-2019-13288/&quot;&gt;https://www.cvedetails.com/cve/CVE-2019-13288/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本地实验环境：&lt;strong&gt;虚拟机Ubuntu 20.04.3 LTS&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;关于非受控递归漏洞：&lt;a href=&quot;https://cwe.mitre.org/data/definitions/674.html&quot;&gt;https://cwe.mitre.org/data/definitions/674.html&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>IDA Python 常用API（持续更新）</title>
    <link href="http://example.com/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://example.com/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2021-11-17T13:21:00.000Z</published>
    <updated>2021-11-18T03:05:58.230Z</updated>
    
    <content type="html"><![CDATA[<p>环境：IDAPro 7.6</p><p>（注意IDAPro 7.4版本后，IDA Python的API版本与7.4之前的版本发生了很多变化，具体区别请看<a href="https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml">https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml</a>）</p><span id="more"></span><h2 id="常见模块"><a href="#常见模块" class="headerlink" title="常见模块"></a>常见模块</h2><p>在IDA中.有三个重要的库.分别是IDC,idautils,idaapi</p><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>IDC</td><td>封装IDA与IDC函数的兼容性模块.</td></tr><tr><td>idautils</td><td>高级实用的模块</td></tr><tr><td>idaapi</td><td>允许访问更加底层的数据</td></tr></tbody></table><h2 id="获取IDA界面地址"><a href="#获取IDA界面地址" class="headerlink" title="获取IDA界面地址"></a>获取IDA界面地址</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>取当前地址</td><td>idc.here() 或 idc.get_screen_ea()</td></tr><tr><td>获取最小地址（可以使用的）</td><td>ida_ida.inf_get_min_ea()</td></tr><tr><td>获取最大地址（可以使用的）</td><td>ida_ida.inf_get_max_ea()</td></tr><tr><td>获取所选范围的起始地址</td><td>idc.read_selection_start()</td></tr><tr><td>获取所选范围的结束地址</td><td>idc.read_selection_end()</td></tr><tr><td></td><td></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;当前地址：&#x27;</span>+<span class="built_in">hex</span>(idc.here()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;基址：&#x27;</span>+<span class="built_in">hex</span>(ida_ida.inf_get_min_ea())))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled.png"></p><h2 id="获取地址的数值"><a href="#获取地址的数值" class="headerlink" title="获取地址的数值"></a>获取地址的数值</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>以1字节为单位获取地址处的值</td><td>idc.get_wide_byte(addr)</td></tr><tr><td>以2字节(字)的单位获取</td><td>idc.get_wide_word(addr)</td></tr><tr><td>以4字节的单位获取</td><td>idc.get_wide_dword(addr)</td></tr><tr><td>以8字节的单位获取</td><td>idc.get_qword(addr)</td></tr><tr><td>判断是否是字节</td><td>ida_bytes.is_byte</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;当前地址：&#x27;</span>+<span class="built_in">hex</span>(idc.here()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;值&#x27;</span>+<span class="built_in">hex</span>(idc.get_wide_byte(idc.here())))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%201.png"></p><h2 id="修改指令数值"><a href="#修改指令数值" class="headerlink" title="修改指令数值"></a>修改指令数值</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>修改addr地址的值为value.每次修改1个字节</td><td>ida_bytes.patch_byte(addr,value)</td></tr><tr><td>每次修改2个字节</td><td>ida_bytes.patch_word(addr,value)</td></tr><tr><td>每次修改4个字节</td><td>ida_bytes.patch_Dword(addr,value)</td></tr><tr><td>每次修改8个字节</td><td>ida_bytes.patch_Qword(addr,value)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line">addr = idc.here()</span><br><span class="line">value_before = idc.get_wide_byte(addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改之前：&quot;</span>+ <span class="built_in">hex</span>(value_before))</span><br><span class="line"></span><br><span class="line">ida_bytes.patch_byte(addr,<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">value_after = idc.get_wide_byte(addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改之后：&quot;</span>+ <span class="built_in">hex</span>(value_after))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%202.png" alt="Untitled"></p><h2 id="汇编指令操作"><a href="#汇编指令操作" class="headerlink" title="汇编指令操作"></a>汇编指令操作</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取地址处的汇编语句</td><td>idc.GetDisasm(addr) 或 idc.generate_disasm_line(addr,flags)</td></tr><tr><td>获取指定地址位置的操作数.参数1是地址.参数2是操作数索引.如 mov ebp,esp中： 操作数1是ebp ，操作数2是esp mov则是汇编指令不是操作数</td><td>idc.print_operand(addr,index)</td></tr><tr><td>获取汇编操作指令（如mov、add）</td><td>idc.print_insn_mnem(addr)</td></tr><tr><td>获取操作数的类型</td><td>idc.get_operand_type(addr,index)</td></tr><tr><td>获取指定索引操作数中的值: 如 calll 0x00402004 对应汇编为: FF 15 04 20 40 00 FF15=Call 而操作数的值则为04 20 40 00 (小端) 使用函数之后获取则为地址 00402004</td><td>idc.get_operand_value(addr,index)</td></tr><tr><td>获取下一行汇编</td><td>idc.next_head(addr)</td></tr><tr><td>获取上一行汇编</td><td>idc.PrevHead(addr)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line">ea = idc.here();</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基址为: &quot;</span> + <span class="built_in">hex</span>(idaapi.get_imagebase()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前汇编: &quot;</span> + idc.GetDisasm(ea))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前汇编指令为: &quot;</span> + idc.print_insn_mnem(ea))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前操作数为: &quot;</span> + idc.print_operand(ea,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%203.png" alt="Untitled"></p><h2 id="段操作"><a href="#段操作" class="headerlink" title="段操作"></a>段操作</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取段的名字（参数为当前的地址）</td><td>idc.get_segm_name(addr)</td></tr><tr><td>获取段的开始地址</td><td>idc.get_segm_start(addr)</td></tr><tr><td>获取段的结束地址</td><td>idc.get_segm_end(addr)</td></tr><tr><td>获取第一个段</td><td>idc.get_first_seg(addr)</td></tr><tr><td>获取下一个段</td><td>idc.get_next_seg(addr)</td></tr><tr><td>返回一个列表记录所有段的地址</td><td>idautil.Segments()</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> seg_addr <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">    segname = idc.get_segm_name(seg_addr)</span><br><span class="line">    segstart = idc.get_segm_start(seg_addr)</span><br><span class="line">    segend   = idc.get_segm_end(seg_addr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;段名：&quot;</span> + segname + <span class="string">&quot;起始地址：&quot;</span> + <span class="built_in">hex</span>(segstart) + <span class="string">&quot;结束地址：&quot;</span> + <span class="built_in">hex</span>(segend));</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%204.png" alt="Untitled"></p><h2 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取指定地址之间的所有函数</td><td>idautils.Functions(startaddr,endaddr)</td></tr><tr><td>获取指定地址的函数名</td><td>idc.get_func_name(addr)</td></tr><tr><td>获取函数的注释</td><td>get_func_cmt(addr, repeatable)  repeatable:0/1    0是获取常规注释 1是获取重复注释</td></tr><tr><td>设置函数注释</td><td>idc.set_func_cmt(ea, cmt, repeatable)</td></tr><tr><td>弹出框框要求用户进行选择 参数则是信息</td><td>idc.choose_func(title)</td></tr><tr><td>返回: addr 距离函数的偏移形式</td><td>idc.get_func_off_str(addr)</td></tr><tr><td>寻找函数结尾,如果函数存在则返回结尾地址,否则返回BADADDR</td><td>idc.find_func_end(addr)</td></tr><tr><td>设置函数结尾</td><td>ida_funcs.set_func_end(ea, newend)      newend:新的结束地址</td></tr><tr><td>设置函数开头</td><td>ida_funcs.set_func_start(addr, newstart)</td></tr><tr><td>设置地址处的名字</td><td>idc.set_name(ea, name, SN_CHECK)                 Ex函数也使用set_name</td></tr><tr><td>获取首个函数</td><td>idc.get_prev_func(ea)</td></tr><tr><td>获取下一个函数</td><td>idc.get_next_func(ea)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">    segname = idc.get_segm_name(seg)</span><br><span class="line">    segstart = idc.get_segm_start(seg)</span><br><span class="line">    segend = idc.get_segm_end(seg)</span><br><span class="line">    <span class="keyword">if</span> (segname == <span class="string">&#x27;.text&#x27;</span>):</span><br><span class="line">        <span class="keyword">for</span> funcaddr <span class="keyword">in</span> Functions(segstart,segend):</span><br><span class="line">            funname = idc.get_func_name(funcaddr)</span><br><span class="line">            funend =  idc.find_func_end(funcaddr)</span><br><span class="line">            funnext = idc.get_next_func(funcaddr)</span><br><span class="line">            funnextname = idc.get_func_name(funnext)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;当前函数名: &quot;</span> + funname + <span class="string">&quot;当前结束地址: &quot;</span> + <span class="built_in">hex</span>(funend) +<span class="string">&quot;下一个函数地址: &quot;</span> + <span class="built_in">hex</span>(funnext) + <span class="string">&quot;下一个函数名: &quot;</span> + funnextname)</span><br><span class="line">ea = idc.get_screen_ea()</span><br><span class="line">funnextoffset = idc.get_func_off_str(ea)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前选择地址距离当前函数的偏移为: &quot;</span>+ funnextoffset)</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%205.png" alt="Untitled"></p><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p> 在IDAPython中如果我们想查询某些 数据 代码 二进制 都可以用都搜索函数。</p><p>搜索函数可以是向上搜索 也可以是向下搜索. 搜索失败就会返回-1 也就是BADADDR。</p><p>而搜索功能也常常用于去除花指令当中。</p><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>查找二进制找到返回地址没找到返回-1(BADADDR)</td><td>idc.find_binary(ea, flag, searchstr, radix=16, from_bc695=False)</td></tr><tr><td>从ea开始寻找下一个数据地址</td><td>ida_search.find_data(ea, sflag)</td></tr><tr><td>从ea开始寻找下一个代码地址</td><td>ida_search.find_code(ea, sflag)</td></tr><tr><td>跳转到ea位置</td><td>ida_kernwin.jumpto(ea)</td></tr><tr><td></td><td></td></tr></tbody></table><p>flags取值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SEARCH_DOWN 向下搜索</span><br><span class="line">SEARCH_UP 向上搜索</span><br><span class="line">SEARCH_NEXT 获取下一个找到的对象。</span><br><span class="line">SEARCH_CASE 指定大小写敏感度</span><br><span class="line">SEARCH_UNICODE 搜索 Unicode 字符串。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line">addr = idc.here()</span><br><span class="line">value = idc.find_binary(ea,SEARCH_DOWN,<span class="string">&#x27;C4 00 C4&#x27;</span>)</span><br><span class="line">value1 = idc.find_code(ea,SEARCH_DOWN)</span><br><span class="line">value2 = idc.find_data(ea,SEARCH_DOWN)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前位置：&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;C4 00 C4 所在位置：&quot;</span>+<span class="built_in">hex</span>(value))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下一处代码位置：&quot;</span>+<span class="built_in">hex</span>(value1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下一处数据位置：&quot;</span>+<span class="built_in">hex</span>(value2))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%206.png" alt="Untitled"></p><h2 id="数据校验函数"><a href="#数据校验函数" class="headerlink" title="数据校验函数"></a>数据校验函数</h2><p>数据校验函数有一个参数flag，得到flag后可以直接进行校验</p><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取标志</td><td>ida_bytes.get_full_flags(ea)</td></tr><tr><td>判断是否为代码</td><td>ida_bytes.is_code(f)                                                                     f即标志</td></tr><tr><td>判断是否为数据</td><td>ida_bytes.is_data(f)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line">addr = idc.here()</span><br><span class="line">value = idc.find_binary(ea,SEARCH_DOWN,<span class="string">&#x27;C4 00 C4&#x27;</span>)</span><br><span class="line">value1 = idc.find_code(ea,SEARCH_DOWN)</span><br><span class="line">value2 = idc.find_data(ea,SEARCH_DOWN)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前位置：&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;C4 00 C4 所在位置：&quot;</span>+<span class="built_in">hex</span>(value))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下一处代码位置：&quot;</span>+<span class="built_in">hex</span>(value1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下一处数据位置：&quot;</span>+<span class="built_in">hex</span>(value2))</span><br><span class="line">flag1 = ida_bytes.get_full_flags(value1)</span><br><span class="line">flag2 = ida_bytes.get_full_flags(value2)</span><br><span class="line"><span class="comment">#print(flag)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">hex</span>(value1)) +<span class="string">&quot;处是不是代码？：&quot;</span>  + <span class="built_in">str</span>(ida_bytes.is_code(flag1)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">hex</span>(value2)) +<span class="string">&quot;处是不是代码？：&quot;</span>  + <span class="built_in">str</span>(ida_bytes.is_code(flag2)))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%207.png" alt="Untitled"></p><h2 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h2><p>在IDA的操作中 我们常常会对一个函数按X快捷键来查看谁引用了</p><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取地址处引用位置 A调用B 对B函数地址使用此函数则找到A调用 返回列表.遍历列表则可以找出所有引用位置. 参数1是ea也就是地址,参数2告诉IDA是否跟踪这些代码.</td><td>idautils.CodeRefsTo(ea, flow)</td></tr><tr><td>返回ea的代码引用了何处的代码. 返回一个列表</td><td>idautils.CodeRefsFrom(ea, flow)</td></tr><tr><td>返回一个列表告诉ea位置的数据被谁引用了</td><td>idautils.DataRefsTo(ea)</td></tr><tr><td>告诉我们ea引用了谁.</td><td>idautils.DataRefsFrom(ea)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line">addr = idc.here()   </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> CodeRefsTo(addr,<span class="literal">False</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前汇编: &quot;</span> + idc.GetDisasm(i))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%208.png" alt="Untitled"></p><p>除了上述通过地址来查找引用的方式外，还可以通过函数名来进行查找交叉引用：</p><p>1、先通过<code>idc.get_name_ea_simple(fun_name)</code>找到函数的线性地址</p><p>2、再使用<code>for i in CodeRefsTo(addr,False)</code>得到所有引用的地址</p><p>一个例子：<a href="https://hotspurzzz.github.io/2021/11/12/IDA-Python%20%E6%89%B9%E9%87%8F%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/">https://hotspurzzz.github.io/2021/11/12/IDA-Python 批量脚本分析程序/</a></p><p>官网API文档：</p><p><a href="https://www.hex-rays.com/wp-content/static/products/ida/support/idapython_docs/">https://www.hex-rays.com/wp-content/static/products/ida/support/idapython_docs/</a></p><p>参考链接：</p><p><a href="https://www.cnblogs.com/iBinary/p/14642662.html">https://www.cnblogs.com/iBinary/p/14642662.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;环境：IDAPro 7.6&lt;/p&gt;
&lt;p&gt;（注意IDAPro 7.4版本后，IDA Python的API版本与7.4之前的版本发生了很多变化，具体区别请看&lt;a href=&quot;https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml&quot;&gt;https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml&lt;/a&gt;）&lt;/p&gt;</summary>
    
    
    
    <category term="IDA" scheme="http://example.com/categories/IDA/"/>
    
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
    <category term="IDA Python" scheme="http://example.com/tags/IDA-Python/"/>
    
  </entry>
  
  <entry>
    <title>IDA-Python 批量脚本分析程序</title>
    <link href="http://example.com/2021/11/12/IDA-Python%20%E6%89%B9%E9%87%8F%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2021/11/12/IDA-Python%20%E6%89%B9%E9%87%8F%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-11-12T08:00:00.000Z</published>
    <updated>2021-11-12T10:51:58.777Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，IDA Python对于分析二进制程序来说是一个非常好用的工具。<br>当面对大量的二进制文件需要分析时，可以实现自动化批量处理。<br>环境：IDA Pro7.5    Python3.7</p><span id="more"></span><p>这里准备两个python文件</p><h3 id="analysis-py"><a href="#analysis-py" class="headerlink" title="analysis.py"></a>analysis.py</h3><p>实现对二进制程序的具体分析</p><p>Demo:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> ida_auto</span><br><span class="line"><span class="keyword">import</span> ida_pro</span><br><span class="line"><span class="keyword">import</span> ida_nalt</span><br><span class="line"><span class="keyword">import</span> ida_ida</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis</span>():</span></span><br><span class="line">    <span class="comment">#Do Some Things</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    ida_auto.auto_wait()</span><br><span class="line">    analysis()</span><br><span class="line">    ida_pro.qexit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="run-py"><a href="#run-py" class="headerlink" title="run.py"></a>run.py</h3><p>Demo:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">dir_path = <span class="string">&quot;path_to_binfile&quot;</span></span><br><span class="line">ida64_path = <span class="string">&quot;path_to_ida&quot;</span></span><br><span class="line">analysis_file = <span class="string">&quot;path_to_analysis.py&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(dir_path):</span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> files:</span><br><span class="line">            file_path = os.path.join(root, file_name)</span><br><span class="line">            cmd = <span class="string">&quot;&#123;0&#125; -LD:/mylog.log -c -A -S&#123;1&#125; &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(ida64_path, ana_file, file_path)</span><br><span class="line">            p = subprocess.Popen(cmd)</span><br><span class="line">            p.wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>dir_path</code> 指需要进行分析的二进制文件的目录</p><p><code>ida64_path</code>指向本地IDA程序</p><p><code>analysis_file</code>指向前面的analysis.py</p><h3 id="小示例"><a href="#小示例" class="headerlink" title="小示例"></a>小示例</h3><p>这里需要来分析多个二进制文件中某个函数的调用地址(相对地址）：</p><p>analysis.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> ida_auto</span><br><span class="line"><span class="keyword">import</span> ida_pro</span><br><span class="line"><span class="keyword">import</span> ida_nalt</span><br><span class="line"><span class="keyword">import</span> ida_ida</span><br><span class="line"></span><br><span class="line">outfile = <span class="built_in">open</span>(<span class="string">&quot;result.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis</span>():</span></span><br><span class="line">    addr_base = ida_ida.inf_get_min_ea()</span><br><span class="line">    danger_funcs = [<span class="string">&quot;system&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> danger_funcs:</span><br><span class="line">        addr = idc.get_name_ea_simple(func)</span><br><span class="line">        filename = ida_nalt.get_root_filename()</span><br><span class="line">        <span class="keyword">if</span> addr != BADADDR:</span><br><span class="line">            cross_refs = CodeRefsTo( addr, <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">for</span> ref <span class="keyword">in</span> cross_refs:</span><br><span class="line">                ref = ref - addr_base</span><br><span class="line">                outfile.write(filename + <span class="string">&quot;-&quot;</span> + <span class="string">&quot;%s&quot;</span> % func + <span class="string">&quot;-0x&quot;</span> + <span class="string">&quot;%08x&quot;</span> % ref + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    ida_auto.auto_wait()</span><br><span class="line">    analysis()</span><br><span class="line">    ida_pro.qexit(<span class="number">0</span>)</span><br><span class="line">    outfile.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p> run.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">dir_path = <span class="string">&quot;C://Users/Desktop/bin_file&quot;</span></span><br><span class="line">ida64_path = <span class="string">&quot;E://IDA_Pro_v7.5_Portable/ida.exe&quot;</span></span><br><span class="line">analysis_file = <span class="string">&quot;C://Users/Desktop/analysis.py&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(dir_path):</span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> files:</span><br><span class="line">            <span class="built_in">print</span>(file_name)</span><br><span class="line">            file_path = os.path.join(root, file_name)</span><br><span class="line">            cmd = <span class="string">&quot;&#123;0&#125; -LD:/mylog.log -c -A -S&#123;1&#125; &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(ida64_path, ana_file, file_path)</span><br><span class="line">            p = subprocess.Popen(cmd)</span><br><span class="line">            p.wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>只需python3 run.py即可</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>IDA python中的API在7.4版本后产生了变化，如果本地使用的IDA Pro版本≥7.4，之前在网上搜的API可能就无法使用，旧版本与新版本相对应的API变化在这可以查询：</p><p><a href="https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml">https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知，IDA Python对于分析二进制程序来说是一个非常好用的工具。&lt;br&gt;当面对大量的二进制文件需要分析时，可以实现自动化批量处理。&lt;br&gt;环境：IDA Pro7.5    Python3.7&lt;/p&gt;</summary>
    
    
    
    <category term="IDA" scheme="http://example.com/categories/IDA/"/>
    
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
    <category term="IDA Python" scheme="http://example.com/tags/IDA-Python/"/>
    
  </entry>
  
  <entry>
    <title>shellphish-fuzzer环境搭建</title>
    <link href="http://example.com/2021/11/09/shellphish-fuzzer%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2021/11/09/shellphish-fuzzer%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-11-09T08:00:00.000Z</published>
    <updated>2022-03-26T07:49:08.689Z</updated>
    
    <content type="html"><![CDATA[<p>搭建shellphish-fuzzer环境，用于python调用AFL<br>环境：Docker—ubuntu18.04<br>python版本：3.6.9</p><span id="more"></span><p>注：由于个人网络问题，github源使用的<code>https://github.com.cnpmjs.org</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; \</span><br><span class="line">    apt-get upgrade -y &amp;&amp; \</span><br><span class="line">    apt-get autoremove -y &amp;&amp; \</span><br><span class="line">    apt-get install -y \</span><br><span class="line">        curl \</span><br><span class="line">        gdb \</span><br><span class="line">        wget \</span><br><span class="line">        git \</span><br><span class="line">        vim</span><br></pre></td></tr></table></figure><p>换源：</p><p><code>vim /etc/apt/sources.list</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>shellphish-fuzzer的安装：</p><p><code>apt-get install build-essential gcc-multilib libtool automake autoconf bison debootstrap debian-archive-keyring libtool-bin</code></p><p><code>apt-get build-dep qemu</code></p><p>由于没有pip，先安装pip3：</p><p><code>apt-get install python3-pip</code></p><p>安装angr</p><p><code>pip3 install angr</code></p><p>安装driller</p><p><code>pip3 install git+https://github.com.cnpmjs.org/angr/tracer</code></p><p><code>pip3 install git+https://github.com.cnpmjs.org/shellphish/driller</code></p><p>安装afl（可选）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir afl-latest</span><br><span class="line"><span class="built_in">cd</span> afl-latest</span><br><span class="line">wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz</span><br><span class="line">tar xf afl-latest.tgz</span><br><span class="line"><span class="built_in">cd</span> afl-2.52b</span><br><span class="line">make</span><br><span class="line"><span class="built_in">cd</span> qemu_mode</span><br><span class="line">wget -O patches/memfd.diff https://salsa.debian.org/qemu-team/qemu/raw/ubuntu-bionic-2.11/debian/patches/ubuntu/lp1753826-memfd-fix-configure-test.patch</span><br><span class="line">sed -i <span class="string">&#x27;/syscall.diff/a patch -p1 &lt;../patches/memfd.diff || exit 1&#x27;</span> build_qemu_support.sh</span><br><span class="line">./build_qemu_support.sh</span><br></pre></td></tr></table></figure><p>安装shellphish-afl</p><p><code>pip3 install git+https://github.com.cnpmjs.org/shellphish/shellphish-afl</code></p><p>但我使用这种方法会报错</p><p>于是我选择clone下来，执行setup.py</p><p><code>git clone[https://github.com.cnpmjs.org/shellphish/shellphish-afl.git](https://github.com.cnpmjs.org/shellphish/shellphish-afl.git)</code></p><p><code>cd shellphish-afl/</code></p><p><code>python3 [setup.py](http://setup.py/) install</code></p><p>安装fuzzer</p><p><code>pip3 install git+https://github.com.cnpmjs.org/shellphish/fuzzer</code></p><p>测试：</p><p><code>shellphuzz --help</code></p><p><img src="/2021/11/09/shellphish-fuzzer%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Untitled.png"></p><p><img src="/2021/11/09/shellphish-fuzzer%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Untitled%201.png"></p><p>参考链接：</p><p><a href="https://github.com/shellphish/fuzzer">https://github.com/shellphish/fuzzer</a></p><p><a href="https://github.com/shellphish/shellphish-afl">https://github.com/shellphish/shellphish-afl</a></p><p><a href="https://blog.grimm-co.com/2020/05/guided-fuzzing-with-driller.html">https://blog.grimm-co.com/2020/05/guided-fuzzing-with-driller.html</a></p><p>附Dockerfile：</p><p><a href="Dockerfile.txt">Dockerfile</a></p>]]></content>
    
    
    <summary type="html">搭建shellphish-fuzzer环境，用于python调用AFL</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
    <category term="AEG" scheme="http://example.com/tags/AEG/"/>
    
  </entry>
  
</feed>
