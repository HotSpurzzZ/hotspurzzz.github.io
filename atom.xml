<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HotSpurzzZ</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-05T07:59:57.070Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>HotSpurzzZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Panda安装及基础操作（未完，持续记录）</title>
    <link href="http://example.com/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-26T02:00:00.000Z</published>
    <updated>2022-04-05T07:59:57.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Panda概述"><a href="#Panda概述" class="headerlink" title="Panda概述"></a>Panda概述</h1><hr><p>动态分析是计算机安全中的一项基本技术，在处理真实程序时，动态分析通常必须在整个系统上运行，而不是仅仅在一个二进制文件上运行，在受控环境中执行样本，然后监视该环境以了解软件的行为。</p><p>Panda（Platform for Architecture-Neutral Dynamic Analysis）是目前基于QEMU 2.9.1的全系统动态分析引擎，是一个用于架构中性动态分析的开源平台。优势在于软件的快速逆向工程。</p><p>包括一个用于记录和回放执行的系统、一个用于在执行代码上运行 LLVM 分析的框架，以及一个易于扩展的插件架构。</p><p><strong>优势：可以收集一段感兴趣的执行记录，然后一遍又一遍地分析该记录。</strong>记录/重放能够一遍又一遍地重复执行跟踪，所有数据完全相同。然后，可以分析执行情况并慢慢了解事物的存储位置、正在运行的进程、关键执行事件何时发生等。</p><p><img src="/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/Untitled.png"></p><p>PANDA 还具有将 QEMU 的中间表示 TCG 转换为 LLVM 代码的功能，这使得通过 LLVM 通道编写全系统动态分析工具成为可能。这是一个强大的功能，它将两个程序分析框架 QEMU 和 LLVM 连接在一起，以利用两者之间的协同作用。</p><span id="more"></span><ul><li>项目地址</li></ul><p><a href="https://github.com/panda-re/panda">https://github.com/panda-re/panda</a></p><ul><li>用户使用文档：</li></ul><p><a href="https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#recordreplay-details">panda/manual.md at dev · panda-re/panda</a></p><h1 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h1><p>Panda插件通过两种主要方式（插件接口）与 QEMU 交互：</p><ul><li>通过检测回调</li><li>通过公开客户系统状态的检查 API，例如内存状态</li></ul><p><img src="/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/Untitled%201.png"></p><p>常见的一些回调在：<a href="https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#callback-and-plugin-management">https://github.com/panda-re/panda/blob/dev/panda/docs/manual.md#callback-and-plugin-management</a></p><p>使用回调来hook程序的执行并执行分析代码</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><hr><p>环境：Ubuntu20.04</p><h3 id="编译安装-采用"><a href="#编译安装-采用" class="headerlink" title="编译安装(采用)"></a>编译安装(采用)</h3><p><code>./install_ubuntu.sh</code></p><p><a href="https://github.com/panda-re/panda/blob/dev/panda/scripts/install_ubuntu.sh">panda/install_ubuntu.sh at dev · panda-re/panda</a></p><p><img src="/2022/03/26/Panda%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80/Untitled%202.png"></p><p>编译完成后，QEMU二进制文件位于build文件夹下；</p><p>还需要创建一个用于PANDA的Qcow（磁盘映像）</p><h3 id="PIP安装Python接口：PyPanda"><a href="#PIP安装Python接口：PyPanda" class="headerlink" title="PIP安装Python接口：PyPanda"></a>PIP安装Python接口：PyPanda</h3><p>安装一些依赖：</p><p><code>apt install libvdeplug-dev libpng16-16 libsdl2-2.0-0</code></p><p><code>pip3 install pandare</code></p><p>这将安装基于 python 的 PANDA 分析所需的一切，但不会安装独立的 PANDA 二进制文件。 这个包不会自动更新，所以它可能落后于 PANDA 的 master 分支。</p><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p><code>panda</code>容器：安装了 Panda 和 PyPANDA 以及它们的运行时依赖项的容器，但没有构建工件或源代码以减小容器的大小。</p><p><code>pandadev</code>容器：安装了 Panda和 PyPANDA 以及它们的运行时依赖项的容器，所有构建工件和源代码以及目录中此存储库的内容。（适合开发者）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull pandare/pandadev</span><br><span class="line">$ docker run --rm pandare/pandadev /panda/build/panda-system-i386 --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h1 id="记录Record和重放Replay"><a href="#记录Record和重放Replay" class="headerlink" title="记录Record和重放Replay"></a>记录Record和重放Replay</h1><hr><p>确定性记录和重放是一种用于捕获系统的 非确定性输入的技术（如果系统使用相同的输入从同一点重新启动，会导致系统行为不同的事物。）</p><ul><li>Panda记录的非确定性输入是对 CPU 状态和内存所做的更改——DMA、中断、in指令等等</li><li>Panda不记录设备的输入</li><li>想象在CPU与RAM外画个圈，记录从外部世界跨过这条线的东西</li></ul><h3 id="记录Record"><a href="#记录Record" class="headerlink" title="记录Record"></a>记录Record</h3><p>可以使用 QEMU 监视器中的 <code>begin_record</code> 和 <code>end_record</code> 命令来记录执行情况。</p><ul><li>begin_record <name><ul><li>开始录制会话，另存为<name>，会覆盖之前的记录</name></li><li>会生成两个文件：<ul><li>VM 快照<code>&lt;name&gt;-rr-snp</code></li><li>所有非确定性输入的日志<code>&lt;name&gt;-rr-nondet.log</code></li></ul></li></ul></name></li><li>end_record<ul><li>结束活动的录制会话，guest将被暂停，但可以恢复，并且一旦恢复guest，就可以进行另一次录制。</li></ul></li></ul><p>监视器，使用 <code>-monitor stdio</code> 运行 QEMU（也有更复杂的设置）。 输入 <code>begin_record &quot;replay_name&quot;</code> 开始录制过程，并使用 <code>end_record</code> 结束它。</p><h3 id="重放Replay"><a href="#重放Replay" class="headerlink" title="重放Replay"></a>重放Replay</h3><p>重放记录（replay recording）：可以使用 （这两个文件）<code>panda-system-$arch -replay replay_name</code>。确保将相同的内存大小传递给 VM，就像记录所做的那样。否则 QEMU 将失败并出现无法理解的错误。</p><p>仅仅运行重放本身并不是很有用，可以启用一些插件，对重放的执行进行分析。</p><h3 id="分享记录"><a href="#分享记录" class="headerlink" title="分享记录"></a>分享记录</h3><p>Pande支持打包和解压记录</p><ul><li>打包记录（这将捆绑<code>&lt;name&gt;-rr-snp</code>与<code>&lt;name&gt;-rr-nondet.log</code>放入 <code>&lt;name&gt;.rr</code>）：  <code>scripts/rrpack.py &lt;name&gt;</code></li><li>解压记录  <code>scripts/rrunpack.py &lt;name&gt;.rr</code></li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>捕获重放（Replay）后，可以多次播放它。通常首先使用标准分析来尝试了解正在发生的事情的基本情况，然后使用自定义插件（<code>panda_plugins</code>目录）来进行更具体的分析。</p><p>常用于开始分析的插件：<code>asidstory</code>、 <code>stringsearch</code>和 <code>file_taint</code></p>]]></content>
    
    
    <summary type="html">Panda（Platform for Architecture-Neutral Dynamic Analysis）是一个用于架构中性动态分析的开源平台。优势在于软件的快速逆向工程。</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="Panda-re" scheme="http://example.com/tags/Panda-re/"/>
    
  </entry>
  
  <entry>
    <title>Fuzzing101 Exercise 2 - libexif - CVE-2009-3895&amp;CVE-2012-2836</title>
    <link href="http://example.com/2022/01/10/Exercise%202/"/>
    <id>http://example.com/2022/01/10/Exercise%202/</id>
    <published>2022-01-10T13:00:00.000Z</published>
    <updated>2022-03-26T07:43:14.675Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%202">Fuzzing101/Exercise 2 at main · antonio-morales/Fuzzing101</a></p><ul><li>任务：在libexif中，找到两个crash  <strong><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895">CVE-2009-3895</a>&amp;****<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836">CVE-2012-2836</a></strong></li><li>版本：libexif 0.6.14</li><li><strong><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895">CVE-2009-3895</a>：</strong>一种基于堆的缓冲区溢出，可以用无效的 EXIF 图像触发。<ul><li>漏洞描述：基于堆的缓冲区溢出是一种发生在堆数据区的缓冲区溢出，它通常与显式动态内存管理（使用 malloc() 和 free() 函数进行分配/释放）有关。因此，远程攻击者可以利用此问题在使用受影响库的应用程序上下文中执行任意代码。</li></ul></li><li><strong><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836">CVE-2012-2836</a>：</strong>一个越界读取漏洞，可以通过带有精心制作的 EXIF 标签的图像触发。<ul><li>漏洞描述：越界读取是当程序读取数据超过预期缓冲区的末尾或开头之前发生的漏洞。因此，它允许远程攻击者导致拒绝服务或可能从进程内存中获取潜在的敏感信息。</li></ul></li><li>本地实验环境：<strong>虚拟机Ubuntu 20.04.3 LTS</strong><span id="more"></span></li></ul><hr><p>AFL使用非确定性测试算法，因此两个模糊会话永远不会相同。因此作者强烈建议设置一个固定的种子(-s 123)。这样模糊结果将类似于这些显示，更容易跟随练习。</p><p>作者建议使用<strong>Ubuntu 20.04.2 LTS</strong>，因为作者已在该环境下测试过，而且建议使用主机而不是虚拟机，以发挥AFL更好的性能</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><hr><ul><li>下载安装libexif-0.6.14</li></ul><p>新建目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line">mkdir fuzzing_libexif &amp;&amp; <span class="built_in">cd</span> fuzzing_libexif/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/libexif/libexif/archive/refs/tags/libexif-0_6_14-release.tar.gz</span><br><span class="line">tar -xzvf libexif-0_6_14-release.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> libexif-libexif-0_6_14-release/</span><br><span class="line">sudo apt-get install autopoint libtool gettext libpopt-dev</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>选择libexif调用接口—exif</li></ul><p>由于 libexif 是一个库，因此我们需要另一个使用该库的应用程序，并将对其进行模糊测试。对于此任务，我们将使用<strong>exif</strong> 命令行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif</span><br><span class="line">wget https://github.com/libexif/exif/archive/refs/tags/exif-0_6_15-release.tar.gz</span><br><span class="line">tar -xzvf exif-0_6_15-release.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> exif-exif-0_6_15-release/</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/install/&quot;</span> PKG_CONFIG_PATH=<span class="variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>测试是否安装成功：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/fuzzing_libexif/install/bin/exif</span><br></pre></td></tr></table></figure><p><img src="/2022/01/10/Exercise%202/Untitled.png" alt="Untitled"></p><ul><li>建立种子语料库（<strong>Seed corpus</strong>）</li></ul><p>我们需要获取一些 exif 样本。我们将使用以下 repo 中的示例图像：<a href="https://github.com/ianare/exif-samples">https</a> : <a href="https://github.com/ianare/exif-samples">//github.com/ianare/exif-samples</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif</span><br><span class="line">wget https://github.com/ianare/exif-samples/archive/refs/heads/master.zip</span><br><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure><p>之后，我们可以这样使用（举例）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/fuzzing_libexif/install/bin/exif <span class="variable">$HOME</span>/fuzzing_libexif/exif-samples-master/jpg/Canon_40D_photoshop_import.jpg</span><br></pre></td></tr></table></figure><ul><li><strong>Afl-clang-lto</strong></li></ul><p>使用<strong>afl-clang-lto</strong>作为编译器来构建 libexif</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -r <span class="variable">$HOME</span>/fuzzing_libexif/install</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif/libexif-libexif-0_6_14-release/</span><br><span class="line">make clean</span><br><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_libexif/exif-exif-0_6_15-release</span><br><span class="line">make clean</span><br><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_libexif/install/&quot;</span> PKG_CONFIG_PATH=<span class="variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>一般来说，<em>afl-clang-lto</em>是最好的选择，因为它是一种无碰撞的仪器（<strong>instrumentation</strong>），而且比<em>afl-clang-fast 更快</em>。</p><p>如果您不确定何时使用<em>afl-clang-lto</em>或<em>afl-clang-fast，</em>您可以查看从<a href="https://github.com/AFLplusplus/AFLplusplus#1-instrumenting-that-target">AFLplusplus</a>提取的下图来选择</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+--------------------------------+</span><br><span class="line">| clang/clang++ 11+ is available | --&gt; use LTO mode (afl-clang-lto/afl-clang-lto++)</span><br><span class="line">+--------------------------------+     see [instrumentation/README.lto.md](instrumentation/README.lto.md)</span><br><span class="line">    |</span><br><span class="line">    | <span class="keyword">if</span> not, or <span class="keyword">if</span> the target fails with LTO afl-clang-lto/++</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">+---------------------------------+</span><br><span class="line">| clang/clang++ 6.0+ is available | --&gt; use LLVM mode (afl-clang-fast/afl-clang-fast++)</span><br><span class="line">+---------------------------------+     see [instrumentation/README.llvm.md](instrumentation/README.llvm.md)</span><br><span class="line">    |</span><br><span class="line">    | <span class="keyword">if</span> not, or <span class="keyword">if</span> the target fails with LLVM afl-clang-fast/++</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"> +--------------------------------+</span><br><span class="line"> | gcc 5+ is available            | -&gt; use GCC_PLUGIN mode (afl-gcc-fast/afl-g++-fast)</span><br><span class="line"> +--------------------------------+    see [instrumentation/README.gcc_plugin.md](instrumentation/README.gcc_plugin.md) and</span><br><span class="line">                                       [instrumentation/README.instrument_list.md](instrumentation/README.instrument_list.md)</span><br><span class="line">    |</span><br><span class="line">    | <span class="keyword">if</span> not, or <span class="keyword">if</span> you <span class="keyword">do</span> not have a gcc with plugin support</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">   use GCC mode (afl-gcc/afl-g++) (or afl-clang/afl-clang++ <span class="keyword">for</span> clang)</span><br></pre></td></tr></table></figure><h1 id="开始模糊测试"><a href="#开始模糊测试" class="headerlink" title="开始模糊测试"></a>开始模糊测试</h1><hr><p>运行fuzz</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i <span class="variable">$HOME</span>/fuzzing_libexif/exif-samples-master/jpg/ -o <span class="variable">$HOME</span>/fuzzing_libexif/out/ -s 123 -- <span class="variable">$HOME</span>/fuzzing_libexif/install/bin/exif @@</span><br></pre></td></tr></table></figure><p>可以发现许多crash</p><p><img src="/2022/01/10/Exercise%202/Untitled%201.png" alt="Untitled"></p><h1 id="使用Eclipse-CDT调试"><a href="#使用Eclipse-CDT调试" class="headerlink" title="使用Eclipse-CDT调试"></a>使用Eclipse-CDT调试</h1><p>安装JAVA-SDK</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install default-jdk</span><br></pre></td></tr></table></figure><p>下载Eclipse：<a href="https://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/2021-12/R/eclipse-cpp-2021-12-R-linux-gtk-x86_64.tar.gz">https://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/2021-12/R/eclipse-cpp-2021-12-R-linux-gtk-x86_64.tar.gz</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzvf eclipse-cpp-2021-03-R-linux-gtk-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>完成这两步后，打开Eclipse — File — Import — C/C++ — “Existing code as makefile project”</p><p><img src="/2022/01/10/Exercise%202/Untitled%202.png" alt="Untitled"></p><p>之后选择Linux GCC 并选择exif源码文件夹</p><p><img src="/2022/01/10/Exercise%202/Untitled%203.png" alt="Untitled"></p><p>之后可以在项目资源管理器中看到exif文件夹。</p><p>现在要配置调试的参数。Run — Debug Configurations，选择我们的exif项目及exif二进制文件</p><p><img src="/2022/01/10/Exercise%202/Untitled%204.png" alt="Untitled"></p><p>之后要设置Arguments，我们找到刚才AFL产生的crash路径，选一条复制进去</p><p>【至于选择哪一条，这里确实不太明白】</p><p><img src="/2022/01/10/Exercise%202/Untitled%205.png" alt="Untitled"></p><p>点击Debug后，程序会停在main函数开头</p><p><img src="/2022/01/10/Exercise%202/Untitled%206.png" alt="Untitled"></p><p>Run — Resume 检测到分段错误时会自动停止运行</p><p><img src="/2022/01/10/Exercise%202/Untitled%207.png" alt="Untitled"></p><h1 id="实验总结与心得"><a href="#实验总结与心得" class="headerlink" title="实验总结与心得"></a>实验总结与心得</h1><hr><ol><li>每次fuzz，不管时间是多少，产生crash数量与类型都是不同的。</li><li>多个crash，可能指向的代码点是同一处。</li><li>作者指出的这两处CVE的溢出点，我在fuzz产生的crash调试时，都没有发现（即使第二次fuzz了3个小时，产生了30个crash，也没有发现）</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%202&quot;&gt;Fuzzing101/Exercise 2 at main · antonio-morales/Fuzzing101&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务：在libexif中，找到两个crash  &lt;strong&gt;&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895&quot;&gt;CVE-2009-3895&lt;/a&gt;&amp;amp;****&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836&quot;&gt;CVE-2012-2836&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;版本：libexif 0.6.14&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895&quot;&gt;CVE-2009-3895&lt;/a&gt;：&lt;/strong&gt;一种基于堆的缓冲区溢出，可以用无效的 EXIF 图像触发。&lt;ul&gt;
&lt;li&gt;漏洞描述：基于堆的缓冲区溢出是一种发生在堆数据区的缓冲区溢出，它通常与显式动态内存管理（使用 malloc() 和 free() 函数进行分配/释放）有关。因此，远程攻击者可以利用此问题在使用受影响库的应用程序上下文中执行任意代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836&quot;&gt;CVE-2012-2836&lt;/a&gt;：&lt;/strong&gt;一个越界读取漏洞，可以通过带有精心制作的 EXIF 标签的图像触发。&lt;ul&gt;
&lt;li&gt;漏洞描述：越界读取是当程序读取数据超过预期缓冲区的末尾或开头之前发生的漏洞。因此，它允许远程攻击者导致拒绝服务或可能从进程内存中获取潜在的敏感信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本地实验环境：&lt;strong&gt;虚拟机Ubuntu 20.04.3 LTS&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Fuzzing101 Exercise 1 - Xpdf - CVE-2019-13288</title>
    <link href="http://example.com/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/"/>
    <id>http://example.com/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/</id>
    <published>2021-11-29T13:00:00.000Z</published>
    <updated>2021-11-29T14:25:59.655Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201">Fuzzing101/Exercise 1 at main · antonio-morales/Fuzzing101</a></p><ul><li>任务：在Xpdf这一PDF阅读器中，找到一个crash  [<strong>CVE-2019-13288]</strong></li><li>版本：XPDF 3.02</li><li>CVE-2019-13288：是一个可能通过精心制作的文件导致无限递归的漏洞<ul><li>漏洞描述：由于程序中每个被调用的函数在堆栈上分配一个堆栈帧，如果一个函数被递归调用太多次，可能会导致堆栈内存耗尽和程序崩溃。因此，远程攻击者可以利用这一点进行DoS攻击。</li><li>详细信息：<a href="https://www.cvedetails.com/cve/CVE-2019-13288/">https://www.cvedetails.com/cve/CVE-2019-13288/</a></li></ul></li><li>本地实验环境：<strong>虚拟机Ubuntu 20.04.3 LTS</strong></li><li>关于非受控递归漏洞：<a href="https://cwe.mitre.org/data/definitions/674.html">https://cwe.mitre.org/data/definitions/674.html</a><span id="more"></span></li></ul><hr><p>AFL使用非确定性测试算法，因此两个模糊会话永远不会相同。因此作者强烈建议设置一个固定的种子(-s 123)。这样模糊结果将类似于这些显示，更容易跟随练习。</p><p>作者建议使用<strong>Ubuntu 20.04.2 LTS</strong>，因为作者已在该环境下测试过，而且建议使用主机而不是虚拟机，以发挥AFL更好的性能</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><hr><p>新建目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line">mkdir fuzzing_xpdf &amp;&amp; <span class="built_in">cd</span> fuzzing_xpdf/</span><br></pre></td></tr></table></figure><p>安装额外工具（即 make 和 gcc）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install build-essential</span><br></pre></td></tr></table></figure><p>下载XPDF 3.02</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gz</span><br><span class="line">tar -xvzf xpdf-3.02.tar.gz</span><br></pre></td></tr></table></figure><p>构建XPDF</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> xpdf-3.02</span><br><span class="line">sudo apt update &amp;&amp; sudo apt install -y build-essential gcc</span><br><span class="line">./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_xpdf/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>下载PDF示例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_xpdf</span><br><span class="line">mkdir pdf_examples &amp;&amp; <span class="built_in">cd</span> pdf_examples</span><br><span class="line">wget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdf</span><br><span class="line">wget http://www.africau.edu/images/default/sample.pdf</span><br><span class="line">wget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf</span><br></pre></td></tr></table></figure><p>使用以下命令测试pdfinfo二进制文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/fuzzing_xpdf/install/bin/pdfinfo -box -meta <span class="variable">$HOME</span>/fuzzing_xpdf/pdf_examples/helloworld.pdf</span><br></pre></td></tr></table></figure><p>得到：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled.png"></p><h1 id="安装AFL"><a href="#安装AFL" class="headerlink" title="安装AFL++"></a>安装AFL++</h1><hr><p>作者推荐本地安装（也可以使用Docker）</p><p>安装依赖：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools</span><br><span class="line">sudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang </span><br><span class="line">sudo apt-get install -y gcc-$(gcc --version|head -n1|sed <span class="string">&#x27;s/.* //&#x27;</span>|sed <span class="string">&#x27;s/\..*//&#x27;</span>)-plugin-dev libstdc++-$(gcc --version|head -n1|sed <span class="string">&#x27;s/.* //&#x27;</span>|sed <span class="string">&#x27;s/\..*//&#x27;</span>)-dev</span><br></pre></td></tr></table></figure><p>构建AFL++</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/AFLplusplus/AFLplusplus &amp;&amp; <span class="built_in">cd</span> AFLplusplus</span><br><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line">make distrib</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>安装成功：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%201.png"></p><p>为了我们的目标应用程序启用检测，我们需要使用 AFL 的编译器编译代码</p><p>首先，我们将清理所有以前编译的目标文件和可执行文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -r <span class="variable">$HOME</span>/fuzzing_xpdf/install</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_xpdf/xpdf-3.02/</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p>使用<strong>afl-clang-fast</strong>编译器构建 xpdf ：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LLVM_CONFIG=<span class="string">&quot;llvm-config-11&quot;</span></span><br><span class="line">CC=<span class="variable">$HOME</span>/AFLplusplus/afl-clang-fast CXX=<span class="variable">$HOME</span>/AFLplusplus/afl-clang-fast++ ./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_xpdf/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>之后可以使用以下命令来运行fuzz</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i <span class="variable">$HOME</span>/fuzzing_xpdf/pdf_examples/ -o <span class="variable">$HOME</span>/fuzzing_xpdf/out/ -s 123 -- <span class="variable">$HOME</span>/fuzzing_xpdf/install/bin/pdftotext @@ <span class="variable">$HOME</span>/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure><p>每个选项的简要说明：</p><ul><li>-<em>i</em>表示我们必须放置输入案例（文件示例）的目录</li><li>-<em>o</em>表示 AFL++ 将存储变异文件的目录</li><li>-<em>s</em>表示要使用的静态随机种子</li><li>*@@*是占位符目标的命令行，AFL 将用每个输入文件名替换它</li></ul><p>等待一段时间后，发现crash，之后可以直接<code>ctrl+c</code>结束fuzz。</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%202.png"></p><h1 id="分析crash"><a href="#分析crash" class="headerlink" title="分析crash"></a>分析crash</h1><hr><p>在<code>$HOME/fuzzing_xpdf/out/</code>目录中找到crash对应的文件：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%203.png"></p><p>将此文件作为输入传递给 pdftotext 二进制文件(如果系统报打不开文件，就改下文件名，例如test.pdf)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/fuzzing_xpdf/install/bin/pdftotext <span class="string">&#x27;$HOME/fuzzing_xpdf/out/default/crashes/&lt;your_filename&gt;&#x27;</span> <span class="variable">$HOME</span>/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure><p>这里注意两个坑，一是不能直接使用pdftotext XXX，结果是不一样的；二是要把命令中间的引号去掉才能运行，不知道这里作者用的引号是什么意思</p><p>最终输出：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%204.png"></p><p>开始使用GDB来查找产生crash的原因</p><p>首先，需要使用调试信息重建 Xpdf 以获得符号堆栈跟踪：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -r <span class="variable">$HOME</span>/fuzzing_xpdf/install</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_xpdf/xpdf-3.02/</span><br><span class="line">make clean</span><br><span class="line">CFLAGS=<span class="string">&quot;-g -O0&quot;</span> CXXFLAGS=<span class="string">&quot;-g -O0&quot;</span> ./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_xpdf/install/&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>运行GDB：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb --args <span class="variable">$HOME</span>/fuzzing_xpdf/install/bin/pdftotext <span class="variable">$HOME</span>/fuzzing_xpdf/out/default/crashes/&lt;your_filename&gt; <span class="variable">$HOME</span>/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%205.png"></p><p>输入<code>run</code>得到：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%206.png"></p><p>之后输入<code>bt</code> 查看调用栈</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%207.png"></p><p>发现程序一直在调用<code>Parser::getObj</code>这一函数，这也正匹配了<a href="https://www.cvedetails.com/cve/CVE-2019-13288/">https://www.cvedetails.com/cve/CVE-2019-13288/</a>中描述的该CVE漏洞信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">In Xpdf 4.01.01, the Parser::getObj() <span class="keyword">function</span> <span class="keyword">in</span> Parser.cc may cause infinite recursion via a crafted file. A remote attacker can leverage this <span class="keyword">for</span> a DoS attack. This is similar to CVE-2018-16646.</span><br><span class="line">Publish Date : 2019-07-04 Last Update Date : 2020-08-24</span><br><span class="line"></span><br><span class="line">在 Xpdf 4.01.01 中，Parser.cc 中的 Parser::getObj() 函数可能会通过精心制作的文件导致无限递归。远程攻击者可以利用它进行 DoS 攻击。这类似于 CVE-2018-16646。</span><br><span class="line">发布日期：2019-07-04 最后更新日期：2020-08-24</span><br></pre></td></tr></table></figure><h1 id="修复bug"><a href="#修复bug" class="headerlink" title="修复bug"></a>修复bug</h1><hr><p>这里我们可以下载已修复错误的 Xpdf 4.02，对比下代码：</p><p><img src="/2021/11/29/Fuzzing101%20Exercise%201%20-%20Xpdf%20-%20CVE-2019-13288/Untitled%208.png"></p><p>参考资料：</p><p><a href="https://chowdera.com/2021/09/20210912223059406n.html">https://chowdera.com/2021/09/20210912223059406n.html</a></p><p><a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201">https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise 1</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201&quot;&gt;Fuzzing101/Exercise 1 at main · antonio-morales/Fuzzing101&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务：在Xpdf这一PDF阅读器中，找到一个crash  [&lt;strong&gt;CVE-2019-13288]&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;版本：XPDF 3.02&lt;/li&gt;
&lt;li&gt;CVE-2019-13288：是一个可能通过精心制作的文件导致无限递归的漏洞&lt;ul&gt;
&lt;li&gt;漏洞描述：由于程序中每个被调用的函数在堆栈上分配一个堆栈帧，如果一个函数被递归调用太多次，可能会导致堆栈内存耗尽和程序崩溃。因此，远程攻击者可以利用这一点进行DoS攻击。&lt;/li&gt;
&lt;li&gt;详细信息：&lt;a href=&quot;https://www.cvedetails.com/cve/CVE-2019-13288/&quot;&gt;https://www.cvedetails.com/cve/CVE-2019-13288/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本地实验环境：&lt;strong&gt;虚拟机Ubuntu 20.04.3 LTS&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;关于非受控递归漏洞：&lt;a href=&quot;https://cwe.mitre.org/data/definitions/674.html&quot;&gt;https://cwe.mitre.org/data/definitions/674.html&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>IDA Python 常用API（持续更新）</title>
    <link href="http://example.com/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://example.com/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2021-11-17T13:21:00.000Z</published>
    <updated>2021-11-18T03:05:58.230Z</updated>
    
    <content type="html"><![CDATA[<p>环境：IDAPro 7.6</p><p>（注意IDAPro 7.4版本后，IDA Python的API版本与7.4之前的版本发生了很多变化，具体区别请看<a href="https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml">https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml</a>）</p><span id="more"></span><h2 id="常见模块"><a href="#常见模块" class="headerlink" title="常见模块"></a>常见模块</h2><p>在IDA中.有三个重要的库.分别是IDC,idautils,idaapi</p><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>IDC</td><td>封装IDA与IDC函数的兼容性模块.</td></tr><tr><td>idautils</td><td>高级实用的模块</td></tr><tr><td>idaapi</td><td>允许访问更加底层的数据</td></tr></tbody></table><h2 id="获取IDA界面地址"><a href="#获取IDA界面地址" class="headerlink" title="获取IDA界面地址"></a>获取IDA界面地址</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>取当前地址</td><td>idc.here() 或 idc.get_screen_ea()</td></tr><tr><td>获取最小地址（可以使用的）</td><td>ida_ida.inf_get_min_ea()</td></tr><tr><td>获取最大地址（可以使用的）</td><td>ida_ida.inf_get_max_ea()</td></tr><tr><td>获取所选范围的起始地址</td><td>idc.read_selection_start()</td></tr><tr><td>获取所选范围的结束地址</td><td>idc.read_selection_end()</td></tr><tr><td></td><td></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;当前地址：&#x27;</span>+<span class="built_in">hex</span>(idc.here()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;基址：&#x27;</span>+<span class="built_in">hex</span>(ida_ida.inf_get_min_ea())))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled.png"></p><h2 id="获取地址的数值"><a href="#获取地址的数值" class="headerlink" title="获取地址的数值"></a>获取地址的数值</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>以1字节为单位获取地址处的值</td><td>idc.get_wide_byte(addr)</td></tr><tr><td>以2字节(字)的单位获取</td><td>idc.get_wide_word(addr)</td></tr><tr><td>以4字节的单位获取</td><td>idc.get_wide_dword(addr)</td></tr><tr><td>以8字节的单位获取</td><td>idc.get_qword(addr)</td></tr><tr><td>判断是否是字节</td><td>ida_bytes.is_byte</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;当前地址：&#x27;</span>+<span class="built_in">hex</span>(idc.here()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;值&#x27;</span>+<span class="built_in">hex</span>(idc.get_wide_byte(idc.here())))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%201.png"></p><h2 id="修改指令数值"><a href="#修改指令数值" class="headerlink" title="修改指令数值"></a>修改指令数值</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>修改addr地址的值为value.每次修改1个字节</td><td>ida_bytes.patch_byte(addr,value)</td></tr><tr><td>每次修改2个字节</td><td>ida_bytes.patch_word(addr,value)</td></tr><tr><td>每次修改4个字节</td><td>ida_bytes.patch_Dword(addr,value)</td></tr><tr><td>每次修改8个字节</td><td>ida_bytes.patch_Qword(addr,value)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line">addr = idc.here()</span><br><span class="line">value_before = idc.get_wide_byte(addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改之前：&quot;</span>+ <span class="built_in">hex</span>(value_before))</span><br><span class="line"></span><br><span class="line">ida_bytes.patch_byte(addr,<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">value_after = idc.get_wide_byte(addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改之后：&quot;</span>+ <span class="built_in">hex</span>(value_after))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%202.png" alt="Untitled"></p><h2 id="汇编指令操作"><a href="#汇编指令操作" class="headerlink" title="汇编指令操作"></a>汇编指令操作</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取地址处的汇编语句</td><td>idc.GetDisasm(addr) 或 idc.generate_disasm_line(addr,flags)</td></tr><tr><td>获取指定地址位置的操作数.参数1是地址.参数2是操作数索引.如 mov ebp,esp中： 操作数1是ebp ，操作数2是esp mov则是汇编指令不是操作数</td><td>idc.print_operand(addr,index)</td></tr><tr><td>获取汇编操作指令（如mov、add）</td><td>idc.print_insn_mnem(addr)</td></tr><tr><td>获取操作数的类型</td><td>idc.get_operand_type(addr,index)</td></tr><tr><td>获取指定索引操作数中的值: 如 calll 0x00402004 对应汇编为: FF 15 04 20 40 00 FF15=Call 而操作数的值则为04 20 40 00 (小端) 使用函数之后获取则为地址 00402004</td><td>idc.get_operand_value(addr,index)</td></tr><tr><td>获取下一行汇编</td><td>idc.next_head(addr)</td></tr><tr><td>获取上一行汇编</td><td>idc.PrevHead(addr)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line">ea = idc.here();</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基址为: &quot;</span> + <span class="built_in">hex</span>(idaapi.get_imagebase()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前汇编: &quot;</span> + idc.GetDisasm(ea))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前汇编指令为: &quot;</span> + idc.print_insn_mnem(ea))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前操作数为: &quot;</span> + idc.print_operand(ea,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%203.png" alt="Untitled"></p><h2 id="段操作"><a href="#段操作" class="headerlink" title="段操作"></a>段操作</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取段的名字（参数为当前的地址）</td><td>idc.get_segm_name(addr)</td></tr><tr><td>获取段的开始地址</td><td>idc.get_segm_start(addr)</td></tr><tr><td>获取段的结束地址</td><td>idc.get_segm_end(addr)</td></tr><tr><td>获取第一个段</td><td>idc.get_first_seg(addr)</td></tr><tr><td>获取下一个段</td><td>idc.get_next_seg(addr)</td></tr><tr><td>返回一个列表记录所有段的地址</td><td>idautil.Segments()</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> seg_addr <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">    segname = idc.get_segm_name(seg_addr)</span><br><span class="line">    segstart = idc.get_segm_start(seg_addr)</span><br><span class="line">    segend   = idc.get_segm_end(seg_addr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;段名：&quot;</span> + segname + <span class="string">&quot;起始地址：&quot;</span> + <span class="built_in">hex</span>(segstart) + <span class="string">&quot;结束地址：&quot;</span> + <span class="built_in">hex</span>(segend));</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%204.png" alt="Untitled"></p><h2 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h2><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取指定地址之间的所有函数</td><td>idautils.Functions(startaddr,endaddr)</td></tr><tr><td>获取指定地址的函数名</td><td>idc.get_func_name(addr)</td></tr><tr><td>获取函数的注释</td><td>get_func_cmt(addr, repeatable)  repeatable:0/1    0是获取常规注释 1是获取重复注释</td></tr><tr><td>设置函数注释</td><td>idc.set_func_cmt(ea, cmt, repeatable)</td></tr><tr><td>弹出框框要求用户进行选择 参数则是信息</td><td>idc.choose_func(title)</td></tr><tr><td>返回: addr 距离函数的偏移形式</td><td>idc.get_func_off_str(addr)</td></tr><tr><td>寻找函数结尾,如果函数存在则返回结尾地址,否则返回BADADDR</td><td>idc.find_func_end(addr)</td></tr><tr><td>设置函数结尾</td><td>ida_funcs.set_func_end(ea, newend)      newend:新的结束地址</td></tr><tr><td>设置函数开头</td><td>ida_funcs.set_func_start(addr, newstart)</td></tr><tr><td>设置地址处的名字</td><td>idc.set_name(ea, name, SN_CHECK)                 Ex函数也使用set_name</td></tr><tr><td>获取首个函数</td><td>idc.get_prev_func(ea)</td></tr><tr><td>获取下一个函数</td><td>idc.get_next_func(ea)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">    segname = idc.get_segm_name(seg)</span><br><span class="line">    segstart = idc.get_segm_start(seg)</span><br><span class="line">    segend = idc.get_segm_end(seg)</span><br><span class="line">    <span class="keyword">if</span> (segname == <span class="string">&#x27;.text&#x27;</span>):</span><br><span class="line">        <span class="keyword">for</span> funcaddr <span class="keyword">in</span> Functions(segstart,segend):</span><br><span class="line">            funname = idc.get_func_name(funcaddr)</span><br><span class="line">            funend =  idc.find_func_end(funcaddr)</span><br><span class="line">            funnext = idc.get_next_func(funcaddr)</span><br><span class="line">            funnextname = idc.get_func_name(funnext)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;当前函数名: &quot;</span> + funname + <span class="string">&quot;当前结束地址: &quot;</span> + <span class="built_in">hex</span>(funend) +<span class="string">&quot;下一个函数地址: &quot;</span> + <span class="built_in">hex</span>(funnext) + <span class="string">&quot;下一个函数名: &quot;</span> + funnextname)</span><br><span class="line">ea = idc.get_screen_ea()</span><br><span class="line">funnextoffset = idc.get_func_off_str(ea)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前选择地址距离当前函数的偏移为: &quot;</span>+ funnextoffset)</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%205.png" alt="Untitled"></p><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p> 在IDAPython中如果我们想查询某些 数据 代码 二进制 都可以用都搜索函数。</p><p>搜索函数可以是向上搜索 也可以是向下搜索. 搜索失败就会返回-1 也就是BADADDR。</p><p>而搜索功能也常常用于去除花指令当中。</p><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>查找二进制找到返回地址没找到返回-1(BADADDR)</td><td>idc.find_binary(ea, flag, searchstr, radix=16, from_bc695=False)</td></tr><tr><td>从ea开始寻找下一个数据地址</td><td>ida_search.find_data(ea, sflag)</td></tr><tr><td>从ea开始寻找下一个代码地址</td><td>ida_search.find_code(ea, sflag)</td></tr><tr><td>跳转到ea位置</td><td>ida_kernwin.jumpto(ea)</td></tr><tr><td></td><td></td></tr></tbody></table><p>flags取值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SEARCH_DOWN 向下搜索</span><br><span class="line">SEARCH_UP 向上搜索</span><br><span class="line">SEARCH_NEXT 获取下一个找到的对象。</span><br><span class="line">SEARCH_CASE 指定大小写敏感度</span><br><span class="line">SEARCH_UNICODE 搜索 Unicode 字符串。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line">addr = idc.here()</span><br><span class="line">value = idc.find_binary(ea,SEARCH_DOWN,<span class="string">&#x27;C4 00 C4&#x27;</span>)</span><br><span class="line">value1 = idc.find_code(ea,SEARCH_DOWN)</span><br><span class="line">value2 = idc.find_data(ea,SEARCH_DOWN)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前位置：&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;C4 00 C4 所在位置：&quot;</span>+<span class="built_in">hex</span>(value))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下一处代码位置：&quot;</span>+<span class="built_in">hex</span>(value1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下一处数据位置：&quot;</span>+<span class="built_in">hex</span>(value2))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%206.png" alt="Untitled"></p><h2 id="数据校验函数"><a href="#数据校验函数" class="headerlink" title="数据校验函数"></a>数据校验函数</h2><p>数据校验函数有一个参数flag，得到flag后可以直接进行校验</p><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取标志</td><td>ida_bytes.get_full_flags(ea)</td></tr><tr><td>判断是否为代码</td><td>ida_bytes.is_code(f)                                                                     f即标志</td></tr><tr><td>判断是否为数据</td><td>ida_bytes.is_data(f)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line">addr = idc.here()</span><br><span class="line">value = idc.find_binary(ea,SEARCH_DOWN,<span class="string">&#x27;C4 00 C4&#x27;</span>)</span><br><span class="line">value1 = idc.find_code(ea,SEARCH_DOWN)</span><br><span class="line">value2 = idc.find_data(ea,SEARCH_DOWN)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前位置：&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;C4 00 C4 所在位置：&quot;</span>+<span class="built_in">hex</span>(value))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下一处代码位置：&quot;</span>+<span class="built_in">hex</span>(value1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下一处数据位置：&quot;</span>+<span class="built_in">hex</span>(value2))</span><br><span class="line">flag1 = ida_bytes.get_full_flags(value1)</span><br><span class="line">flag2 = ida_bytes.get_full_flags(value2)</span><br><span class="line"><span class="comment">#print(flag)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">hex</span>(value1)) +<span class="string">&quot;处是不是代码？：&quot;</span>  + <span class="built_in">str</span>(ida_bytes.is_code(flag1)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="built_in">hex</span>(value2)) +<span class="string">&quot;处是不是代码？：&quot;</span>  + <span class="built_in">str</span>(ida_bytes.is_code(flag2)))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%207.png" alt="Untitled"></p><h2 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h2><p>在IDA的操作中 我们常常会对一个函数按X快捷键来查看谁引用了</p><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>获取地址处引用位置 A调用B 对B函数地址使用此函数则找到A调用 返回列表.遍历列表则可以找出所有引用位置. 参数1是ea也就是地址,参数2告诉IDA是否跟踪这些代码.</td><td>idautils.CodeRefsTo(ea, flow)</td></tr><tr><td>返回ea的代码引用了何处的代码. 返回一个列表</td><td>idautils.CodeRefsFrom(ea, flow)</td></tr><tr><td>返回一个列表告诉ea位置的数据被谁引用了</td><td>idautils.DataRefsTo(ea)</td></tr><tr><td>告诉我们ea引用了谁.</td><td>idautils.DataRefsFrom(ea)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line">addr = idc.here()   </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> CodeRefsTo(addr,<span class="literal">False</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前汇编: &quot;</span> + idc.GetDisasm(i))</span><br></pre></td></tr></table></figure><p><img src="/2021/11/17/IDA%20Python%20%E5%B8%B8%E7%94%A8API%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/Untitled%208.png" alt="Untitled"></p><p>除了上述通过地址来查找引用的方式外，还可以通过函数名来进行查找交叉引用：</p><p>1、先通过<code>idc.get_name_ea_simple(fun_name)</code>找到函数的线性地址</p><p>2、再使用<code>for i in CodeRefsTo(addr,False)</code>得到所有引用的地址</p><p>一个例子：<a href="https://hotspurzzz.github.io/2021/11/12/IDA-Python%20%E6%89%B9%E9%87%8F%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/">https://hotspurzzz.github.io/2021/11/12/IDA-Python 批量脚本分析程序/</a></p><p>官网API文档：</p><p><a href="https://www.hex-rays.com/wp-content/static/products/ida/support/idapython_docs/">https://www.hex-rays.com/wp-content/static/products/ida/support/idapython_docs/</a></p><p>参考链接：</p><p><a href="https://www.cnblogs.com/iBinary/p/14642662.html">https://www.cnblogs.com/iBinary/p/14642662.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;环境：IDAPro 7.6&lt;/p&gt;
&lt;p&gt;（注意IDAPro 7.4版本后，IDA Python的API版本与7.4之前的版本发生了很多变化，具体区别请看&lt;a href=&quot;https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml&quot;&gt;https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml&lt;/a&gt;）&lt;/p&gt;</summary>
    
    
    
    <category term="IDA" scheme="http://example.com/categories/IDA/"/>
    
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
    <category term="IDA Python" scheme="http://example.com/tags/IDA-Python/"/>
    
  </entry>
  
  <entry>
    <title>IDA-Python 批量脚本分析程序</title>
    <link href="http://example.com/2021/11/12/IDA-Python%20%E6%89%B9%E9%87%8F%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2021/11/12/IDA-Python%20%E6%89%B9%E9%87%8F%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-11-12T08:00:00.000Z</published>
    <updated>2021-11-12T10:51:58.777Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，IDA Python对于分析二进制程序来说是一个非常好用的工具。<br>当面对大量的二进制文件需要分析时，可以实现自动化批量处理。<br>环境：IDA Pro7.5    Python3.7</p><span id="more"></span><p>这里准备两个python文件</p><h3 id="analysis-py"><a href="#analysis-py" class="headerlink" title="analysis.py"></a>analysis.py</h3><p>实现对二进制程序的具体分析</p><p>Demo:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> ida_auto</span><br><span class="line"><span class="keyword">import</span> ida_pro</span><br><span class="line"><span class="keyword">import</span> ida_nalt</span><br><span class="line"><span class="keyword">import</span> ida_ida</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis</span>():</span></span><br><span class="line">    <span class="comment">#Do Some Things</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    ida_auto.auto_wait()</span><br><span class="line">    analysis()</span><br><span class="line">    ida_pro.qexit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="run-py"><a href="#run-py" class="headerlink" title="run.py"></a>run.py</h3><p>Demo:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">dir_path = <span class="string">&quot;path_to_binfile&quot;</span></span><br><span class="line">ida64_path = <span class="string">&quot;path_to_ida&quot;</span></span><br><span class="line">analysis_file = <span class="string">&quot;path_to_analysis.py&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(dir_path):</span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> files:</span><br><span class="line">            file_path = os.path.join(root, file_name)</span><br><span class="line">            cmd = <span class="string">&quot;&#123;0&#125; -LD:/mylog.log -c -A -S&#123;1&#125; &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(ida64_path, ana_file, file_path)</span><br><span class="line">            p = subprocess.Popen(cmd)</span><br><span class="line">            p.wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>dir_path</code> 指需要进行分析的二进制文件的目录</p><p><code>ida64_path</code>指向本地IDA程序</p><p><code>analysis_file</code>指向前面的analysis.py</p><h3 id="小示例"><a href="#小示例" class="headerlink" title="小示例"></a>小示例</h3><p>这里需要来分析多个二进制文件中某个函数的调用地址(相对地址）：</p><p>analysis.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> ida_auto</span><br><span class="line"><span class="keyword">import</span> ida_pro</span><br><span class="line"><span class="keyword">import</span> ida_nalt</span><br><span class="line"><span class="keyword">import</span> ida_ida</span><br><span class="line"></span><br><span class="line">outfile = <span class="built_in">open</span>(<span class="string">&quot;result.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis</span>():</span></span><br><span class="line">    addr_base = ida_ida.inf_get_min_ea()</span><br><span class="line">    danger_funcs = [<span class="string">&quot;system&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> danger_funcs:</span><br><span class="line">        addr = idc.get_name_ea_simple(func)</span><br><span class="line">        filename = ida_nalt.get_root_filename()</span><br><span class="line">        <span class="keyword">if</span> addr != BADADDR:</span><br><span class="line">            cross_refs = CodeRefsTo( addr, <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">for</span> ref <span class="keyword">in</span> cross_refs:</span><br><span class="line">                ref = ref - addr_base</span><br><span class="line">                outfile.write(filename + <span class="string">&quot;-&quot;</span> + <span class="string">&quot;%s&quot;</span> % func + <span class="string">&quot;-0x&quot;</span> + <span class="string">&quot;%08x&quot;</span> % ref + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    ida_auto.auto_wait()</span><br><span class="line">    analysis()</span><br><span class="line">    ida_pro.qexit(<span class="number">0</span>)</span><br><span class="line">    outfile.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p> run.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">dir_path = <span class="string">&quot;C://Users/Desktop/bin_file&quot;</span></span><br><span class="line">ida64_path = <span class="string">&quot;E://IDA_Pro_v7.5_Portable/ida.exe&quot;</span></span><br><span class="line">analysis_file = <span class="string">&quot;C://Users/Desktop/analysis.py&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(dir_path):</span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> files:</span><br><span class="line">            <span class="built_in">print</span>(file_name)</span><br><span class="line">            file_path = os.path.join(root, file_name)</span><br><span class="line">            cmd = <span class="string">&quot;&#123;0&#125; -LD:/mylog.log -c -A -S&#123;1&#125; &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(ida64_path, ana_file, file_path)</span><br><span class="line">            p = subprocess.Popen(cmd)</span><br><span class="line">            p.wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>只需python3 run.py即可</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>IDA python中的API在7.4版本后产生了变化，如果本地使用的IDA Pro版本≥7.4，之前在网上搜的API可能就无法使用，旧版本与新版本相对应的API变化在这可以查询：</p><p><a href="https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml">https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知，IDA Python对于分析二进制程序来说是一个非常好用的工具。&lt;br&gt;当面对大量的二进制文件需要分析时，可以实现自动化批量处理。&lt;br&gt;环境：IDA Pro7.5    Python3.7&lt;/p&gt;</summary>
    
    
    
    <category term="IDA" scheme="http://example.com/categories/IDA/"/>
    
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
    <category term="IDA Python" scheme="http://example.com/tags/IDA-Python/"/>
    
  </entry>
  
  <entry>
    <title>shellphish-fuzzer环境搭建</title>
    <link href="http://example.com/2021/11/09/shellphish-fuzzer%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2021/11/09/shellphish-fuzzer%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-11-09T08:00:00.000Z</published>
    <updated>2022-03-26T07:49:08.689Z</updated>
    
    <content type="html"><![CDATA[<p>搭建shellphish-fuzzer环境，用于python调用AFL<br>环境：Docker—ubuntu18.04<br>python版本：3.6.9</p><span id="more"></span><p>注：由于个人网络问题，github源使用的<code>https://github.com.cnpmjs.org</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; \</span><br><span class="line">    apt-get upgrade -y &amp;&amp; \</span><br><span class="line">    apt-get autoremove -y &amp;&amp; \</span><br><span class="line">    apt-get install -y \</span><br><span class="line">        curl \</span><br><span class="line">        gdb \</span><br><span class="line">        wget \</span><br><span class="line">        git \</span><br><span class="line">        vim</span><br></pre></td></tr></table></figure><p>换源：</p><p><code>vim /etc/apt/sources.list</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>shellphish-fuzzer的安装：</p><p><code>apt-get install build-essential gcc-multilib libtool automake autoconf bison debootstrap debian-archive-keyring libtool-bin</code></p><p><code>apt-get build-dep qemu</code></p><p>由于没有pip，先安装pip3：</p><p><code>apt-get install python3-pip</code></p><p>安装angr</p><p><code>pip3 install angr</code></p><p>安装driller</p><p><code>pip3 install git+https://github.com.cnpmjs.org/angr/tracer</code></p><p><code>pip3 install git+https://github.com.cnpmjs.org/shellphish/driller</code></p><p>安装afl（可选）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir afl-latest</span><br><span class="line"><span class="built_in">cd</span> afl-latest</span><br><span class="line">wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz</span><br><span class="line">tar xf afl-latest.tgz</span><br><span class="line"><span class="built_in">cd</span> afl-2.52b</span><br><span class="line">make</span><br><span class="line"><span class="built_in">cd</span> qemu_mode</span><br><span class="line">wget -O patches/memfd.diff https://salsa.debian.org/qemu-team/qemu/raw/ubuntu-bionic-2.11/debian/patches/ubuntu/lp1753826-memfd-fix-configure-test.patch</span><br><span class="line">sed -i <span class="string">&#x27;/syscall.diff/a patch -p1 &lt;../patches/memfd.diff || exit 1&#x27;</span> build_qemu_support.sh</span><br><span class="line">./build_qemu_support.sh</span><br></pre></td></tr></table></figure><p>安装shellphish-afl</p><p><code>pip3 install git+https://github.com.cnpmjs.org/shellphish/shellphish-afl</code></p><p>但我使用这种方法会报错</p><p>于是我选择clone下来，执行setup.py</p><p><code>git clone[https://github.com.cnpmjs.org/shellphish/shellphish-afl.git](https://github.com.cnpmjs.org/shellphish/shellphish-afl.git)</code></p><p><code>cd shellphish-afl/</code></p><p><code>python3 [setup.py](http://setup.py/) install</code></p><p>安装fuzzer</p><p><code>pip3 install git+https://github.com.cnpmjs.org/shellphish/fuzzer</code></p><p>测试：</p><p><code>shellphuzz --help</code></p><p><img src="/2021/11/09/shellphish-fuzzer%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Untitled.png"></p><p><img src="/2021/11/09/shellphish-fuzzer%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Untitled%201.png"></p><p>参考链接：</p><p><a href="https://github.com/shellphish/fuzzer">https://github.com/shellphish/fuzzer</a></p><p><a href="https://github.com/shellphish/shellphish-afl">https://github.com/shellphish/shellphish-afl</a></p><p><a href="https://blog.grimm-co.com/2020/05/guided-fuzzing-with-driller.html">https://blog.grimm-co.com/2020/05/guided-fuzzing-with-driller.html</a></p><p>附Dockerfile：</p><p><a href="Dockerfile.txt">Dockerfile</a></p>]]></content>
    
    
    <summary type="html">搭建shellphish-fuzzer环境，用于python调用AFL</summary>
    
    
    
    <category term="Fuzz" scheme="http://example.com/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="http://example.com/tags/Fuzz/"/>
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
    <category term="AEG" scheme="http://example.com/tags/AEG/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell反混淆学习</title>
    <link href="http://example.com/2021/11/01/PowerShell%E5%8F%8D%E6%B7%B7%E6%B7%86/"/>
    <id>http://example.com/2021/11/01/PowerShell%E5%8F%8D%E6%B7%B7%E6%B7%86/</id>
    <published>2021-11-01T08:01:18.000Z</published>
    <updated>2021-11-09T08:50:10.007Z</updated>
    
    <content type="html"><![CDATA[<p>PowerShell功能十分强大，其有很多优点：例如易于导入模块，能够访问核心API和远程命令，也正是由于这些优点使其成为攻击者执行无文件攻击的首选工具之一。</p><span id="more"></span><h1 id="常见混淆方式"><a href="#常见混淆方式" class="headerlink" title="常见混淆方式"></a>常见混淆方式</h1><p>例如：变换大小写、字符串分割、将变量插入命令语句中（最常见的是-f格式转换）、变量中增加反引号“`”、字符串之间添加空格、字符转换ASCII码、利用replace函数替换、base64加密等等……</p><p>如图所示：</p><p><img src="/2021/11/01/PowerShell%E5%8F%8D%E6%B7%B7%E6%B7%86/Untitled.png"></p><h2 id="人工去混淆"><a href="#人工去混淆" class="headerlink" title="人工去混淆"></a>人工去混淆</h2><p>先通过几个例子来了解PowerShell样本例子来了解去混淆的方式</p><h3 id="iex"><a href="#iex" class="headerlink" title="iex"></a>iex</h3><p>例如：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.( <span class="variable">$SHEllID</span>[<span class="number">1</span>]+<span class="variable">$shEllid</span>[<span class="number">13</span>]+<span class="string">&#x27;x&#x27;</span>) (( <span class="string">&#x27;118&amp;105N64J100J25V19J4&amp;5&amp;26~25f3&amp;25N64G64C100~4f5_30C15Z25~64~67f9G56Z47C43N62V47f46V106Z37~36V112~106&amp;67&amp;114V101_120V120~101N120C122&amp;123_126V64V67&amp;9N56Z47_43~62_47C46C106C40J51G112&amp;106&amp;67~11N46G43V39V106C8C47Z56J62_56J43N39Z64J67C12_35f38f47G36G43C39Z47f112N67&amp;67&amp;64C67N9f56N47~46G35~62G57N112~67N67J64C67Z24&amp;47N59G63C35C56V47J39J47J36Z62f57_112G67N64J67J30G37N46_37V57~112_67&amp;67~67Z67f64C100J15f18f11V7Z26&amp;6V15&amp;64V67~64C100~15~18N11G7C26_6_15&amp;64&amp;67Z64&amp;100V26_11f24G11C7~15f30N15f24C106&amp;26~11G24~11V7G123G64_106_67f64N100V26&amp;11Z24C11&amp;7V15Z30_15N24&amp;106&amp;26~11V24J11J7_120&amp;64&amp;67_64f105Z116J64~17N9f39~46V38C47&amp;62C8Z35~36G46C35Z36&amp;45f98C14f47f44~43C63~38N62~26C43_56~43G39G47G62G47N56V25&amp;47C62V4_43&amp;39_47J106f119G106Z109G36~43J39~47~109C99J23Z64_17_5_63V62_58G63Z62~30_51Z58J47&amp;98_109V25G51C57Z62V47G39V100N7N43&amp;36Z43f45G47J39Z47G36N62V100N11&amp;63&amp;62V37G39f43C62Z35&amp;37~36V100f26N25f9C63C57J62C37f39N5V40f32&amp;47N41&amp;62J109~99G23_64&amp;58N43f56C43G39f106J98G64G67V17G26_43&amp;56&amp;43N39Z47~62C47C56N98f26Z43V56&amp;43C39Z47f62J47&amp;56Z25J47~62C4f43&amp;39&amp;47~106C119_106Z109&amp;36&amp;43f39N47~109f102V64G67~67Z7_43N36N46_43~62J37J56V51Z102_64G67V67G28~43C38f63N47V12_56V37&amp;39V26f35_58Z47V38N35~36J47_102Z64N67J67&amp;28Z43&amp;38V63Z47_12V56~37J39G26G35J58~47G38N35N36G47&amp;8G51C26J56~37~58N47&amp;56_62J51&amp;4J43&amp;39N47J99J23N64&amp;67&amp;17C28_43C38V35J46C43N62V47&amp;25_47_62f98J104G30C37_39&amp;104J102V104J14G35G41J33V104Z102f104~0N43Z36f47~104_99_23C64Z67Z17J28~43N38f35G46G43G62f47_24_43N36J45G47Z98J120f123V102~124C127N99_23~64Z67_17N28f43_38f35J46C43&amp;62C47~25&amp;41G56_35N58&amp;62Z98G49G30&amp;47J57J62N103N26&amp;43~62f34C106&amp;110C21C106Z103Z26_43Z62N34J30_51N58Z47G106Z109N9C37~36&amp;62&amp;43_35_36J47&amp;56f109_55V99&amp;23_106~64Z67J17C28V43_38_35J46G43f62_47J4Z37J62V4V63G38Z38C5C56&amp;15N39G58_62C51V98Z99_23f64V67_17~28Z43f38C35C46f43G62_47~9V37_63G36J62J98_123Z102~127_99C23V64f67V17J28V43C38G35G46V43N62G47J6Z47V36V45~62N34C98V123V102f123Z122&amp;99G23N64G67&amp;17J28_43Z38Z35~46&amp;43V62V47V26N43~62C62G47N56N36&amp;98Z99&amp;23C64V67C17f57f62f56G35J36_45V23C110C9N37_39C58V63C62~47C56G36C43Z39f47f106V119_106V109V14N15C12~11&amp;31&amp;6J30_28C11C6C31V15_109V64_99_64&amp;64C40N47J45f35_36Z106_49_64_67V110&amp;15f56N56~37_56f11C41&amp;62C35J37C36V26C56_47V44f47J56N47N36V41V47J106f119Z106~17_25f51J57J62G47J39V100~7G43J36Z43C45C47J39&amp;47~36C62~100_11V63N62G37C39~43C62Z35&amp;37f36J100N11~41C62Z35f37&amp;36G26J56&amp;47G44~47f56C47~36f41V47G23Z112~112N25C62Z37N58V64f67V25Z47f62J103C25N62J56G35_41J62G7Z37J46J47f106J103Z28f47J56_57_35C37V36C106G6C43&amp;62_47f57N62G64J67_62V56G51J106N49V64&amp;67G67V64Z67_55f106J41V43C62C41~34J106&amp;49C64~67~67J29~56G35C62_47&amp;103&amp;15V56G56G37V56f106C110G21_100&amp;15N50G41~47f58V62_35V37C36C100V7Z47V57f57Z43C45_47&amp;64G67G55G64G55f64f64Z58G56J37G41&amp;47N57f57G106f49~64~67f62_56Z51Z106J49J64_67G67C64N67V55~106_41N43J62~41V34Z106_49G64&amp;67_67N29Z56&amp;35&amp;62&amp;47C103V15_56f56Z37C56C106f110C21&amp;100f15_50Z41~47C58N62C35&amp;37C36_100V7&amp;47G57N57_43&amp;45G47N67f64N67V55J64Z106G106_106C106_64C55f64~64~47G36J46C106N49Z64Z67_62J56C51C106&amp;49G64_67Z67Z64V67~55C106Z41C43f62C41J34f106Z49Z64Z67f67J29C56J35Z62~47&amp;103N15N56_56&amp;37N56&amp;106&amp;110V21_100f15Z50V41N47Z58_62V35~37~36J100Z7J47J57J57N43f45C47~64G67G55V64Z55J64&#x27;</span><span class="operator">-Split</span><span class="string">&#x27;&amp;&#x27;</span><span class="operator">-spLIt</span><span class="string">&#x27;~&#x27;</span> <span class="operator">-SpliT</span> <span class="string">&#x27;_&#x27;</span><span class="operator">-spLIt</span> <span class="string">&#x27;v&#x27;</span><span class="operator">-SpLIt</span><span class="string">&#x27;z&#x27;</span> <span class="operator">-sPLiT</span> <span class="string">&#x27;C&#x27;</span> <span class="operator">-spLit</span><span class="string">&#x27;n&#x27;</span><span class="operator">-spLit</span> <span class="string">&#x27;J&#x27;</span> <span class="operator">-SPLIT</span><span class="string">&#x27;f&#x27;</span><span class="operator">-spLIt</span> <span class="string">&#x27;g&#x27;</span>| <span class="keyword">FoREacH</span> &#123;[<span class="built_in">chAR</span>] (<span class="variable">$_</span> <span class="operator">-bXor</span><span class="string">&quot;0x4a&quot;</span>) &#125;) <span class="operator">-joIN</span><span class="string">&#x27;&#x27;</span> </span><br></pre></td></tr></table></figure><p>中间都是被混淆了的代码，前后各有一小段代码。</p><p>后面的代码大致是进行了分割与异或操作，</p><p>前面的是<code>$SHEllID[1]+$shEllid[13]+&#39;x&#39;</code>，这里的$是PowerShell的操作符，可以将字符串作为命令执行，那么<code>$SHEllID</code>是什么呢，可以在PowerShell中查看：</p><p><img src="/2021/11/01/PowerShell%E5%8F%8D%E6%B7%B7%E6%B7%86/Untitled%201.png"></p><p>也就是说，通过从<code>$SHEllID</code>这一系统变量中，提取到了i和e这两个字符，以这种混淆的方式拼接出了iex字符。</p><p><img src="/2021/11/01/PowerShell%E5%8F%8D%E6%B7%B7%E6%B7%86/Untitled%202.png"></p><p>iex全称为Invoke-Expression，PowerShell文档中对其的解释为：</p><p><img src="/2021/11/01/PowerShell%E5%8F%8D%E6%B7%B7%E6%B7%86/Untitled%203.png"></p><p>即iex用于将后面的字符串作为命令来执行；如果去掉iex，运行后就会得到原来的字符串。</p><p>如果用户没有对样本进行分析，而直接运行经过iex混淆后的恶意的指令，那么就会给用户带来麻烦，正因如此，我们需要对样本进行解混淆来得到明文代码。</p><p>于是我们可以将iex去掉，即这里的<code>.( $SHEllID[1]+$shEllid[13]+&#39;x&#39;)</code></p><p>并通过<code>./test.ps1 &gt; test_1.ps1</code>命令来运行去除iex后的脚本，从而得到明文：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;#</span></span><br><span class="line"><span class="comment"><span class="doctag">.SYNOPSIS</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">.NOTES</span></span></span><br><span class="line"><span class="comment">Created on: 8/22/2014</span></span><br><span class="line"><span class="comment">Created by: Adam Bertram</span></span><br><span class="line"><span class="comment">Filename:</span></span><br><span class="line"><span class="comment">Credits:</span></span><br><span class="line"><span class="comment">Requirements:</span></span><br><span class="line"><span class="comment">Todos:</span></span><br><span class="line"><span class="comment"><span class="doctag">.EXAMPLE</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">.EXAMPLE</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">.PARAMETER PARAM1</span></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"><span class="doctag">.PARAMETER PARAM2</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line">[<span class="type">CmdletBinding</span>(<span class="type">DefaultParameterSetName</span> = <span class="string">&#x27;name&#x27;</span>)]</span><br><span class="line"><span class="function">[<span class="type">OutputType</span>(<span class="string">&#x27;System.Management.Automation.PSCustomObject&#x27;</span>)]</span></span><br><span class="line"><span class="keyword">param</span> (</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">ParameterSetName</span> = <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line"><span class="type">Mandatory</span>,</span><br><span class="line"><span class="type">ValueFromPipeline</span>,</span><br><span class="line"><span class="type">ValueFromPipelineByPropertyName</span>)]</span><br><span class="line">[<span class="type">ValidateSet</span>(<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Dick&quot;</span>,<span class="string">&quot;Jane&quot;</span>)]</span><br><span class="line">[<span class="type">ValidateRange</span>(<span class="number">21</span>,<span class="number">65</span>)]</span><br><span class="line">[<span class="type">ValidateScript</span>(&#123;<span class="built_in">Test-Path</span> <span class="variable">$_</span> -<span class="type">PathType</span> <span class="string">&#x27;Container&#x27;</span>&#125;)] </span><br><span class="line">[<span class="type">ValidateNotNullOrEmpty</span>()]</span><br><span class="line">[<span class="type">ValidateCount</span>(<span class="number">1</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="type">ValidateLength</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line">[<span class="type">ValidatePattern</span>()]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$Computername</span> = <span class="string">&#x27;DEFAULTVALUE&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span> &#123;</span><br><span class="line"><span class="variable">$ErrorActionPreference</span> = [<span class="type">System.Management.Automation.ActionPreference</span>]::Stop</span><br><span class="line"><span class="built_in">Set-StrictMode</span> <span class="literal">-Version</span> Latest</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">Write-Error</span> <span class="variable">$_</span>.Exception.Message</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">process</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">Write-Error</span> <span class="variable">$_</span>.Exception.Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">Write-Error</span> <span class="variable">$_</span>.Exception.Message</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后打开test_1.ps1就能清晰地看到代码做了什么</p><p>iex存在许多种表达方式，一些常见的：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">IEX</span></span><br><span class="line"><span class="built_in">InVOKe-EXprESSiON</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">GV</span> <span class="string">&#x27;*MdR*&#x27;</span>).nAme[<span class="number">3</span>,<span class="number">11</span>,<span class="number">2</span>]<span class="operator">-Join</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">(vAriaBLe <span class="string">&#x27;*mdr*&#x27;</span>).naME[<span class="number">3</span>,<span class="number">11</span>,<span class="number">2</span>]<span class="operator">-JoIn</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">(<span class="built_in">geT-vAriaBLe</span> <span class="string">&#x27;*MdR*&#x27;</span>).NAmE[<span class="number">3</span>,<span class="number">11</span>,<span class="number">2</span>]<span class="operator">-JOIN</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$VERBOsEPREference</span>.TOstrING()[<span class="number">1</span>,<span class="number">3</span>]+<span class="string">&#x27;x&#x27;</span><span class="operator">-JOiN</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">([<span class="built_in">STRIng</span>]<span class="variable">$veRbOsePrEfErENCe</span>)[<span class="number">1</span>,<span class="number">3</span>]+<span class="string">&#x27;X&#x27;</span><span class="operator">-joIn</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$env:COMspEC</span>[<span class="number">4</span>,<span class="number">15</span>,<span class="number">25</span>]<span class="operator">-jOin</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="variable">$eNv:COmsPEc</span>[<span class="number">4</span>,<span class="number">24</span>,<span class="number">25</span>]<span class="operator">-joiN</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="variable">$eNv:COMSPeC</span>[<span class="number">4</span>,<span class="number">26</span>,<span class="number">25</span>]<span class="operator">-jOIN</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$SHEllID</span>[<span class="number">1</span>]+<span class="variable">$shEllid</span>[<span class="number">13</span>]+<span class="string">&#x27;x&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$psHoME</span>[<span class="number">4</span>]+<span class="variable">$PShOmE</span>[<span class="number">30</span>]+<span class="string">&#x27;x&#x27;</span></span><br><span class="line"><span class="variable">$psHoME</span>[<span class="number">4</span>]+<span class="variable">$PsHOmE</span>[<span class="number">34</span>]+<span class="string">&#x27;X&#x27;</span></span><br><span class="line"><span class="variable">$psHomE</span>[<span class="number">21</span>]+<span class="variable">$pshOME</span>[<span class="number">30</span>]+<span class="string">&#x27;X&#x27;</span></span><br><span class="line"><span class="variable">$PSHoMe</span>[<span class="number">21</span>]+<span class="variable">$PsHOme</span>[<span class="number">34</span>]+<span class="string">&#x27;X&#x27;</span></span><br></pre></td></tr></table></figure><p>注意，默认情况下，Windows PowerShell本身不区分大小写。因此这里iex的表示方法，大小写是随意的。</p><p>当然，我们也能发现，iex通常与一些运算符、操作符结合在一起使用，例如test.ps1中最开始的<code>.</code>运算符。</p><p>常见的与iex结合的运算符、操作符如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、属性引用运算符（点运算符）: .</span><br><span class="line">作用：通过点运算符访问对象的属性和方法</span><br><span class="line">例如：</span><br><span class="line">.( <span class="variable">$SHEllID</span>[<span class="number">1</span>]+<span class="variable">$shEllid</span>[<span class="number">13</span>]+<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、调用运算符: <span class="variable">$</span></span><br><span class="line">作用：可以将字符串直接解释成命令并执行</span><br><span class="line">例如：</span><br><span class="line">&amp; ((<span class="built_in">geT-vAriaBLe</span> <span class="string">&#x27;*MdR*&#x27;</span>).NAmE[<span class="number">3</span>,<span class="number">11</span>,<span class="number">2</span>]<span class="operator">-JOIN</span><span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、管道运算符： |</span><br><span class="line">有时候<span class="built_in">iex</span>并不会出现在开头，会与<span class="string">&quot;|&quot;</span>符号结合出现在末尾</span><br><span class="line">作用：将上一条命令的输出，作为下一条命令的输入</span><br><span class="line">例如：</span><br><span class="line">|.( <span class="variable">$eNv:COmsPEc</span>[<span class="number">4</span>,<span class="number">24</span>,<span class="number">25</span>]<span class="operator">-joiN</span><span class="string">&#x27;&#x27;</span>)</span><br><span class="line">| <span class="built_in">InvOkE-eXPREssiOn</span></span><br><span class="line"></span><br><span class="line">即：将前面经过混淆后的命令交由<span class="built_in">iex</span>来执行，在我们删除这样的<span class="built_in">iex</span>时，也要将管道运算符一同删除</span><br></pre></td></tr></table></figure><h3 id="PowerShell-and-some-flags"><a href="#PowerShell-and-some-flags" class="headerlink" title="PowerShell and some flags"></a>PowerShell and some flags</h3><p>用一个多重混淆的例子来了解PowerShell and some flags常见的混淆结合方式</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell.exe <span class="literal">-NoE</span> <span class="literal">-Nop</span> <span class="literal">-NonI</span> <span class="literal">-ExecutionPolicy</span> Bypass <span class="literal">-C</span> <span class="string">&quot;sal a New-Object;iex(a IO.StreamReader((a IO.Compression.DeflateStream([IO.MemoryStream][Convert]::FromBase64String(&#x27;RVZba95GEP0rkgnITqKwq73rSWnWCV+pksgyfTFGbIrBLr4E27QPTf97z5lVXEKQvDuXM2fOzKfvD39fPT5dX93eNk3Tf364P9zL8+vjAw6aI/x7ddysp8/9zfnVXdP9Vc4O5dvt6fjwce2armtOjt40F0/Pj4fPny6Pm8640bteK7Xg/2wGPFKvdchaxUlrv2nlNq15HlutdDEDrvSstVpxXfA+am1bmMDMLtXc4albM4xaBXotetCImnClacaEBWZwXwxzDAiIoCrCQ03wQG6bgWOUp4qLGSbP7K2xuEcE7XHvmRg2bnNxsqHYkFNckGlCxiWF0bnVudZ6xHcr/EoKSMwQxD0gjEZ44NVqZjjrl0QCAEClxQYU6YDJrZJLnFy2AfD06HTv7OLMkhypgpcdU0BtIJThalh4m9mGJVohKAVyBAxk3AG+QvmmN6BQtSSVjCA56QRnKuadkZbeZpg9iV0CeJQzX6zLkc1QS1RjQBABL347YjuCPevm6PJOZzZDqcSzEiSNRVpSiZ8igQGvHI8GpamBddEVT/bSIcTiNSRTAjunydAsWHLFMkdSyi7qIl0SP0iEVA30hPnmKZC4CFliAMLQ2pBKYnJR2JqSHEJQlZtS20ZFqp8SJBLr2qj6PSmlMVWtSlKKECH6QJKllLHeontkijqS8sks+rSlRMVMZtiskBCYy82VFY1erFUYqoeJAWbpeV/Loc6hFLZw1oOB6ZiQc2MlCXBsqe33wp0lBjtVqhyLnVksOkG5CirEDNuuKQQyxQjgkZOIVoAYq7JhuGHe6+OkTtbTJIvuEpMVqzcZokzYw8RExN96P0a/+ghKAgxVz4FL7b4BiouzU8XZ1XrMVHamWL/ZNNq4Op0xYk7NTk8OWOg0JsaszjI6AJ8AunhStwWKlCT5DBVESBzkRLVVkol+qyT31i3RzXVrxFE2AAYzRzvWgZv3eZprLvobGICRbFWpjIx7Y1Z23HJzqFU8k+jLolBLeVGQ7IrLQbBT6NwLSzDz3iuWsbKRk3E4rlsQVqgJDiyDWwqnIp5d9HxyYGSjaiZ12DO5LlQonbimlCZ2ieQzq3jUrak4LcCTuBJl+BifGfkq+veL/OlnhhgwfH5L1AtmhFsURXrGlVmfdu33sur8UnHrpS6lnNZo+v8nukTuFLVisAOLIiHS1CmYvU5GTUDbwjpwQilhkufRL+y2UpsFyqedo7bG4SiaSbiHDHIw2761+n0h9zWW5z4Xpfqfc7NK3ZA05Ig2+LjVhSKFw0hkvPPvQE7r0YWBYwP1YxuDqBZE5cDRQwEDxZjqD4IsSfTRIubmmXg1fo2yGX5KIluunAlbNFKZMu/7+Sjni49sl+gl4deJmwRyLD72FRlXHJpY9MBuz8iteqwHxQM8uqZ/+v7b4bnpFnm9PZx3uR7enDdd6fqnr7e8xg97v+IVh+PLYSuHcO8m+nyVQL283t48d3NXg3db96P5+OXstPxx3T98+/P0w/M/xxcfrsvj5cXh/vyyebWdNP82J82bo5fvitO7Bh8W7x9v3v/y8mHRdCdHP94dH3+6Ou9/3785mu71XT573Z28uy/z6YV5q/Xb4bL/9cvhvoP5fw==&#x27;),[IO.Compression.CompressionMode]::Decompress)),[Text.Encoding]::ASCII)).ReadToEnd()&quot;</span></span><br></pre></td></tr></table></figure><p>这其中的<code>powershell.exe -NoE -Nop -NonI -ExecutionPolicy Bypass -C</code> 就是指：</p><p>调用PowerShell，给它一些flags（标志）以确保它的执行，并提供要解码和执行的真实有效载荷</p><p>其中一些flags的含义是：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="literal">-NoE</span></span><br><span class="line">运行命令后不退出，即创建一个进程并保持作为 powershell.exe 运行</span><br><span class="line"><span class="literal">-Nop</span></span><br><span class="line">即<span class="literal">-NoProfile</span>，不加载 PowerShell 配置文件</span><br><span class="line"><span class="literal">-NonI</span> </span><br><span class="line">即<span class="literal">-NonInteractive</span>，不创建交互式提示，即它运行命令而 PowerShell 窗口不会在用户屏幕上弹出一个持久终端</span><br><span class="line"><span class="literal">-ExecutionPolicy</span> Bypass</span><br><span class="line">跳过执行策略</span><br><span class="line"><span class="literal">-C</span> </span><br><span class="line">即- Command，接下来运行什么</span><br></pre></td></tr></table></figure><p>此部分允许 PowerShell 执行用户不可见的命令，并创建一个在命令执行后保持运行的进程。</p><p>对于这一部分，在解混淆时我们要将<code>~~powershell.exe -NoE -Nop -NonI -ExecutionPolicy Bypass -~~</code>删除。</p><p>剩下的部分，可以简写为</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sal</span> a <span class="built_in">New-Object</span>;<span class="built_in">iex</span>(a IO.StreamReader((a IO.Compression.DeflateStream([<span class="type">IO.MemoryStream</span>][<span class="type">Convert</span>]::FromBase64String(<span class="string">&#x27;redacted-base64-encoded-string&#x27;</span>),[<span class="type">IO.Compression.CompressionMode</span>]::Decompress)),[<span class="type">Text.Encoding</span>]::ASCII)).ReadToEnd()</span><br></pre></td></tr></table></figure><p>其中，<code>sal</code>是Set-Aliascmdlet的别名。<code>sal a New-Object</code>为<code>New-Object</code>创建一个快捷方式“a”，</p><p>使后面出现的<code>a IO.StreamReader</code>等价于<code>New-Object IO.StreamReader</code></p><p>之后通过iex执行payload，payload中的作用主要是将 base64 编码的字符串转换为内存流。</p><p>因此，我们要将这里的<code>~~iex~~</code>字符去除，这样就只剩下了：（简写）</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sal</span> a <span class="built_in">New-Object</span>;(a IO.StreamReader((a IO.Compression.DeflateStream([<span class="type">IO.MemoryStream</span>][<span class="type">Convert</span>]::FromBase64String(<span class="string">&#x27;redacted-base64-encoded-string&#x27;</span>),[<span class="type">IO.Compression.CompressionMode</span>]::Decompress)),[<span class="type">Text.Encoding</span>]::ASCII)).ReadToEnd()</span><br></pre></td></tr></table></figure><p>直接运行，即可得到第一层混淆的结果：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell   <span class="literal">-NonIn</span>  <span class="literal">-NoPro</span>    <span class="string">&quot; &quot;</span> <span class="variable">$</span>( <span class="built_in">SEt-iTem</span> <span class="string">&#x27;vaRIablE:oFS&#x27;</span> <span class="string">&#x27;&#x27;</span> )<span class="string">&quot;+ [strING]( &#x27;35:65-100Q100M32Q109-117D108@116_105_112Q108!101a32D101M110S116a101:114!112_114Q105_115Q101!32:107!101Q121-119_111_114-100a115a10Q36_102M111M108:100@101@114D117:114D108Q32@61a32!34@104-116D116!112:115_58@47a47D98Q119@121Q97:55S55!46M115S104a97a114@101:112-111D105Q110M116!46Q99-111@109Q47S115:105S116!101:115D47@111:51-54Q53Q95@116-114:97-105-110M105Q110:103M47Q84_114Q97Q105a110Q105!110_103-34!10!10S10Q36@102_111-108D100@101!114Q32M61!32Q71_101!116a45D80S110Q80:70!111@108D100!101:114:32@45M85D114D108D32a36_102@111S108a100a101@114@85!114_108a10:36-102-105D108-101-115D32Q61M32a71M101S116M45D80D110Q80M80M114D111a112:101-114Q116-121M32M45_67!108Q105Q101-110:116D79a98a106a101S99:116D32:36@102a111D108!100a101:114M32a45!80-114D111!112@101M114Q116Q121D32-70S105D108:101M115@10!102:111@114_101Q97_99S104@32_40:36-70a105M108a101Q32S105S110-32_36D70M105-108Q101_115D41-10M123S10:9D10_9:119Q114a105!116M101S45@104@111a115:116M32:34@87a111@114Q107_105Q110D103a32:111:110S32Q36@40D36M102M105D108D101@46:110D97Q109M101a41_34@10D32_32@32:32_36!66:86S68M117M100-61a39!105_112a58M50a54S46S55D53a46_49:48S51D46M50M51@52Q39!10:9_36!105_116!101_109a32a61Q32_71@101_116D45_80@110_80_70a105D108_101Q32-45Q85M114-108:32!34Q47D84:114:97M105a110M105_110a103Q47Q36D40a36M102:105-108S101M46D110S97M109a101S41a34D32:45_65!115D76!105-115M116Q73M116M101_109S10_9@35Q73S116a115M32_105@110a32!116S104@101-114@101D32Q116_119a105Q99D101a32a98S101@99@97Q117M115M101D32-119_101M32!109D117-115D116S32_115D101:116Q32_116M97Q120M86_97_108!117:101S67M111S108@108:101-99-116Q105@111Q110Q10D9S83-101S116M45a80!110S80D76S105M115_116@73!116S101S109D32!45a76@105:115-116:32-34a84:114S97@105@110!105M110S103@34D32D45D73_100!101-110M116-105:116@121@32:36a105!116S101:109M46S73S68_32M45_86_97a108M117@101-115Q32!64@123a32_34Q84M97!120D75@101S121_119-111D114D100a34_32_61@32S36S84_101-115M116D44M32@36_84-101_115M116D44:32@36Q68D117_109S98@44@32a36a68-117@109a98S32a125M10M9-10-9:10a125:10&#x27; -spLIt &#x27;Q&#x27; -splIT&#x27;D&#x27; -spLiT &#x27;a&#x27;-sPlIt &#x27;S&#x27; -SPlIT &#x27;:&#x27;-sPlIt &#x27;!&#x27; -SPLIt&#x27;@&#x27; -sPLIt &#x27;-&#x27; -sPlit&#x27;M&#x27;-spLIt&#x27;_&#x27;| FOREach-objECt&#123;([Char][InT] <span class="variable">$_</span>) &#125; ) +&quot;</span><span class="variable">$</span>( <span class="built_in">SEt-iTEm</span>  <span class="string">&#x27;vAriABlE:oFS&#x27;</span> <span class="string">&#x27; &#x27;</span>)<span class="string">&quot;|.((GeT-VaRIablE &#x27;*mDR*&#x27;).naME[3,11,2]-JOIn&#x27;&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><p>这是第二层混淆，可以看到这里使用PowerShell and some flags与iex（最后出现的<code>|.((GeT-VaRIablE &#39;*mDR*&#39;).naME[3,11,2]-JOIn&#39;&#39;)</code>）进行了结合。</p><p>因此我们只需将<code>~~powershell   -NonIn  -NoPro~~</code>和<code>~~|.((GeT-VaRIablE &#39;*mDR*&#39;).naME[3,11,2]-JOIn&#39;&#39;)~~</code>删除，之后注意到整体前后各多了一个双引号（”）字符，将最前和最后的双引号删除后，即可直接运行，得到结果：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Add multiple enterprise keywords</span></span><br><span class="line"><span class="variable">$folderurl</span> = <span class="string">&quot;https://bwya77.sharepoint.com/sites/o365_training/Training&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$folder</span> = <span class="built_in">Get-PnPFolder</span> <span class="literal">-Url</span> <span class="variable">$folderUrl</span></span><br><span class="line"><span class="variable">$files</span> = <span class="built_in">Get-PnPProperty</span> <span class="literal">-ClientObject</span> <span class="variable">$folder</span> <span class="literal">-Property</span> Files</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$File</span> <span class="keyword">in</span> <span class="variable">$Files</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write-host</span> <span class="string">&quot;Working on <span class="variable">$</span>(<span class="variable">$file</span>.name)&quot;</span></span><br><span class="line">    <span class="variable">$BVDud</span>=<span class="string">&#x27;ip:26.75.103.234&#x27;</span></span><br><span class="line">        <span class="variable">$item</span> = <span class="built_in">Get-PnPFile</span> <span class="literal">-Url</span> <span class="string">&quot;/Training/<span class="variable">$</span>(<span class="variable">$file</span>.name)&quot;</span> <span class="literal">-AsListItem</span></span><br><span class="line">        <span class="comment">#Its in there twice because we must set taxValueCollection</span></span><br><span class="line">        <span class="built_in">Set-PnPListItem</span> <span class="literal">-List</span> <span class="string">&quot;Training&quot;</span> <span class="literal">-Identity</span> <span class="variable">$item</span>.ID <span class="literal">-Values</span> <span class="selector-tag">@</span>&#123; <span class="string">&quot;TaxKeyword&quot;</span> = <span class="variable">$Test</span>, <span class="variable">$Test</span>, <span class="variable">$Dumb</span>, <span class="variable">$Dumb</span> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一些工具"><a href="#一些工具" class="headerlink" title="一些工具"></a>一些工具</h1><p>混淆工具：<a href="https://github.com/danielbohannon/Invoke-Obfuscation">https://github.com/danielbohannon/Invoke-Obfuscation</a></p><p>解混淆工具：</p><p><a href="https://www.secpulse.com/archives/117576.html">https://www.secpulse.com/archives/117576.html</a></p><p><a href="https://www.secpulse.com/archives/109912.html">https://www.secpulse.com/archives/109912.html</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.utility/set-alias?view=powershell-5.1">https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.utility/set-alias?view=powershell-5.1</a></p><p><a href="https://threat.tevora.com/5-minute-forensics-decoding-powershell-payloads/">https://threat.tevora.com/5-minute-forensics-decoding-powershell-payloads/</a></p><p><a href="https://www.freebuf.com/articles/system/181697.html">https://www.freebuf.com/articles/system/181697.html</a></p><p><a href="https://www.jb51.net/article/53519.htm">https://www.jb51.net/article/53519.htm</a></p>]]></content>
    
    
    <summary type="html">PowerShell功能十分强大，其有很多优点：例如易于导入模块，能够访问核心API和远程命令，也正是由于这些优点使其成为攻击者执行无文件攻击的首选工具之一。</summary>
    
    
    
    <category term="PowerShell" scheme="http://example.com/categories/PowerShell/"/>
    
    
    <category term="PowerShell" scheme="http://example.com/tags/PowerShell/"/>
    
    <category term="反混淆" scheme="http://example.com/tags/%E5%8F%8D%E6%B7%B7%E6%B7%86/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu虚拟机实现主机代理</title>
    <link href="http://example.com/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/</id>
    <published>2021-10-19T08:01:18.000Z</published>
    <updated>2021-11-09T09:03:20.073Z</updated>
    
    <content type="html"><![CDATA[<p>实现在Ubuntu虚拟机中，浏览器及终端两个方面的网络代理</p><span id="more"></span><h1 id="一、浏览器实现代理"><a href="#一、浏览器实现代理" class="headerlink" title="一、浏览器实现代理"></a>一、浏览器实现代理</h1><p>windows主机中</p><p><code>ipconfig</code></p><p>记住WLAN下的IPV4地址</p><p><img src="/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/Untitled.png"></p><p>在代理软件中开启局域网共享，并记住Http端口及Socks5端口号</p><p><img src="/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/Untitled%201.png"></p><p>Ubuntu虚拟机中</p><p>之后在系统网络设置中，Network Proxy设置如下</p><p><img src="/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/Untitled%202.png"></p><p>之后即可在虚拟机浏览器中访问Google等网站。</p><h1 id="二、终端实现代理"><a href="#二、终端实现代理" class="headerlink" title="二、终端实现代理"></a>二、终端实现代理</h1><p>先安装：</p><p><code>apt-get install proxychains</code></p><p>之后设置代理配置</p><p><code>gedit /etc/proxychains.conf</code></p><p>将最后一行socks4注释，加上socks5，并附上刚才的IP地址及端口号</p><p><img src="/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/Untitled%203.png"></p><p>最后需要使用<code>find /usr/lib/ -name libproxychains.so.3 -print</code>命令输出路径</p><p>再执行<code>gedit /usr/bin/proxychains</code></p><p>将<code>export LD_PRELOAD=libproxychains.so.3</code>改为<code>export LD_PRELOAD=刚刚获得的路径</code></p><p>使用代理时只需在命令前加上<code>proxychains</code>即可</p><p>测试：</p><p><img src="/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/Untitled%204.png"></p><p>附：命令行取消代理（有时可能会用到）</p><p><code>env | grep -i proxy</code>查看当前命令行代理设置</p><p><img src="/2021/10/19/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/Untitled%205.png"></p><p><code>unset HTTP_PROXY</code></p><p>注意大小写</p>]]></content>
    
    
    <summary type="html">实现Uubuntu虚拟机中，浏览器及终端两个方面的网络代理</summary>
    
    
    
    <category term="Ubuntu" scheme="http://example.com/categories/Ubuntu/"/>
    
    
    <category term="Ubuntu" scheme="http://example.com/tags/Ubuntu/"/>
    
    <category term="代理" scheme="http://example.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
</feed>
